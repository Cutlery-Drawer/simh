
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

    <title>1. Adding an I/O device to a SIMH virtual machine &#8212; Python  documentation</title>
    <link rel="stylesheet" type="text/css" href="static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="static/alabaster.css" />
    <script data-url_root="./" id="documentation_options" src="static/documentation_options.js"></script>
    <script src="static/jquery.js"></script>
    <script src="static/underscore.js"></script>
    <script src="static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="static/doctools.js"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Simulators: virtual machines of the past and future" href="simulators_acm_queue_2004.html" />
    <link rel="prev" title="SIMH magtape representation and handling" href="simh_magtape.html" />
   
  <link rel="stylesheet" href="static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="adding-an-i-o-device-to-a-simh-virtual-machine">
<h1><span class="sectnum">1. </span>Adding an I/O device to a SIMH virtual machine<a class="headerlink" href="#adding-an-i-o-device-to-a-simh-virtual-machine" title="Permalink to this heading">¶</a></h1>
<dl class="field-list simple">
<dt class="field-odd">Date<span class="colon">:</span></dt>
<dd class="field-odd"><p>2016-03-17</p>
</dd>
<dt class="field-even">Version<span class="colon">:</span></dt>
<dd class="field-even"><p>4.0</p>
</dd>
<dt class="field-odd">Revision<span class="colon">:</span></dt>
<dd class="field-odd"><p>$Format:%H$</p>
</dd>
<dt class="field-even">Copyright<span class="colon">:</span></dt>
<dd class="field-even"><p>See <a class="reference external" href="../LICENSE.txt">LICENSE.txt</a> for terms of use.</p>
</dd>
</dl>
<p>This memo provides more detail on adding I/O device simulators to the various virtual machines supported by SIMH.</p>
<section id="scp-and-i-o-device-interactions">
<h2><span class="sectnum">1.1. </span>SCP and I/O device interactions<a class="headerlink" href="#scp-and-i-o-device-interactions" title="Permalink to this heading">¶</a></h2>
<section id="the-scp-interface">
<h3><span class="sectnum">1.1.1. </span>The SCP interface<a class="headerlink" href="#the-scp-interface" title="Permalink to this heading">¶</a></h3>
<p>The simulator control package (SCP) finds devices through the device list,
<code class="docutils literal notranslate"><span class="pre">DEVICE</span> <span class="pre">*sim_devices</span></code>.
This list, defined in <code class="docutils literal notranslate"><span class="pre">&lt;simname&gt;_sys.c</span></code>,
must be modified to add the <code class="docutils literal notranslate"><span class="pre">DEVICE</span></code> data structure(s) of the new device to <code class="docutils literal notranslate"><span class="pre">sim_devices</span></code>:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">extern</span><span class="w"> </span><span class="n">DEVICE</span><span class="w"> </span><span class="n">new_device</span><span class="p">;</span><span class="w"></span>
<span class="cm">/* ⋮ */</span><span class="w"></span>
<span class="n">DEVICE</span><span class="w"> </span><span class="o">*</span><span class="n">sim_devices</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="o">&amp;</span><span class="n">cpu_dev</span><span class="p">,</span><span class="w"></span>
<span class="cm">/* ⋮ */</span><span class="w"></span>
<span class="w">    </span><span class="o">&amp;</span><span class="n">new_device</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="nb">NULL</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>
</div>
<p>The device then defines data structures for UNITs, REGISTERs, and, if required, options.</p>
</section>
<section id="i-o-interface-requirements">
<h3><span class="sectnum">1.1.2. </span>I/O interface requirements<a class="headerlink" href="#i-o-interface-requirements" title="Permalink to this heading">¶</a></h3>
<p>SCP provides interfaces to attach files to, and detach them from, I/O devices,
and to examine and modify the contents of attached files.
SCP expects devices to store individual data words right-aligned in container words.
The container words should be the next largest power of 2 in width:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Data word</p></th>
<th class="head"><p>Container word</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>1b to 8b</p></td>
<td><p>8b</p></td>
</tr>
<tr class="row-odd"><td><p>9b to 16b</p></td>
<td><p>16b</p></td>
</tr>
<tr class="row-even"><td><p>17b to 32b</p></td>
<td><p>32b</p></td>
</tr>
<tr class="row-odd"><td><p>33b to 64b</p></td>
<td><p>64b (requires compile flag <code class="docutils literal notranslate"><span class="pre">-DUSE_INT64</span></code>)</p></td>
</tr>
</tbody>
</table>
</section>
<section id="save-restore-interactions">
<h3><span class="sectnum">1.1.3. </span>Save/restore interactions<a class="headerlink" href="#save-restore-interactions" title="Permalink to this heading">¶</a></h3>
<p>The Save/Restore capability allows simulations to be stopped, saved, resumed, and repeated.
For save and restore to work properly,
I/O devices must save and restore all state required for operation.
This includes control registers, working registers, intermediate buffers, and mode flags.</p>
<p>Save and restore automatically handle the following state items:</p>
<ul class="simple">
<li><p>Content of declared registers.</p></li>
<li><p>Content of memory-like structures.</p></li>
<li><p>Device user-specific flags and <code class="docutils literal notranslate"><span class="pre">DEV_DIS</span></code>.</p></li>
<li><p>Whether each unit is attached to a file and, if so, the filename.</p></li>
<li><p>Whether each unit is active, and, if so, the unit time out.</p></li>
<li><p>Unit U3-U6 words.</p></li>
<li><p>Unit user-specific flags and <code class="docutils literal notranslate"><span class="pre">UNIT_DIS</span></code>.</p></li>
</ul>
<p>There are two methods for handling intermediate buffers.
First, the buffer can be made accessible as unit memory.
This requires buffer-specific examine and deposit routines.
Alternately, the buffer can be declared as an arrayed register.</p>
</section>
</section>
<section id="pdp-8">
<h2><span class="sectnum">1.2. </span>PDP-8<a class="headerlink" href="#pdp-8" title="Permalink to this heading">¶</a></h2>
<section id="cpu-and-i-o-device-structures">
<h3><span class="sectnum">1.2.1. </span>CPU and I/O device structures<a class="headerlink" href="#cpu-and-i-o-device-structures" title="Permalink to this heading">¶</a></h3>
<p>Simulated memory is kept in array <code class="docutils literal notranslate"><span class="pre">uint16 M[MAXMEMSIZE]</span></code>.
12b words are right-justified in each array entry;
the high-order 4b must be zero.</p>
<p>The interrupt structure is implemented in three parallel variables:</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int32</span> <span class="pre">int_req</span></code></dt><dd><p>Interrupt requests.
The two high-order bits are the interrupt enable flag
and the interrupts-not-deferred flag</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int32</span> <span class="pre">dev_done</span></code></dt><dd><p>Device done flags</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int32</span> <span class="pre">int_enable</span></code></dt><dd><p>Device interrupt enable flags</p>
</dd>
</dl>
<p>A device without interrupt control keeps its interrupt request,
which is also the device done flag, in <code class="docutils literal notranslate"><span class="pre">int_req</span></code>.
A device with interrupt control keeps its interrupt request in <code class="docutils literal notranslate"><span class="pre">dev_done</span></code> and its interrupt enable flag in <code class="docutils literal notranslate"><span class="pre">int_enable</span></code>.
Pictorially,</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>╒════╤════╕╌╒════╤════╕╌╒════╤════╤════╕
│ion │indf│ │irq1│irq2│ │irqx│irqy│irqz│ irq_req
╘════╧════╛╌╘════╧════╛╌╘════╧════╧════╛

╒════╤════╕╌╒════╤════╕╌╒════╤════╤════╕
│ 0  │ 0  │ │ 0  │ 0  │ │donx│dony│donz│ dev_done
╘════╧════╛╌╘════╧════╛╌╘════╧════╧════╛

╒════╤════╕╌╒════╤════╕╌╒════╤════╤════╕
│ 0  │ 0  │ │ 0  │ 0  │ │enbx│enby│enbz│ int_enable
╘════╧════╛╌╘════╧════╛╌╘════╧════╧════╛
╷         ╷ ╷         ╷ ╷              ╷
╰────┬────╯ ╰────┬────╯ ╰──────┬───────╯
   fixed      no enbl     with enable
</pre></div>
</div>
<p>Logically, the relationship is</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">int_req</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">int_req</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="p">(</span><span class="n">OVHD</span><span class="o">+</span><span class="n">NOENB</span><span class="p">))</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="p">(</span><span class="n">dev_done</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">dev_enable</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>Macro <code class="docutils literal notranslate"><span class="pre">INT_UPDATE</span></code> maintains this relationship after a change to any of the three variables.</p>
<p>Device enable flags are kept in <code class="docutils literal notranslate"><span class="pre">dev_enb</span></code>.
The device enable flag,
by convention,
is the same bit position as device interrupt flag.</p>
<p>I/O dispatching is done by explicit case decoding in the IOT instruction flow for CPU IOTs,
and dispatch through table <code class="docutils literal notranslate"><span class="pre">dev_tab[64]</span></code> for devices.
Each entry in <code class="docutils literal notranslate"><span class="pre">dev_tab</span></code> is a pointer to a device IOT processing routine.
The calling sequence for the IOT routine is:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">new_data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">iot_routine</span><span class="w"> </span><span class="p">(</span><span class="n">IOT</span><span class="w"> </span><span class="n">instruction</span><span class="p">,</span><span class="w"> </span><span class="n">current</span><span class="w"> </span><span class="n">AC</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>where</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">new_data</span><span class="o">&lt;</span><span class="mi">11</span><span class="p">:</span><span class="mi">0</span><span class="o">&gt;</span>             <span class="o">=</span>  <span class="n">New</span> <span class="n">contents</span> <span class="n">of</span> <span class="n">AC</span>
<span class="n">new_data</span><span class="o">&lt;</span><span class="n">IOT_V_SKP</span><span class="o">&gt;</span>        <span class="o">=</span>  <span class="mi">1</span> <span class="k">if</span> <span class="n">skip</span><span class="p">,</span> <span class="mi">0</span> <span class="k">if</span> <span class="ow">not</span>
<span class="n">new_data</span><span class="o">&lt;</span><span class="mi">31</span><span class="p">:</span><span class="n">IOT_V_REASON</span><span class="o">&gt;</span>  <span class="o">=</span>  <span class="n">Stop</span> <span class="n">code</span><span class="p">,</span> <span class="k">if</span> <span class="n">non</span><span class="o">-</span><span class="n">zero</span>
</pre></div>
</div>
</section>
<section id="device-context-and-flags">
<h3><span class="sectnum">1.2.2. </span><code class="docutils literal notranslate"><span class="pre">DEVICE</span></code> context and flags<a class="headerlink" href="#device-context-and-flags" title="Permalink to this heading">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">DEVICE</span></code> <strong>ctxt</strong> (context) field must point to the device information block (DIB), if one exists.
The <code class="docutils literal notranslate"><span class="pre">DEVICE</span></code> <strong>flags</strong> field must specify whether the device supports the <code class="docutils literal notranslate"><span class="pre">SET</span> <span class="pre">ENABLED</span></code>/<code class="docutils literal notranslate"><span class="pre">SET</span> <span class="pre">DISABLED</span></code> commands (<code class="docutils literal notranslate"><span class="pre">DEV_DISABLE</span></code>).
If a device can be disabled,
the state of the device flag&lt;DEV_DIS&gt; must be declared as a register for <code class="docutils literal notranslate"><span class="pre">SAVE</span></code>/<code class="docutils literal notranslate"><span class="pre">RESTORE</span></code>.</p>
</section>
<section id="adding-a-new-i-o-device">
<h3><span class="sectnum">1.2.3. </span>Adding a new I/O device<a class="headerlink" href="#adding-a-new-i-o-device" title="Permalink to this heading">¶</a></h3>
<section id="defining-the-device-number-and-done-interrupt-flag">
<h4><span class="sectnum">1.2.3.1. </span>Defining the device number and Done/Interrupt flag<a class="headerlink" href="#defining-the-device-number-and-done-interrupt-flag" title="Permalink to this heading">¶</a></h4>
<p>Module <code class="docutils literal notranslate"><span class="pre">pdp8_defs.h</span></code> must be modified to add the device number definitions and the device interrupt flag definitions.
The device number is the lowest device number that the device responds to (e.g., 060 for the RL8A):</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#define DEV_NEW         0nn                     </span><span class="cm">/* not 0,010,020-027 */</span><span class="cp"></span>
</pre></div>
</div>
<p>If the device has a separate interrupt enable,
the interrupt flag must be added above <code class="docutils literal notranslate"><span class="pre">INT_V_DIRECT</span></code>,
and the latter increased accordingly:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#define INT_V_TTI4      (INT_V_START+13)        </span><span class="cm">/* clock */</span><span class="cp"></span>
<span class="cp">#define INT_V_NEW       (INT_V_START+14)        </span><span class="cm">/* new */</span><span class="cp"></span>
<span class="cp">#define INT_V_DIRECT    (INT_V_START+15)        </span><span class="cm">/* direct start */</span><span class="cp"></span>
<span class="cm">/* ⋮ */</span><span class="w"></span>
<span class="cp">#define INT_NEW         (1 &lt;&lt; INT_V_NEW)</span>
</pre></div>
</div>
<p>If the device has only an interrupt/done flag,
it must be added between <code class="docutils literal notranslate"><span class="pre">INT_V_DIRECT</span></code> and <code class="docutils literal notranslate"><span class="pre">INT_V_OVHD</span></code>,
and the latter increased accordingly:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#define INT_V_UF        (INT_V_DIRECT+8)        </span><span class="cm">/* user int */</span><span class="cp"></span>
<span class="cp">#define INT_V_NEW       (INT_V_DIRECT+9)        </span><span class="cm">/* new */</span><span class="cp"></span>
<span class="cp">#define INT_V_OVHD      (INT_V_DIRECT+10)       </span><span class="cm">/* overhead start */</span><span class="cp"></span>
<span class="cm">/* ⋮ */</span><span class="w"></span>
<span class="cp">#define INT_NEW         (1 &lt;&lt; INT_V_NEW)</span>
</pre></div>
</div>
</section>
<section id="adding-the-device-information-block">
<h4><span class="sectnum">1.2.3.2. </span>Adding the device information block<a class="headerlink" href="#adding-the-device-information-block" title="Permalink to this heading">¶</a></h4>
<p>The device information block is declared in the device module, as follows:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">int32</span><span class="w"> </span><span class="nf">iotrtn1</span><span class="w"> </span><span class="p">(</span><span class="n">int32</span><span class="w"> </span><span class="n">instruction</span><span class="p">,</span><span class="w"> </span><span class="n">int32</span><span class="w"> </span><span class="n">AC</span><span class="p">);</span><span class="w"></span>
<span class="n">int32</span><span class="w"> </span><span class="nf">iotrtn2</span><span class="w"> </span><span class="p">(</span><span class="n">int32</span><span class="w"> </span><span class="n">instruction</span><span class="p">,</span><span class="w"> </span><span class="n">int32</span><span class="w"> </span><span class="n">AC</span><span class="p">);</span><span class="w"></span>
<span class="cm">/* ⋮ */</span><span class="w"></span>
<span class="n">DIB</span><span class="w"> </span><span class="n">dev_dib</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">DEV_NEW</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">num_iot_routines</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"> </span><span class="o">&amp;</span><span class="n">iotrtn1</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">iotrn2</span><span class="p">,</span><span class="w"> </span><span class="cm">/* … */</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">DEV_NEW</span></code> is the device number,
and <code class="docutils literal notranslate"><span class="pre">num_iot_routines</span></code> is the number of IOT dispatch routines
(allocated contiguously starting at <code class="docutils literal notranslate"><span class="pre">DEV_NEW</span></code>).
If a device number in the range defined by [<code class="docutils literal notranslate"><span class="pre">DEV_NEW</span></code>, <code class="docutils literal notranslate"><span class="pre">DEV_NEW</span></code> + <code class="docutils literal notranslate"><span class="pre">num_iot_routines</span></code> − 1] is not needed,
the corresponding dispatch address should be <code class="docutils literal notranslate"><span class="pre">NULL</span></code>.</p>
</section>
</section>
</section>
<section id="pdp-4-7-9-15">
<h2><span class="sectnum">1.3. </span>PDP-4/7/9/15<a class="headerlink" href="#pdp-4-7-9-15" title="Permalink to this heading">¶</a></h2>
<section id="id1">
<h3><span class="sectnum">1.3.1. </span>CPU and I/O Device Structures<a class="headerlink" href="#id1" title="Permalink to this heading">¶</a></h3>
<p>Simulated memory is kept in an array <code class="docutils literal notranslate"><span class="pre">*M</span></code>, dynamically allocated.
18b words are right-justified in each array entry;
the high-order 14b must be zero.</p>
<p>The interrupt structure is implemented in an array <code class="docutils literal notranslate"><span class="pre">int32 int_hwre[5]</span></code>,
corresponding to API (automatic priority interrupt) levels 0 through 3 and normal program interrupts,
if a device doesn’t support API.
Priority is from level 0 to level 4 (PI);
with a level, priority is right-to-left.
The API control variables are updated centrally;
an IO device only deals with <code class="docutils literal notranslate"><span class="pre">int_hwre</span></code>.</p>
<p>Device enable flags are kept in <code class="docutils literal notranslate"><span class="pre">dev_enb</span></code>.
The device enable flag, by convention,
is the same bit position as device interrupt flag.</p>
<p>I/O dispatching is done by explicit case decoding in the IOT instruction flow for CPU IOTs,
and dispatch through table <code class="docutils literal notranslate"><span class="pre">dev_tab[64]</span></code> for devices.
Each entry in <code class="docutils literal notranslate"><span class="pre">dev_tab</span></code> is a pointer to a device IOT processing routine.
The calling sequence for the IOT routine is:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">new_data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">iot_routine</span><span class="w"> </span><span class="p">(</span><span class="n">device</span><span class="p">,</span><span class="w"> </span><span class="n">pulse</span><span class="p">,</span><span class="w"> </span><span class="n">current</span><span class="w"> </span><span class="n">AC</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>where</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">device</span>                     <span class="o">=</span>  <span class="n">instruction</span><span class="o">&lt;</span><span class="mi">6</span><span class="p">:</span><span class="mi">11</span><span class="o">&gt;</span>
<span class="n">pulse</span>                      <span class="o">=</span>  <span class="n">instruction</span><span class="o">&lt;</span><span class="mi">12</span><span class="p">:</span><span class="mi">13</span><span class="s1">&#39;0&#39;</span><span class="mi">15</span><span class="p">:</span><span class="mi">17</span><span class="o">&gt;</span>
<span class="n">new_data</span><span class="o">&lt;</span><span class="mi">17</span><span class="p">:</span><span class="mi">0</span><span class="o">&gt;</span>             <span class="o">=</span>  <span class="n">new</span> <span class="n">contents</span> <span class="n">of</span> <span class="n">AC</span>
<span class="n">new_data</span><span class="o">&lt;</span><span class="n">IOT_V_SKP</span><span class="o">&gt;</span>        <span class="o">=</span>  <span class="mi">1</span> <span class="k">if</span> <span class="n">skip</span><span class="p">,</span> <span class="mi">0</span> <span class="k">if</span> <span class="ow">not</span>
<span class="n">new_data</span><span class="o">&lt;</span><span class="mi">31</span><span class="p">:</span><span class="n">IOT_V_REASON</span><span class="o">&gt;</span>  <span class="o">=</span>  <span class="n">stop</span> <span class="n">code</span><span class="p">,</span> <span class="k">if</span> <span class="n">non</span><span class="o">-</span><span class="n">zero</span>
</pre></div>
</div>
<p>Note that instruction <code class="docutils literal notranslate"><span class="pre">bit&lt;14&gt;</span></code> (clear AC) has been processed by the time the IOT routine is called and is always cleared.</p>
<p>If the device responds to the IORS instructions,
it must also have an IORS response routine:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">IORS_response</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">iors_routine</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>where</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">IORS</span> <span class="n">response</span>              <span class="o">=</span>  <span class="n">bit</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="n">to</span> <span class="nb">set</span> <span class="ow">in</span> <span class="n">IORS</span><span class="p">,</span> <span class="ow">or</span> <span class="mi">0</span>
</pre></div>
</div>
</section>
<section id="id2">
<h3><span class="sectnum">1.3.2. </span><code class="docutils literal notranslate"><span class="pre">DEVICE</span></code> context and flags<a class="headerlink" href="#id2" title="Permalink to this heading">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">DEVICE</span></code> <strong>ctxt</strong> (context) field must point to the device information block (DIB), if one exists.
The <code class="docutils literal notranslate"><span class="pre">DEVICE</span></code> <strong>flags</strong> field must specify whether the device supports the
<code class="docutils literal notranslate"><span class="pre">SET</span> <span class="pre">ENABLED</span></code>/<code class="docutils literal notranslate"><span class="pre">SET</span> <span class="pre">DISABLED</span></code> commands (<code class="docutils literal notranslate"><span class="pre">DEV_DISABLE</span></code>).
If a device can be disabled,
the state of the device flag&lt;DEV_DIS&gt; must be declared as a register for <code class="docutils literal notranslate"><span class="pre">SAVE</span></code>/<code class="docutils literal notranslate"><span class="pre">RESTORE</span></code>.</p>
</section>
<section id="id3">
<h3><span class="sectnum">1.3.3. </span>Adding a new I/O device<a class="headerlink" href="#id3" title="Permalink to this heading">¶</a></h3>
<section id="defining-the-device-number-and-interrupt-information">
<h4><span class="sectnum">1.3.3.1. </span>Defining the device number and interrupt information<a class="headerlink" href="#defining-the-device-number-and-interrupt-information" title="Permalink to this heading">¶</a></h4>
<p>Module <code class="docutils literal notranslate"><span class="pre">pdp18b_defs.h</span></code> must be modified to add the device number definitions,
the device interrupt flag definitions,
and the IORS response (if any).
The device number is the lowest device number that the device responds to (e.g., 063 for the RP15):</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#define DEV_NEW         0nn                     </span><span class="cm">/* not 0,033,055 */</span><span class="cp"></span>
</pre></div>
</div>
<p>The device must be assigned to an interrupt level and,
if it supports API,
an API channel.
Use the next unassigned bit number at the desired API level:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#define INT_V_dev_new   n                       </span><span class="cm">/* V -&gt; a bit number */</span><span class="cp"></span>
<span class="cp">#define INT_dev_new     (1u &lt;&lt; INT_V_new_dev)</span>
<span class="cp">#define API_dev_new     0, 1, 2, 3, or 4        </span><span class="cm">/* 4 means PI */</span><span class="cp"></span>
<span class="cp">#define ACH_dev_new     0mm                     </span><span class="cm">/* only if API */</span><span class="cp"></span>
</pre></div>
</div>
<p>If a device requires multiple interrupts,
this set of definitions must be repeated for each interrupt.</p>
<p>With these definitions,
IO devices can manipulate the interrupt system with simple macros:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">SET_INT</span><span class="w"> </span><span class="p">(</span><span class="n">dev_new</span><span class="p">)</span><span class="w">                         </span><span class="cm">/* set device interrupt */</span><span class="w"></span>
<span class="n">CLR_INT</span><span class="w"> </span><span class="p">(</span><span class="n">dev_new</span><span class="p">)</span><span class="w">                         </span><span class="cm">/* clr device interrupt */</span><span class="w"></span>
<span class="n">TST_INT</span><span class="w"> </span><span class="p">(</span><span class="n">dev_new</span><span class="p">)</span><span class="w">                         </span><span class="cm">/* test device interrupt */</span><span class="w"></span>
</pre></div>
</div>
<p>If the device responds to IORS,
an IORS response bit (or bits) should also be defined.</p>
</section>
<section id="id4">
<h4><span class="sectnum">1.3.3.2. </span>Adding the device information block<a class="headerlink" href="#id4" title="Permalink to this heading">¶</a></h4>
<p>The device information block is declared in the device module, as follows:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">int32</span><span class="w"> </span><span class="nf">iotrtn1</span><span class="w"> </span><span class="p">(</span><span class="n">int32</span><span class="w"> </span><span class="n">instruction</span><span class="p">,</span><span class="w"> </span><span class="n">int32</span><span class="w"> </span><span class="n">AC</span><span class="p">);</span><span class="w"></span>
<span class="n">int32</span><span class="w"> </span><span class="nf">iotrtn2</span><span class="w"> </span><span class="p">(</span><span class="n">int32</span><span class="w"> </span><span class="n">instruction</span><span class="p">,</span><span class="w"> </span><span class="n">int32</span><span class="w"> </span><span class="n">AC</span><span class="p">);</span><span class="w"></span>
<span class="n">int32</span><span class="w"> </span><span class="nf">iorsrtn</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="p">);</span><span class="w"></span>
<span class="cm">/* ⋮ */</span><span class="w"></span>
<span class="n">DIB</span><span class="w"> </span><span class="n">dev_dib</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">DEV_NEW</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">num_iot_routines</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">iorsrtn</span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="o">&amp;</span><span class="n">iotrtn1</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">iotrn2</span><span class="p">,</span><span class="w"> </span><span class="cm">/* … */</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">DEV_NEW</span></code> is the device number,
and <code class="docutils literal notranslate"><span class="pre">num_iot_routines</span></code> is the number of IOT dispatch routines
(allocated contiguously starting at <code class="docutils literal notranslate"><span class="pre">DEV_NEW</span></code>).
If a device number in the range defined by [<code class="docutils literal notranslate"><span class="pre">DEV_NEW</span></code>, <code class="docutils literal notranslate"><span class="pre">DEV_NEW</span></code> + <code class="docutils literal notranslate"><span class="pre">num_iot_routines</span></code> − 1] is not needed,
the corresponding dispatch address should be <code class="docutils literal notranslate"><span class="pre">NULL</span></code>.
If the device does not respond to IORS,
then <code class="docutils literal notranslate"><span class="pre">iorsrtn</span></code> should be NULL.</p>
</section>
</section>
</section>
<section id="pdp-11-microvax-3900-vax-780-and-pdp-10">
<h2><span class="sectnum">1.4. </span>PDP-11, MicroVAX 3900, VAX-780, and PDP-10<a class="headerlink" href="#pdp-11-microvax-3900-vax-780-and-pdp-10" title="Permalink to this heading">¶</a></h2>
<section id="memory">
<h3><span class="sectnum">1.4.1. </span>Memory<a class="headerlink" href="#memory" title="Permalink to this heading">¶</a></h3>
<p>For the PDP-11, simulated memory is kept in array <code class="docutils literal notranslate"><span class="pre">uint16</span> <span class="pre">*M</span></code>, dynamically allocated.
For the MicroVAX 3900 and VAX-780,
simulated memory is kept in array <code class="docutils literal notranslate"><span class="pre">uint32</span> <span class="pre">*M</span></code>, dynamically allocated.
For the PDP-10, simulated memory is kept in array <code class="docutils literal notranslate"><span class="pre">t_uint64</span> <span class="pre">*M</span></code>, dynamically allocated.
Because the three systems use different memory widths and different I/O mapping schemes,
DMA peripherals that are shared among them use interface routines to access memory.</p>
</section>
<section id="interrupt-structure">
<h3><span class="sectnum">1.4.2. </span>Interrupt structure<a class="headerlink" href="#interrupt-structure" title="Permalink to this heading">¶</a></h3>
<p>The interrupt structure is implemented by array <code class="docutils literal notranslate"><span class="pre">int_req</span></code>,
indexed by priority level
(except on the PDP-10, where all levels are kept in one word).
Each device is assigned a request flag in <code class="docutils literal notranslate"><span class="pre">int_req[device_IPL]</span></code>,
according to its priority,
with highest priority at the right (low-order bit).
To facilitate access to <code class="docutils literal notranslate"><span class="pre">int_req</span></code> across the three systems,
each device <em>dev</em> defines three variables:</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">INT_V_dev</span></code></dt><dd><p>The bit number of the device’s interrupt request flag.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">INT_dev</span></code></dt><dd><p>The mask of the device’s interrupt request flag.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IPL_dev</span></code></dt><dd><p>The index into <code class="docutils literal notranslate"><span class="pre">int_req</span></code> for the device’s priority level
(PDP-11, MicroVAX 3900, and VAX-780 only).</p>
</dd>
</dl>
<p>Four macros allow simulated devices to access and manipulate interrupt structures independent of the underlying VM:</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">IVCL</span> <span class="pre">(dev)</span></code></dt><dd><p>Vector locator for <code class="docutils literal notranslate"><span class="pre">DIB</span> <span class="pre">(IPL</span> <span class="pre">*</span> <span class="pre">32</span> <span class="pre">+</span> <span class="pre">bit</span> <span class="pre">number)</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IREQ</span> <span class="pre">(dev)</span></code></dt><dd><p>Resolves to <code class="docutils literal notranslate"><span class="pre">int_req[device_IPL]</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">CLR_INT</span> <span class="pre">(dev)</span></code></dt><dd><p>Clears the device’s interrupt request flag.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SET_INT</span> <span class="pre">(dev)</span></code></dt><dd><p>Sets the device’s interrupt request flag.</p>
</dd>
</dl>
</section>
<section id="i-o-dispatching">
<h3><span class="sectnum">1.4.3. </span>I/O dispatching<a class="headerlink" href="#i-o-dispatching" title="Permalink to this heading">¶</a></h3>
<section id="unibus-qbus-devices">
<h4><span class="sectnum">1.4.3.1. </span>Unibus/Qbus devices<a class="headerlink" href="#unibus-qbus-devices" title="Permalink to this heading">¶</a></h4>
<p>For Unibus and Qbus devices,
I/O dispatching is done by table-driven address decoding in the I/O page read and write routines.
Interrupt handling is done by table driven processing of vector and interrupt handling tables.
These tables are constructed at run time from device information blocks (DIBs).
Each I/O device has a DIB with the following information:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>{ IO page base address, IO page length, read_routine, write_routine,
  num_vectors, vector_locator, vector, { &amp;iack_rtn1, &amp;iack_rtn2, … } }
</pre></div>
</div>
<p>The calling sequence for an I/O read is:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">t_stat</span><span class="w"> </span><span class="n">read_routine</span><span class="w"> </span><span class="p">(</span><span class="n">int32</span><span class="w"> </span><span class="o">*</span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="n">int32</span><span class="w"> </span><span class="n">pa</span><span class="p">,</span><span class="w"> </span><span class="n">int32</span><span class="w"> </span><span class="n">access</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>The calling sequence for an I/O write is:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">t_stat</span><span class="w"> </span><span class="n">write_routine</span><span class="w"> </span><span class="p">(</span><span class="n">int32</span><span class="w"> </span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="n">int32</span><span class="w"> </span><span class="n">pa</span><span class="p">,</span><span class="w"> </span><span class="n">int32</span><span class="w"> </span><span class="n">access</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>For both, the <code class="docutils literal notranslate"><span class="pre">access</span></code> parameter can have one of the following values:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">READ</span>                     <span class="n">Normal</span> <span class="n">read</span>
<span class="n">READC</span>                    <span class="n">Console</span> <span class="n">read</span> <span class="p">(</span><span class="n">PDP</span><span class="o">-</span><span class="mi">11</span> <span class="n">only</span><span class="p">)</span>
<span class="n">WRITE</span>                    <span class="n">Word</span> <span class="n">write</span>
<span class="n">WRITEC</span>                   <span class="n">Console</span> <span class="n">word</span> <span class="n">write</span> <span class="p">(</span><span class="n">PDP</span><span class="o">-</span><span class="mi">11</span> <span class="n">only</span><span class="p">)</span>
<span class="n">WRITEB</span>                   <span class="n">Byte</span> <span class="n">write</span>
</pre></div>
</div>
<p>I/O read and I/O word write use word (even) addresses;
the low-order bit of the address should be ignored.
I/O byte write uses byte addresses,
and the data byte to be written is right-justified in the calling argument.</p>
<p>If the device has vectors,
the <code class="docutils literal notranslate"><span class="pre">vector_locator</span></code> field specifies the position of the vector in the interrupt tables,
using macro <code class="docutils literal notranslate"><span class="pre">IVCL</span> <span class="pre">(dev)</span></code>.
If the device has static interrupt vectors,
they are specified by the DIB vector field and by the DIB <code class="docutils literal notranslate"><span class="pre">num_vectors</span></code> field.
The device is assumed to have vectors at <span class="math notranslate nohighlight">\(vector, …, vector + ((num_vectors - 1) * 4)\)</span>.
If the device has dynamic interrupt acknowledge routines,
they are specified by the DIB interrupt acknowledge routines.
A calling sequence for an interrupt acknowledge routine is:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">int32</span><span class="w"> </span><span class="n">iack_rtn</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>It returns the interrupt vector for the device,
or 0 if there is no interrupt (passive release).</p>
</section>
<section id="massbus-devices-pdp-11-vax-780-only">
<h4><span class="sectnum">1.4.3.2. </span>Massbus devices (PDP-11, VAX-780 only)<a class="headerlink" href="#massbus-devices-pdp-11-vax-780-only" title="Permalink to this heading">¶</a></h4>
<p>For Massbus devices,
I/O dispatching is done by table-driven address decoding in the Massbus adapter
(RH for the PDP11, MBA for the VAX-780).
These tables are constructed at run time from device information blocks (DIBs).
Each Massbus device has a DIB with the following information:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">{</span> <span class="n">Massbus</span> <span class="n">number</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">mb_read_routine</span><span class="p">,</span> <span class="n">mb_write_routine</span><span class="p">,</span>
  <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">{</span> <span class="o">&amp;</span><span class="n">abort_routine</span> <span class="p">}</span> <span class="p">}</span>
</pre></div>
</div>
<p>The calling sequence for a Massbus register read is:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">t_stat</span><span class="w"> </span><span class="n">mb_read_routine</span><span class="w"> </span><span class="p">(</span><span class="n">int32</span><span class="w"> </span><span class="o">*</span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="n">int32</span><span class="w"> </span><span class="n">offset</span><span class="p">,</span><span class="w"> </span><span class="n">int32</span><span class="w"> </span><span class="n">drive</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>The calling sequence for a Massbus register write is:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">t_stat</span><span class="w"> </span><span class="n">mb_write_routine</span><span class="w"> </span><span class="p">(</span><span class="n">int32</span><span class="w"> </span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="n">int32</span><span class="w"> </span><span class="n">offset</span><span class="p">,</span><span class="w"> </span><span class="n">int32</span><span class="w"> </span><span class="n">drive</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>For both, offset is the internal register offset of the Massbus register being accessed,
and drive is the unit number of the Massbus controller being accessed.
These routines can return the following status values:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">SCPE_OK</span>                  <span class="n">Access</span> <span class="n">ok</span>
<span class="n">MBE_NXD</span>                  <span class="n">Non</span><span class="o">-</span><span class="n">existent</span> <span class="n">drive</span>
<span class="n">MBE_NXR</span>                  <span class="n">Non</span><span class="o">-</span><span class="n">existent</span> <span class="n">register</span>
<span class="n">MBE_GOE</span>                  <span class="n">Error</span> <span class="n">attempting</span> <span class="n">to</span> <span class="n">initiate</span> <span class="n">function</span>
</pre></div>
</div>
<p>The abort routine is called if the Massbus adapter must stop a data transfer or reset the associated controllers.
Its calling sequence is:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">t_stat</span><span class="w"> </span><span class="n">mba_abort</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>The abort routine typically invokes the device reset routine to stop all transfers and reset all device controller state.</p>
</section>
</section>
<section id="id5">
<h3><span class="sectnum">1.4.4. </span><code class="docutils literal notranslate"><span class="pre">DEVICE</span></code> context and flags<a class="headerlink" href="#id5" title="Permalink to this heading">¶</a></h3>
<p>For the PDP-11, VAX, and PDP-10,
the <code class="docutils literal notranslate"><span class="pre">DEVICE</span></code> <strong>ctxt</strong> (context) field must point to the device information block (DIB), if one exists.
The <code class="docutils literal notranslate"><span class="pre">DEVICE</span></code> <strong>flags</strong> field must specify whether the device is a Unibus device (<code class="docutils literal notranslate"><span class="pre">DEV_UBUS</span></code>);
a Qbus device with 22b DMA capability,
or no DMA capability (<code class="docutils literal notranslate"><span class="pre">DEV_QBUS</span></code>);
or a Qbus device with 18b DMA capability (<code class="docutils literal notranslate"><span class="pre">DEV_Q18</span></code>);
a Massbus device (<code class="docutils literal notranslate"><span class="pre">DEV_MBUS</span></code>); or a combination thereof.
The <code class="docutils literal notranslate"><span class="pre">DEVICE</span></code> flags field must also specify whether the device supports the <code class="docutils literal notranslate"><span class="pre">SET</span> <span class="pre">ENABLED</span></code>/<code class="docutils literal notranslate"><span class="pre">SET</span> <span class="pre">DISABLED</span></code> commands (<code class="docutils literal notranslate"><span class="pre">DEV_DISABLE</span></code>).
Lastly, device addresses and vectors are set in the device’s DIB from the table information in the <code class="docutils literal notranslate"><span class="pre">pdp11_io_lib.c</span></code> module.
This is true for BOTH static and floating addresses and vectors.</p>
<p>Most devices do not care whether the I/O bus is Unibus or Qbus.
Those that do can use macro <code class="docutils literal notranslate"><span class="pre">UNIBUS</span></code> to see if the host bus is Unibus (true) or Qbus (false).
On the PDP-11, <code class="docutils literal notranslate"><span class="pre">UNIBUS</span></code> is derived from the CPU model;
on the PDP-10 and VAX-11/780, VAX-11/750 and VAX-11/730, it is always true;
and for the MicroVAX models, it is always false.</p>
</section>
<section id="memory-access-routines">
<h3><span class="sectnum">1.4.5. </span>Memory access routines<a class="headerlink" href="#memory-access-routines" title="Permalink to this heading">¶</a></h3>
<section id="id6">
<h4><span class="sectnum">1.4.5.1. </span>Unibus/Qbus Devices<a class="headerlink" href="#id6" title="Permalink to this heading">¶</a></h4>
<p>Unibus/Qbus DMA devices access memory through four interface routines:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">int32</span><span class="w"> </span><span class="nf">Map_ReadB</span><span class="w"> </span><span class="p">(</span><span class="n">t_addr</span><span class="w"> </span><span class="n">ba</span><span class="p">,</span><span class="w"> </span><span class="n">int32</span><span class="w"> </span><span class="n">bc</span><span class="p">,</span><span class="w"> </span><span class="n">uint8</span><span class="w"> </span><span class="o">*</span><span class="n">buf</span><span class="p">);</span><span class="w"></span>
<span class="n">int32</span><span class="w"> </span><span class="nf">Map_ReadW</span><span class="w"> </span><span class="p">(</span><span class="n">t_addr</span><span class="w"> </span><span class="n">ba</span><span class="p">,</span><span class="w"> </span><span class="n">int32</span><span class="w"> </span><span class="n">bc</span><span class="p">,</span><span class="w"> </span><span class="n">uint16</span><span class="w"> </span><span class="o">*</span><span class="n">buf</span><span class="p">);</span><span class="w"></span>
<span class="n">int32</span><span class="w"> </span><span class="nf">Map_WriteB</span><span class="w"> </span><span class="p">(</span><span class="n">t_addr</span><span class="w"> </span><span class="n">ba</span><span class="p">,</span><span class="w"> </span><span class="n">int32</span><span class="w"> </span><span class="n">bc</span><span class="p">,</span><span class="w"> </span><span class="n">uint8</span><span class="w"> </span><span class="o">*</span><span class="n">buf</span><span class="p">);</span><span class="w"></span>
<span class="n">int32</span><span class="w"> </span><span class="nf">Map_WriteW</span><span class="w"> </span><span class="p">(</span><span class="n">t_addr</span><span class="w"> </span><span class="n">ba</span><span class="p">,</span><span class="w"> </span><span class="n">int32</span><span class="w"> </span><span class="n">bc</span><span class="p">,</span><span class="w"> </span><span class="n">uint16</span><span class="w"> </span><span class="o">*</span><span class="n">buf</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>The arguments to these routines are:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ba</span>          <span class="n">Starting</span> <span class="n">memory</span> <span class="n">address</span>
<span class="n">bc</span>          <span class="n">Byte</span> <span class="n">count</span>
<span class="o">*</span><span class="n">buf</span>        <span class="n">Pointer</span> <span class="n">to</span> <span class="n">device</span> <span class="n">buffer</span>
</pre></div>
</div>
<p>Note that the PDP-10 can only share a small number of PDP-11 peripherals,
because of its dependence on 18b transfers on the Unibus;
and that all non-Massbus peripherals are on Unibus 3.</p>
<p>The routines return the number of bytes not transferred:
0 indicates a successful transfer.
Transfer failures can occur if the mapped address uses an invalid mapping register or maps to non-existent memory.</p>
</section>
<section id="massbus-devices">
<h4><span class="sectnum">1.4.5.2. </span>Massbus devices<a class="headerlink" href="#massbus-devices" title="Permalink to this heading">¶</a></h4>
<p>Massbus devices access memory through three interface routines,
for read, write, and write check respectively:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">int32</span><span class="w"> </span><span class="nf">mba_rdbufW</span><span class="w"> </span><span class="p">(</span><span class="n">uint32</span><span class="w"> </span><span class="n">mbus</span><span class="p">,</span><span class="w"> </span><span class="n">int32</span><span class="w"> </span><span class="n">bc</span><span class="p">,</span><span class="w"> </span><span class="n">uint16</span><span class="w"> </span><span class="o">*</span><span class="n">buf</span><span class="p">);</span><span class="w"></span>
<span class="n">int32</span><span class="w"> </span><span class="nf">mba_wrbufW</span><span class="w"> </span><span class="p">(</span><span class="n">uint32</span><span class="w"> </span><span class="n">mbus</span><span class="p">,</span><span class="w"> </span><span class="n">int32</span><span class="w"> </span><span class="n">bc</span><span class="p">,</span><span class="w"> </span><span class="n">uint16</span><span class="w"> </span><span class="o">*</span><span class="n">buf</span><span class="p">);</span><span class="w"></span>
<span class="n">int32</span><span class="w"> </span><span class="nf">mba_chbufW</span><span class="w"> </span><span class="p">(</span><span class="n">uint32</span><span class="w"> </span><span class="n">mbus</span><span class="p">,</span><span class="w"> </span><span class="n">int32</span><span class="w"> </span><span class="n">bc</span><span class="p">,</span><span class="w"> </span><span class="n">uint16</span><span class="w"> </span><span class="o">*</span><span class="n">buf</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>The arguments to these routines are:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">mbus</span>       <span class="n">Massbus</span> <span class="n">adapter</span> <span class="n">number</span>
<span class="n">bc</span>         <span class="n">Byte</span> <span class="n">count</span>
<span class="o">*</span><span class="n">buf</span>       <span class="n">Pointer</span> <span class="n">to</span> <span class="n">device</span> <span class="n">buffer</span>
</pre></div>
</div>
<p>The routines the number of bytes successfully transferred.
Transfer failures can occur if a mapped address uses an invalid mapping register,
maps to non-existent memory,
or on a write-check,
if a miscompare occurs.</p>
</section>
</section>
<section id="id7">
<h3><span class="sectnum">1.4.6. </span>Adding a new I/O device<a class="headerlink" href="#id7" title="Permalink to this heading">¶</a></h3>
<section id="defining-the-device-parameters">
<h4><span class="sectnum">1.4.6.1. </span>Defining the device parameters<a class="headerlink" href="#defining-the-device-parameters" title="Permalink to this heading">¶</a></h4>
<p>If the device can interrupt, <code class="docutils literal notranslate"><span class="pre">pdp11_defs.h</span></code>
(<code class="docutils literal notranslate"><span class="pre">vaxmod_defs.h</span></code>, <code class="docutils literal notranslate"><span class="pre">vax780_moddefs.h</span></code>, <code class="docutils literal notranslate"><span class="pre">pdp10_defs.h</span></code>)
must be modified to add the device interrupt flag(s) and priority level.
The device flag(s) should be inserted using a spare bit (or bits) at the appropriate priority level.
On the PDP-11, the PIRQ interrupt flags (PIR) must always be the last (lowest priority) device in the level.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/* IPL 4 devices */</span><span class="w"></span>

<span class="cp">#define INT_V_LPT       4</span>
<span class="cp">#define INT_V_NEW       5                       </span><span class="cm">/* new IPL 4 dev */</span><span class="cp"></span>
<span class="cp">#define INT_V_PIR4      6                       </span><span class="cm">/* used to be 4 */</span><span class="cp"></span>
<span class="cm">/* ⋮ */</span><span class="w"></span>
<span class="cp">#define INT_NEW         (1u &lt;&lt; INT_V_NEW)</span>
<span class="cm">/* ⋮ */</span><span class="w"></span>
<span class="cp">#define IPL_NEW         4</span>
</pre></div>
</div>
</section>
<section id="defining-the-i-o-page-region-size">
<h4><span class="sectnum">1.4.6.2. </span>Defining the I/O page region size<a class="headerlink" href="#defining-the-i-o-page-region-size" title="Permalink to this heading">¶</a></h4>
<p>The size of the devices I/O page footprint should be defined as follows:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#define IOLN_NEW        010                     </span><span class="cm">/* length = 8 bytes */</span><span class="cp"></span>
</pre></div>
</div>
<p>This definition should appear in your device simulator code just before it is referenced to fill in the device information block.</p>
</section>
<section id="id8">
<h4><span class="sectnum">1.4.6.3. </span>Adding the device information block<a class="headerlink" href="#id8" title="Permalink to this heading">¶</a></h4>
<p>The device information block is declared in the device module, as follows:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">t_stat</span><span class="w"> </span><span class="nf">new_rd</span><span class="w"> </span><span class="p">(</span><span class="n">int32</span><span class="w"> </span><span class="o">*</span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="n">int32</span><span class="w"> </span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="n">int32</span><span class="w"> </span><span class="n">access</span><span class="p">);</span><span class="w"></span>
<span class="n">t_stat</span><span class="w"> </span><span class="nf">new_wr</span><span class="w"> </span><span class="p">(</span><span class="n">int32</span><span class="w"> </span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="n">int32</span><span class="w"> </span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="n">int32</span><span class="w"> </span><span class="n">access</span><span class="p">);</span><span class="w"></span>
<span class="n">int32</span><span class="w"> </span><span class="nf">new_iack1</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="p">);</span><span class="w"></span>
<span class="n">int32</span><span class="w"> </span><span class="nf">new_iack2</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="p">);</span><span class="w"></span>

<span class="cp">#define IOLN_NEW        010                     </span><span class="cm">/* length = 8 bytes */</span><span class="cp"></span>

<span class="n">DIB</span><span class="w"> </span><span class="n">new_dib</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">IOBA_AUTO</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">IOLN_NEW</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="o">&amp;</span><span class="n">new_rd</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="o">&amp;</span><span class="n">new_wr</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">num_vectors</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">IVLC</span><span class="w"> </span><span class="p">(</span><span class="n">NEW</span><span class="p">),</span><span class="w"></span>
<span class="w">    </span><span class="n">VEC_AUTO</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"> </span><span class="o">&amp;</span><span class="n">new_iack1</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">new_iack2</span><span class="p">,</span><span class="w"> </span><span class="cm">/* … */</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="proper-setting-of-your-i-o-page-base-address-in-the-device-information-block">
<h4><span class="sectnum">1.4.6.4. </span>Proper setting of your I/O page base address in the device information block<a class="headerlink" href="#proper-setting-of-your-i-o-page-base-address-in-the-device-information-block" title="Permalink to this heading">¶</a></h4>
<p>All Unibus and Qbus devices have some registers present in the I/O page.
The size of the device’s register footprint is mentioned above.
The address of the device’s base address in the I/O page can either be a fixed or a floating address.
The vector used by the device can either be a fixed or a floating vector.
The details for all known Unibus and Qbus devices are present in the entries of auto configure table (<code class="docutils literal notranslate"><span class="pre">auto_tab</span></code>).
Any device you may wish to simulate is likely already present in this table,
you usually need only add your device name to the existing entry for the device you are simulating.</p>
<p>For example, if you were going to simulate a DPV11,
and your device name is DPV,
you would find the DPV11 entry in the <strong>auto_tab</strong> table which looks like:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="p">{</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nb">NULL</span><span class="w"> </span><span class="p">},</span><span class="w">          </span><span class="mi">1</span><span class="p">,</span><span class="w">  </span><span class="mi">2</span><span class="p">,</span><span class="w">  </span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="w"> </span><span class="p">},</span><span class="w">            </span><span class="cm">/* DPV11 */</span><span class="w"></span>
</pre></div>
</div>
<p>You would revise it to look like:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="p">{</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="s">&quot;DPV&quot;</span><span class="w"> </span><span class="p">},</span><span class="w">         </span><span class="mi">1</span><span class="p">,</span><span class="w">  </span><span class="mi">2</span><span class="p">,</span><span class="w">  </span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="w"> </span><span class="p">},</span><span class="w">            </span><span class="cm">/* DPV11 */</span><span class="w"></span>
</pre></div>
</div>
<p>It is a good idea to actively call <code class="docutils literal notranslate"><span class="pre">auto_config</span> <span class="pre">(0,</span> <span class="pre">0)</span></code> as the last line in your device reset routine.
This will assure that both the address and vector will be properly inserted into your device information block
for proper system execution.</p>
</section>
<section id="adding-the-device-to-autoconfiguration-pdp-11-vax-11-and-micro-vax-only">
<h4><span class="sectnum">1.4.6.5. </span>Adding the device to autoconfiguration (PDP-11, VAX-11, and Micro VAX only)<a class="headerlink" href="#adding-the-device-to-autoconfiguration-pdp-11-vax-11-and-micro-vax-only" title="Permalink to this heading">¶</a></h4>
<p>If the device is not presently included in the autoconfiguration table,
it must be added to table <code class="docutils literal notranslate"><span class="pre">auto_tab</span></code> in <code class="docutils literal notranslate"><span class="pre">pdp11_io_lib.c</span></code>.
Entries are in rank order
(with the exception of devices which have only fixed addresses AND vectors).
The fields for each entry are:</p>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*dnam[32]</span></code></p></td>
<td><p>List of controller names for this device type, maximum 32</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">int32</span> <span class="pre">numc;</span></code></p></td>
<td><p>Number of controllers per device name (used by terminal multiplexers)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">int32</span> <span class="pre">numv;</span></code></p></td>
<td><p>Number of vectors per controller</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">uint32</span> <span class="pre">amod</span></code></p></td>
<td><p>Address modulus</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">uint32</span> <span class="pre">vmod</span></code></p></td>
<td><p>Vector modulus</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">uint32</span> <span class="pre">fix[32]</span></code></p></td>
<td><p>Fixed CSR addresses, maximum 32; 0 = end of list</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">uint32</span> <span class="pre">fixv[32]</span></code></p></td>
<td><p>Fixed vectors, maximum 32; 0 = end of list</p></td>
</tr>
</tbody>
</table>
<p>An <code class="docutils literal notranslate"><span class="pre">amod</span></code> value of 0 indicates that the addresses for this device entry are only fixed.
A <code class="docutils literal notranslate"><span class="pre">vmod</span></code> value of 0 indicates that all the vectors for this entry are fixed.
A negative <code class="docutils literal notranslate"><span class="pre">numv</span></code> value indicates that the <code class="docutils literal notranslate"><span class="pre">abs(numv)</span></code> should be the number of vectors used/reserved,
but they should not be updated in the DIB by the auto-configure process since they are set by software.</p>
</section>
</section>
</section>
<section id="nova">
<h2><span class="sectnum">1.5. </span>Nova<a class="headerlink" href="#nova" title="Permalink to this heading">¶</a></h2>
<section id="id9">
<h3><span class="sectnum">1.5.1. </span>CPU and I/O device structures<a class="headerlink" href="#id9" title="Permalink to this heading">¶</a></h3>
<p>Simulated memory is kept in array <code class="docutils literal notranslate"><span class="pre">uint16</span> <span class="pre">M[MAXMEMSIZE]</span></code>.</p>
<p>The interrupt structure is implemented in three parallel variables:</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">int32</span> <span class="pre">int_req</span></code></dt><dd><p>Interrupt requests.
The two high-order bits are the interrupt enable flag and the interrupts-not-deferred flag.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int32</span> <span class="pre">dev_done</span></code></dt><dd><p>Device done flags.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int32</span> <span class="pre">dev_disable</span></code></dt><dd><p>Device interrupt disable flags.</p>
</dd>
</dl>
<p>Pictorially,</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>╒════╤════╕╌╒════╤════╕╌╒════╤════╤════╕
│ion │indf│ │irqa│irqb│ │irqx│irqy│irqz│ irq_req
╘════╧════╛╌╘════╧════╛╌╘════╧════╧════╛

╒════╤════╕╌╒════╤════╕╌╒════╤════╤════╕
│ 0  │ 0  │ │dona│donb│ │donx│dony│donz│ dev_done
╘════╧════╛╌╘════╧════╛╌╘════╧════╧════╛

╒════╤════╕╌╒════╤════╕╌╒════╤════╤════╕
│ 0  │ 0  │ │disa│disb│ │disx│disy│disz│ dev_disable
╘════╧════╛╌╘════╧════╛╌╘════╧════╧════╛
╷         ╷ ╷                          ╷
╰────┬────╯ ╰───────────┬──────────────╯
   fixed           I/O devices
</pre></div>
</div>
<p>Logically, the relationship is</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">int_req</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">int_req</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="o">~</span><span class="n">INT_DEV</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="p">(</span><span class="n">dev_done</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="o">~</span><span class="n">dev_disable</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>Device enable flags are kept in <code class="docutils literal notranslate"><span class="pre">iot_enb</span></code>.
The device enable flag, by convention, is the same bit position as device interrupt flag.</p>
<p>I/O dispatching is indirectly through dispatch table <code class="docutils literal notranslate"><span class="pre">dev_table</span></code>,
which has one entry for each possible I/O device.
Each entry is a structure of the form:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">ndev</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">int32</span><span class="w">   </span><span class="n">mask</span><span class="p">;</span><span class="w">                   </span><span class="cm">/* interrupt/done mask bit */</span><span class="w"></span>
<span class="w">    </span><span class="n">int32</span><span class="w">   </span><span class="n">pi</span><span class="p">;</span><span class="w">                     </span><span class="cm">/* PI out mask bit */</span><span class="w"></span>
<span class="w">    </span><span class="n">t_stat</span><span class="w">  </span><span class="p">(</span><span class="o">*</span><span class="n">iot_routine</span><span class="p">)();</span><span class="w">       </span><span class="cm">/* addr of I/O routine */</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>The I/O routine is called by</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">new_data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">iot_routine</span><span class="w"> </span><span class="p">(</span><span class="n">IOT</span><span class="w"> </span><span class="n">pulse</span><span class="p">,</span><span class="w"> </span><span class="n">IOT</span><span class="w"> </span><span class="n">subopcode</span><span class="p">,</span><span class="w"> </span><span class="n">AC</span><span class="w"> </span><span class="n">value</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>where</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">new_data</span><span class="o">&lt;</span><span class="mi">15</span><span class="p">:</span><span class="mi">0</span><span class="o">&gt;</span>              <span class="o">=</span>   <span class="n">New</span> <span class="n">contents</span> <span class="n">of</span> <span class="n">AC</span><span class="p">,</span> <span class="k">if</span> <span class="n">DIA</span><span class="o">/</span><span class="n">DIB</span><span class="o">/</span><span class="n">DIC</span>
<span class="n">new_data</span><span class="o">&lt;</span><span class="n">IOT_V_SKP</span><span class="o">&gt;</span>         <span class="o">=</span>   <span class="mi">1</span> <span class="k">if</span> <span class="n">skip</span><span class="p">,</span> <span class="mi">0</span> <span class="k">if</span> <span class="ow">not</span>
<span class="n">new_data</span><span class="o">&lt;</span><span class="mi">31</span><span class="p">:</span><span class="n">IOT_V_REASON</span><span class="o">&gt;</span>   <span class="o">=</span>   <span class="n">Stop</span> <span class="n">code</span><span class="p">,</span> <span class="k">if</span> <span class="n">non</span><span class="o">-</span><span class="n">zero</span>
</pre></div>
</div>
</section>
<section id="id10">
<h3><span class="sectnum">1.5.2. </span><code class="docutils literal notranslate"><span class="pre">DEVICE</span></code> context and flags<a class="headerlink" href="#id10" title="Permalink to this heading">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">DEVICE</span></code> <strong>ctxt</strong> (context) field must point to the device information block (DIB), if one exists.
The <code class="docutils literal notranslate"><span class="pre">DEVICE</span></code> <strong>flags</strong> field must specify whether the device supports the <code class="docutils literal notranslate"><span class="pre">SET</span> <span class="pre">ENABLED</span></code>/<code class="docutils literal notranslate"><span class="pre">SET</span> <span class="pre">DISABLED</span></code> commands (<code class="docutils literal notranslate"><span class="pre">DEV_DISABLE</span></code>).
If a device can be disabled, the state of the device flag&lt;DEV_DIS&gt; must be declared as a register for <code class="docutils literal notranslate"><span class="pre">SAVE</span></code>/<code class="docutils literal notranslate"><span class="pre">RESTORE</span></code>.</p>
</section>
<section id="memory-mapping">
<h3><span class="sectnum">1.5.3. </span>Memory mapping<a class="headerlink" href="#memory-mapping" title="Permalink to this heading">¶</a></h3>
<p>On mapped Novas and on Eclipses,
DMA transfers use a memory map to translate 15b virtual addresses to physical addresses.
The mapping function is called by:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">int32</span><span class="w"> </span><span class="n">MapAddr</span><span class="p">(</span><span class="n">int32</span><span class="w"> </span><span class="n">map</span><span class="p">,</span><span class="w"> </span><span class="n">int32</span><span class="w"> </span><span class="n">addr</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>with the following arguments:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">map</span>         <span class="n">Map</span> <span class="n">number</span><span class="p">,</span> <span class="n">usually</span> <span class="mi">0</span>
<span class="n">addr</span>        <span class="n">Virtual</span> <span class="n">address</span>
</pre></div>
</div>
<p>The routine returns the physical address to be used for the transfer.</p>
</section>
<section id="id11">
<h3><span class="sectnum">1.5.4. </span>Adding a new I/O device<a class="headerlink" href="#id11" title="Permalink to this heading">¶</a></h3>
<section id="defining-the-device-number-and-the-done-interrupt-flag">
<h4><span class="sectnum">1.5.4.1. </span>Defining the device number and the Done/Interrupt flag<a class="headerlink" href="#defining-the-device-number-and-the-done-interrupt-flag" title="Permalink to this heading">¶</a></h4>
<p>Module <code class="docutils literal notranslate"><span class="pre">nova_defs.h</span></code> must be modified to add the device number definitions and the device interrupt flag definitions.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#define DEV_NEW         0nn                     </span><span class="cm">/* can&#39;t be 00, 01 */</span><span class="cp"></span>
</pre></div>
</div>
<p>Device flags are kept as a bit vector.
If priority is unimportant,
the device flag can be defined as one of the currently unused bits:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#define INT_V_NEW       1                       </span><span class="cm">/* new */</span><span class="cp"></span>
<span class="cm">/* ⋮ */</span><span class="w"></span>
<span class="cp">#define INT_NEW         (1 &lt;&lt; INT_V_NEW)</span>
</pre></div>
</div>
<p>If the device requires a specific priority with respect to existing devices,
it must be assigned the appropriate flag bit,
and the other device flag bits moved up or down.</p>
<p>The device’s <code class="docutils literal notranslate"><span class="pre">PI</span></code> mask bit must also be defined:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#define PI_NEW          000200</span>
</pre></div>
</div>
</section>
<section id="id12">
<h4><span class="sectnum">1.5.4.2. </span>Adding the device information block<a class="headerlink" href="#id12" title="Permalink to this heading">¶</a></h4>
<p>The device information block is declared in the device module, as follows:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">int32</span><span class="w"> </span><span class="nf">iot</span><span class="w"> </span><span class="p">(</span><span class="n">int32</span><span class="w"> </span><span class="n">pulse</span><span class="p">,</span><span class="w"> </span><span class="n">int32</span><span class="w"> </span><span class="n">code</span><span class="p">,</span><span class="w"> </span><span class="n">int32</span><span class="w"> </span><span class="n">AC</span><span class="p">);</span><span class="w"></span>
<span class="cm">/* ⋮ */</span><span class="w"></span>
<span class="n">DIB</span><span class="w"> </span><span class="n">new_dib</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">DEV_NEW</span><span class="p">,</span><span class="w"> </span><span class="n">INT_new</span><span class="p">,</span><span class="w"> </span><span class="n">PI_new</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">iot</span><span class="w"> </span><span class="p">};</span><span class="w"></span>
</pre></div>
</div>
</section>
</section>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">Python</a></h1>








<h3>Navigation</h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="simh_doc.html">SimH Users' Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="simh_swre.html">SimH Sample Software Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="simh_faq.html">SimH FAQ</a></li>
<li class="toctree-l1"><a class="reference internal" href="nova_doc.html">Data General Nova</a></li>
<li class="toctree-l1"><a class="reference internal" href="pdp1_doc.html">Digital Equipment Corporation PDP-1</a></li>
<li class="toctree-l1"><a class="reference internal" href="pdp11_doc.html">Digital Equipment Corporation PDP-11</a></li>
<li class="toctree-l1"><a class="reference internal" href="vax780_doc.html">Digital Equipment Corporation VAX-11/780</a></li>
<li class="toctree-l1"><a class="reference internal" href="vax_doc.html">Digital Equipment Corporation MicroVAX 3900</a></li>
<li class="toctree-l1"><a class="reference internal" href="tx0_doc.html">TX-0 simulator usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="simh_breakpoints.html">The SIMH breakpoint subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="simh_magtape.html">SIMH magtape representation and handling</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Adding an I/O device to a SIMH virtual machine</a></li>
<li class="toctree-l1"><a class="reference internal" href="simulators_acm_queue_2004.html">Simulators: virtual machines of the past and future</a></li>
<li class="toctree-l1"><a class="reference internal" href="Summary%20of%20IMP%20IO%20Device%20Codes.html">Summary of I/O commands for the Arpanet IMP</a></li>
<li class="toctree-l1"><a class="reference internal" href="ssem_doc.html">SSEM simulator usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="swtp6800_doc.html">SWTP 6800 simulator usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="simh.html">Writing a simulator for the SIMH system</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
      <li>Previous: <a href="simh_magtape.html" title="previous chapter">SIMH magtape representation and handling</a></li>
      <li>Next: <a href="simulators_acm_queue_2004.html" title="next chapter">Simulators: virtual machines of the past and future</a></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 5.1.0</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="_sources/simh_vmio.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>