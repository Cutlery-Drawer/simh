
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

    <title>1. Writing a simulator for the SIMH system &#8212; Python  documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/alabaster.css" />
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/sphinx_highlight.js"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="prev" title="1. SWTP 6800 simulator usage" href="swtp6800_doc.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="writing-a-simulator-for-the-simh-system">
<h1><span class="sectnum">1. </span>Writing a simulator for the SIMH system<a class="headerlink" href="#writing-a-simulator-for-the-simh-system" title="Permalink to this heading">¶</a></h1>
<dl class="field-list simple">
<dt class="field-odd">Date<span class="colon">:</span></dt>
<dd class="field-odd"><p>2020-03-01</p>
</dd>
<dt class="field-even">Version<span class="colon">:</span></dt>
<dd class="field-even"><p>4.0</p>
</dd>
<dt class="field-odd">Revision<span class="colon">:</span></dt>
<dd class="field-odd"><p>$Format:%H$</p>
</dd>
<dt class="field-even">Copyright<span class="colon">:</span></dt>
<dd class="field-even"><p>See <a class="reference external" href="../LICENSE.txt">LICENSE.txt</a> for terms of use.</p>
</dd>
</dl>
<aside class="topic">
<p class="topic-title"><strong>Copyright notice</strong></p>
<p>The following copyright notice applies to the SIMH source, binary, and documentation:</p>
<p>Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the “Software”),
to deal in the Software without restriction, including without limitation
the rights to use, copy, modify, merge, publish, distribute, sublicense,
and/or sell copies of the Software, and to permit persons to whom the
Software is furnished to do so, subject to the following conditions:</p>
<p>The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.</p>
<p>THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>
<p>Except as contained in this notice, the names of The Authors shall not be
used in advertising or otherwise to promote the sale, use or other dealings
in this Software without prior written authorization from the Authors.</p>
</aside>
<nav class="contents local" id="contents">
<ul class="auto-toc simple">
<li><p><a class="reference internal" href="#overview" id="id11"><span class="sectnum">1.1. </span>Overview</a></p></li>
<li><p><a class="reference internal" href="#data-types" id="id12"><span class="sectnum">1.2. </span>Data types</a></p></li>
<li><p><a class="reference internal" href="#vm-organization" id="id13"><span class="sectnum">1.3. </span>VM organization</a></p>
<ul class="auto-toc">
<li><p><a class="reference internal" href="#cpu-organization" id="id14"><span class="sectnum">1.3.1. </span>CPU organization</a></p>
<ul class="auto-toc">
<li><p><a class="reference internal" href="#time-base" id="id15"><span class="sectnum">1.3.1.1. </span>Time base</a></p></li>
<li><p><a class="reference internal" href="#step-function" id="id16"><span class="sectnum">1.3.1.2. </span>Step function</a></p></li>
<li><p><a class="reference internal" href="#memory-organization" id="id17"><span class="sectnum">1.3.1.3. </span>Memory organization</a></p></li>
<li><p><a class="reference internal" href="#interrupt-organization" id="id18"><span class="sectnum">1.3.1.4. </span>Interrupt organization</a></p></li>
<li><p><a class="reference internal" href="#i-o-dispatching" id="id19"><span class="sectnum">1.3.1.5. </span>I/O dispatching</a></p></li>
<li><p><a class="reference internal" href="#instruction-execution" id="id20"><span class="sectnum">1.3.1.6. </span>Instruction execution</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#peripheral-device-organization" id="id21"><span class="sectnum">1.3.2. </span>Peripheral device organization</a></p>
<ul class="auto-toc">
<li><p><a class="reference internal" href="#device-timing" id="id22"><span class="sectnum">1.3.2.1. </span>Device timing</a></p></li>
<li><p><a class="reference internal" href="#clock-calibration" id="id23"><span class="sectnum">1.3.2.2. </span>Clock calibration</a></p></li>
<li><p><a class="reference internal" href="#pre-calibration" id="id24"><span class="sectnum">1.3.2.3. </span>Pre-calibration</a></p></li>
<li><p><a class="reference internal" href="#idling" id="id25"><span class="sectnum">1.3.2.4. </span>Idling</a></p></li>
<li><p><a class="reference internal" href="#data-i-o" id="id26"><span class="sectnum">1.3.2.5. </span>Data I/O</a></p></li>
</ul>
</li>
</ul>
</li>
<li><p><a class="reference internal" href="#data-structures" id="id27"><span class="sectnum">1.4. </span>Data structures</a></p>
<ul class="auto-toc">
<li><p><a class="reference internal" href="#device-structure" id="id28"><span class="sectnum">1.4.1. </span><code class="docutils literal notranslate"><span class="pre">DEVICE</span></code> structure</a></p>
<ul class="auto-toc">
<li><p><a class="reference internal" href="#awidth-and-aincr" id="id29"><span class="sectnum">1.4.1.1. </span><code class="docutils literal notranslate"><span class="pre">awidth</span></code> and <code class="docutils literal notranslate"><span class="pre">aincr</span></code></a></p></li>
<li><p><a class="reference internal" href="#section-1-4-1-2" id="id30"><span class="sectnum">1.4.1.2. </span>Device flags</a></p></li>
<li><p><a class="reference internal" href="#context" id="id31"><span class="sectnum">1.4.1.3. </span>Context</a></p></li>
<li><p><a class="reference internal" href="#examine-and-deposit-routines" id="id32"><span class="sectnum">1.4.1.4. </span>Examine and deposit routines</a></p></li>
<li><p><a class="reference internal" href="#reset-routine" id="id33"><span class="sectnum">1.4.1.5. </span>Reset routine</a></p></li>
<li><p><a class="reference internal" href="#boot-routine" id="id34"><span class="sectnum">1.4.1.6. </span>Boot routine</a></p></li>
<li><p><a class="reference internal" href="#attach-and-detach-routines" id="id35"><span class="sectnum">1.4.1.7. </span>Attach and detach routines</a></p></li>
<li><p><a class="reference internal" href="#memory-size-change-routine" id="id36"><span class="sectnum">1.4.1.8. </span>Memory size change routine</a></p></li>
<li><p><a class="reference internal" href="#debug-controls" id="id37"><span class="sectnum">1.4.1.9. </span>Debug controls</a></p></li>
<li><p><a class="reference internal" href="#device-specific-help-support" id="id38"><span class="sectnum">1.4.1.10. </span>Device-specific help support</a></p></li>
<li><p><a class="reference internal" href="#help-routine" id="id39"><span class="sectnum">1.4.1.11. </span>Help routine</a></p></li>
<li><p><a class="reference internal" href="#attach-help-routine" id="id40"><span class="sectnum">1.4.1.12. </span>Attach help routine</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#unit-structure" id="id41"><span class="sectnum">1.4.2. </span><code class="docutils literal notranslate"><span class="pre">UNIT</span></code> structure</a></p>
<ul class="auto-toc">
<li><p><a class="reference internal" href="#id4" id="id42"><span class="sectnum">1.4.2.1. </span>Unit flags</a></p></li>
<li><p><a class="reference internal" href="#service-routine" id="id43"><span class="sectnum">1.4.2.2. </span>Service routine</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#reg-structure" id="id44"><span class="sectnum">1.4.3. </span><code class="docutils literal notranslate"><span class="pre">REG</span></code> structure</a></p>
<ul class="auto-toc">
<li><p><a class="reference internal" href="#register-flags" id="id45"><span class="sectnum">1.4.3.1. </span>Register flags</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#bitfield-structure" id="id46"><span class="sectnum">1.4.4. </span><code class="docutils literal notranslate"><span class="pre">BITFIELD</span></code> structure</a></p></li>
<li><p><a class="reference internal" href="#mtab-structure" id="id47"><span class="sectnum">1.4.5. </span><code class="docutils literal notranslate"><span class="pre">MTAB</span></code> structure</a></p>
<ul class="auto-toc">
<li><p><a class="reference internal" href="#validation-routine" id="id48"><span class="sectnum">1.4.5.1. </span>Validation routine</a></p></li>
<li><p><a class="reference internal" href="#display-routine" id="id49"><span class="sectnum">1.4.5.2. </span>Display routine</a></p></li>
<li><p><a class="reference internal" href="#help-flags" id="id50"><span class="sectnum">1.4.5.3. </span>Help flags</a></p></li>
<li><p><a class="reference internal" href="#example-arguments-in-the-mstring" id="id51"><span class="sectnum">1.4.5.4. </span>Example arguments in the <code class="docutils literal notranslate"><span class="pre">mstring</span></code></a></p></li>
<li><p><a class="reference internal" href="#help-field" id="id52"><span class="sectnum">1.4.5.5. </span>Help field</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#other-data-structures" id="id53"><span class="sectnum">1.4.6. </span>Other data structures</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#vm-provided-routines" id="id54"><span class="sectnum">1.5. </span>VM-provided routines</a></p>
<ul class="auto-toc">
<li><p><a class="reference internal" href="#id6" id="id55"><span class="sectnum">1.5.1. </span>Instruction execution</a></p></li>
<li><p><a class="reference internal" href="#binary-load-and-dump" id="id56"><span class="sectnum">1.5.2. </span>Binary load and dump</a></p></li>
<li><p><a class="reference internal" href="#symbolic-examination-and-deposit" id="id57"><span class="sectnum">1.5.3. </span>Symbolic examination and deposit</a></p></li>
<li><p><a class="reference internal" href="#optional-interfaces" id="id58"><span class="sectnum">1.5.4. </span>Optional interfaces</a></p>
<ul class="auto-toc">
<li><p><a class="reference internal" href="#once-only-initialization-routine" id="id59"><span class="sectnum">1.5.4.1. </span>Once only initialization routine</a></p></li>
<li><p><a class="reference internal" href="#address-input-and-display" id="id60"><span class="sectnum">1.5.4.2. </span>Address input and display</a></p></li>
<li><p><a class="reference internal" href="#command-input-and-post-processing" id="id61"><span class="sectnum">1.5.4.3. </span>Command input and post-processing</a></p></li>
<li><p><a class="reference internal" href="#simulator-stop-message-formatting" id="id62"><span class="sectnum">1.5.4.4. </span>Simulator stop message formatting</a></p></li>
<li><p><a class="reference internal" href="#vm-specific-commands" id="id63"><span class="sectnum">1.5.4.5. </span>VM-specific commands</a></p></li>
<li><p><a class="reference internal" href="#vm-support-for-stepping-over-subroutine-calls" id="id64"><span class="sectnum">1.5.4.6. </span>VM-support for stepping over subroutine calls</a></p></li>
<li><p><a class="reference internal" href="#displaying-the-simulator-pc-value-in-debug-output" id="id65"><span class="sectnum">1.5.4.7. </span>Displaying the simulator PC value in debug output</a></p></li>
</ul>
</li>
</ul>
</li>
<li><p><a class="reference internal" href="#other-scp-facilities" id="id66"><span class="sectnum">1.6. </span>Other SCP facilities</a></p>
<ul class="auto-toc">
<li><p><a class="reference internal" href="#terminal-input-output-formatting-library" id="id67"><span class="sectnum">1.6.1. </span>Terminal input/output formatting library</a></p>
<ul class="auto-toc">
<li><p><a class="reference internal" href="#terminal-multiplexer-emulation-library" id="id68"><span class="sectnum">1.6.1.1. </span>Terminal multiplexer emulation library</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#magnetic-tape-emulation-library" id="id69"><span class="sectnum">1.6.2. </span>Magnetic tape emulation library</a></p></li>
<li><p><a class="reference internal" href="#disk-emulation-library" id="id70"><span class="sectnum">1.6.3. </span>Disk emulation library</a></p></li>
<li><p><a class="reference internal" href="#breakpoint-support" id="id71"><span class="sectnum">1.6.4. </span>Breakpoint support</a></p>
<ul class="auto-toc">
<li><p><a class="reference internal" href="#breakpoint-basics" id="id72"><span class="sectnum">1.6.4.1. </span>Breakpoint basics</a></p></li>
<li><p><a class="reference internal" href="#testing-for-breakpoints" id="id73"><span class="sectnum">1.6.4.2. </span>Testing for breakpoints</a></p></li>
<li><p><a class="reference internal" href="#the-replay-problem" id="id74"><span class="sectnum">1.6.4.3. </span>The replay problem</a></p></li>
<li><p><a class="reference internal" href="#breakpoint-classes" id="id75"><span class="sectnum">1.6.4.4. </span>Breakpoint classes</a></p></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
<section id="overview">
<h2><span class="sectnum">1.1. </span>Overview<a class="headerlink" href="#overview" title="Permalink to this heading">¶</a></h2>
<p>SIMH (history simulators) is a set of portable programs,
written in C,
which simulate various historically interesting computers.
This document describes how to design, write, and check out a new simulator for SIMH.
It is not an introduction to either the philosophy or external operation of SIMH,
and the reader should be familiar with both of those topics before proceeding.
Nor is it a guide to the internal design or operation of SIMH,
except insofar as those areas interact with simulator design.
Instead, this manual presents and explains the form, meaning,
and operation of the interfaces between simulators and the SIMH simulator control package.
It also offers some suggestions for utilizing the services SIMH offers and explains the constraints that all simulators operating within SIMH will experience.</p>
<p>Some terminology:
Each simulator consists of a standard <em>simulator control package</em> (SCP and related libraries),
which provides a control framework and utility routines for a simulator;
and a unique <em>virtual machine</em> (VM),
which implements the simulated processor and selected peripherals.
A VM consists of multiple <em>devices</em>,
such as the CPU, paper tape reader, disk controller, etc.
Each controller consists of a named state space (called <em>registers</em>)
and one or more <em>units</em>.
Each unit consists of a numbered state space (called a <em>data set</em>).
The host computer is the system on which SIMH runs;
the <em>target computer</em> is the system being simulated.</p>
<p>SIMH is unabashedly based on the MIMIC simulation system,
designed in the late 1960s by Len Fehskens, Mike McCarthy, and Bob Supnik.
This document is based on MIMIC’s published interface specification,
“How to Write a Virtual Machine for the MIMIC Simulation System”,
by Len Fehskens and Bob Supnik.</p>
</section>
<section id="data-types">
<h2><span class="sectnum">1.2. </span>Data types<a class="headerlink" href="#data-types" title="Permalink to this heading">¶</a></h2>
<p>SIMH is written in C.
The host system must support (at least) 32-bit data types
(64-bit data types for the PDP-10 and other large-word target systems).
To cope with the vagaries of C data types,
SIMH defines some unambiguous data types for its interfaces:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>SIMH data type</p></th>
<th class="head"><p>Interpretation in typical 32-bit C</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="code highlight c docutils literal highlight-c"><span class="n">int8</span></code>, <code class="code highlight c docutils literal highlight-c"><span class="n">uint8</span></code></p></td>
<td><p><code class="code highlight c docutils literal highlight-c"><span class="kt">signed</span><span class="w"> </span><span class="kt">char</span></code>, <code class="code highlight c docutils literal highlight-c"><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="code highlight c docutils literal highlight-c"><span class="n">int16</span></code>, <code class="code highlight c docutils literal highlight-c"><span class="n">uint16</span></code></p></td>
<td><p><code class="code highlight c docutils literal highlight-c"><span class="kt">signed</span><span class="w"> </span><span class="kt">short</span></code>, <code class="code highlight c docutils literal highlight-c"><span class="kt">unsigned</span><span class="w"> </span><span class="kt">short</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="code highlight c docutils literal highlight-c"><span class="n">int32</span></code>, <code class="code highlight c docutils literal highlight-c"><span class="n">uint32</span></code></p></td>
<td><p><code class="code highlight c docutils literal highlight-c"><span class="kt">signed</span><span class="w"> </span><span class="kt">int</span></code>, <code class="code highlight c docutils literal highlight-c"><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="code highlight c docutils literal highlight-c"><span class="n">t_int64</span></code>, <code class="code highlight c docutils literal highlight-c"><span class="n">t_uint64</span></code></p></td>
<td><p><code class="code highlight c docutils literal highlight-c"><span class="kt">long</span><span class="w"> </span><span class="kt">long</span></code>, <code class="code highlight c docutils literal highlight-c"><span class="n">_int64</span></code> (system-specific)</p></td>
</tr>
<tr class="row-even"><td><p><code class="code highlight c docutils literal highlight-c"><span class="n">t_addr</span></code></p></td>
<td><p>Simulated address, <code class="code highlight c docutils literal highlight-c"><span class="n">uint32</span></code> or <code class="code highlight c docutils literal highlight-c"><span class="n">t_uint64</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="code highlight c docutils literal highlight-c"><span class="n">t_value</span></code></p></td>
<td><p>Simulated value, <code class="code highlight c docutils literal highlight-c"><span class="n">uint32</span></code> or <code class="code highlight c docutils literal highlight-c"><span class="n">t_uint64</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="code highlight c docutils literal highlight-c"><span class="n">t_svalue</span></code></p></td>
<td><p>Simulated signed value, <code class="code highlight c docutils literal highlight-c"><span class="n">int32</span></code> or <code class="code highlight c docutils literal highlight-c"><span class="n">t_int64</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="code highlight c docutils literal highlight-c"><span class="n">t_mtrlnt</span></code></p></td>
<td><p>Mag tape record length, <code class="code highlight c docutils literal highlight-c"><span class="n">uint32</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="code highlight c docutils literal highlight-c"><span class="n">t_stat</span></code></p></td>
<td><p>Status code, <code class="code highlight c docutils literal highlight-c"><span class="kt">int</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="code highlight c docutils literal highlight-c"><span class="n">t_bool</span></code></p></td>
<td><p>True/false value, <code class="code highlight c docutils literal highlight-c"><span class="kt">int</span></code></p></td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The inconsistency in naming <code class="code highlight c docutils literal highlight-c"><span class="n">t_int64</span></code> and <code class="code highlight c docutils literal highlight-c"><span class="n">t_uint64</span></code> is due to Microsoft VC++,
which uses <code class="code highlight c docutils literal highlight-c"><span class="n">int64</span></code> as a structure name member in the master Windows definitions file.</p>
</div>
<p>In addition, SIMH defines structures for each of its major data elements:</p>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#device"><code class="docutils literal notranslate"><span class="pre">DEVICE</span></code></a></p></td>
<td><p>Device definition structure</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#unit"><code class="docutils literal notranslate"><span class="pre">UNIT</span></code></a></p></td>
<td><p>Unit definition structure</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#reg"><code class="docutils literal notranslate"><span class="pre">REG</span></code></a></p></td>
<td><p>Register definition structure</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mtab"><code class="docutils literal notranslate"><span class="pre">MTAB</span></code></a></p></td>
<td><p>Modifier definition structure</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#ctab"><code class="docutils literal notranslate"><span class="pre">CTAB</span></code></a></p></td>
<td><p>Command definition structure</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#debtab"><code class="docutils literal notranslate"><span class="pre">DEBTAB</span></code></a></p></td>
<td><p>Debug table entry structure</p></td>
</tr>
</tbody>
</table>
</section>
<section id="vm-organization">
<h2><span class="sectnum">1.3. </span>VM organization<a class="headerlink" href="#vm-organization" title="Permalink to this heading">¶</a></h2>
<p>A virtual machine (VM) is a collection of devices bound together through their internal logic.
Each device is named and corresponds more or less to a hunk of hardware on the real machine; for example:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>VM device</p></th>
<th class="head"><p>Real machine hardware</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">CPU</span></code></p></td>
<td><p>Central processor and main memory</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">PTR</span></code></p></td>
<td><p>Paper tape reader controller and paper tape reader</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">TTI</span></code></p></td>
<td><p>Console keyboard</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">TTO</span></code></p></td>
<td><p>Console output</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">DKP</span></code></p></td>
<td><p>Disk pack controller and drives</p></td>
</tr>
</tbody>
</table>
<p>There may be more than one device per physical hardware entity,
as for the console; but for each user-accessible device there must be at least one.
One of these devices will have the pre-eminent responsibility for directing simulated operations.
Normally, this is the CPU, but it could be a higher-level entity, such as a bus master.</p>
<p>The VM actually runs as a subroutine of the simulator control package (SCP).
It provides a master routine for running simulated programs and other routines and data structures to implement SCP’s command and control functions.
The interfaces between a VM and SCP are relatively few:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Interface</p></th>
<th class="head"><p>Function</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="code highlight c docutils literal highlight-c"><span class="kt">char</span><span class="w"> </span><span class="n">sim_name</span><span class="p">[]</span></code></p></td>
<td><p>Simulator name string</p></td>
</tr>
<tr class="row-odd"><td><p><code class="code highlight c docutils literal highlight-c"><span class="n">REG</span><span class="w"> </span><span class="o">*</span><span class="n">sim_PC</span></code></p></td>
<td><p>Pointer to simulated program counter</p></td>
</tr>
<tr class="row-even"><td><p><code class="code highlight c docutils literal highlight-c"><span class="n">int32</span><span class="w"> </span><span class="n">sim_emax</span></code></p></td>
<td><p>Maximum number of words in an instruction or data item</p></td>
</tr>
<tr class="row-odd"><td><p><code class="code highlight c docutils literal highlight-c"><span class="n">DEVICE</span><span class="w"> </span><span class="o">*</span><span class="n">sim_devices</span><span class="p">[]</span></code></p></td>
<td><p>Table of pointers to simulated devices, <code class="code highlight c docutils literal highlight-c"><span class="nb">NULL</span></code> terminated</p></td>
</tr>
<tr class="row-even"><td><p><code class="code highlight c docutils literal highlight-c"><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">sim_stop_messages</span><span class="p">[</span><span class="n">SCPE_BASE</span><span class="p">]</span></code></p></td>
<td><p>Table of pointers to error messages</p></td>
</tr>
<tr class="row-odd"><td><p><code class="code highlight c docutils literal highlight-c"><span class="n">t_stat</span><span class="w"> </span><span class="n">sim_load</span><span class="w"> </span><span class="p">(</span><span class="cm">/*…*/</span><span class="p">)</span></code></p></td>
<td><p>Binary loader subroutine</p></td>
</tr>
<tr class="row-even"><td><p><code class="code highlight c docutils literal highlight-c"><span class="n">t_stat</span><span class="w"> </span><span class="n">sim_instr</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="p">)</span></code></p></td>
<td><p>Instruction execution subroutine</p></td>
</tr>
<tr class="row-odd"><td><p><code class="code highlight c docutils literal highlight-c"><span class="n">t_stat</span><span class="w"> </span><span class="n">parse_sym</span><span class="w"> </span><span class="p">(</span><span class="cm">/*…*/</span><span class="p">)</span></code></p></td>
<td><p>Symbolic instruction/data parse subroutine</p></td>
</tr>
<tr class="row-even"><td><p><code class="code highlight c docutils literal highlight-c"><span class="n">t_stat</span><span class="w"> </span><span class="n">fprint_sym</span><span class="w"> </span><span class="p">(</span><span class="cm">/*…*/</span><span class="p">)</span></code></p></td>
<td><p>Symbolic instruction/data print subroutine</p></td>
</tr>
</tbody>
</table>
<p>In addition, there are several optional interfaces,
which can be used for special situations, such as GUI implementations:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Interface</p></th>
<th class="head"><p>Function</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="code highlight c docutils literal highlight-c"><span class="n">t_addr</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">sim_vm_parse_addr</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="cm">/*…*/</span><span class="p">)</span></code></p></td>
<td><p>Pointer to address parsing routine</p></td>
</tr>
<tr class="row-odd"><td><p><code class="code highlight c docutils literal highlight-c"><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">sim_vm_fprint_addr</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="cm">/*…*/</span><span class="p">)</span></code></p></td>
<td><p>Pointer to address output routine</p></td>
</tr>
<tr class="row-even"><td><p><code class="code highlight c docutils literal highlight-c"><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">sim_vm_sprint_addr</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="cm">/*…*/</span><span class="p">)</span></code></p></td>
<td><p>Pointer to address format routine</p></td>
</tr>
<tr class="row-odd"><td><p><code class="code highlight c docutils literal highlight-c"><span class="kt">char</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">sim_vm_read</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="cm">/*…*/</span><span class="p">)</span></code></p></td>
<td><p>Pointer to command input routine</p></td>
</tr>
<tr class="row-even"><td><p><code class="code highlight c docutils literal highlight-c"><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">sim_vm_post</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="cm">/*…*/</span><span class="p">)</span></code></p></td>
<td><p>Pointer to command post-processing routine</p></td>
</tr>
<tr class="row-odd"><td><p><code class="code highlight c docutils literal highlight-c"><span class="n">t_bool</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">sim_vm_fprint_stopped</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="cm">/*…*/</span><span class="p">)</span></code></p></td>
<td><p>Pointer to stop message format routine</p></td>
</tr>
<tr class="row-even"><td><p><code class="code highlight c docutils literal highlight-c"><span class="n">t_value</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">sim_vm_pc_value</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="cm">/*…*/</span><span class="p">)</span></code></p></td>
<td><p>Pointer to routine returning the VM PC value</p></td>
</tr>
<tr class="row-odd"><td><p><code class="code highlight c docutils literal highlight-c"><span class="n">t_bool</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">sim_vm_is_subroutine_call</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="cm">/*…*/</span><span class="p">)</span></code></p></td>
<td><p>Pointer to routine that determines if the current instruction is a subroutine call</p></td>
</tr>
<tr class="row-even"><td><p><code class="code highlight c docutils literal highlight-c"><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">sim_vm_release</span></code></p></td>
<td><p>Pointer to string specifying the simulator specific release version</p></td>
</tr>
<tr class="row-odd"><td><p><code class="code highlight c docutils literal highlight-c"><span class="n">CTAB</span><span class="w"> </span><span class="o">*</span><span class="n">sim_vm_cmd</span></code></p></td>
<td><p>Pointer to simulator-specific command table</p></td>
</tr>
</tbody>
</table>
<p>There is no required organization for VM code.
The following convention has been used so far.
Let name be the <em>name</em> of the real system
(<code class="docutils literal notranslate"><span class="pre">i1401</span></code> for the IBM 1401;
<code class="docutils literal notranslate"><span class="pre">i1620</span></code> for the IBM 1620;
<code class="docutils literal notranslate"><span class="pre">pdp1</span></code> for the PDP-1;
<code class="docutils literal notranslate"><span class="pre">pdp18b</span></code> for the other 18-bit PDPs;
<code class="docutils literal notranslate"><span class="pre">pdp8</span></code> for the PDP-8;
<code class="docutils literal notranslate"><span class="pre">pdp11</span></code> for the PDP-11;
<code class="docutils literal notranslate"><span class="pre">nova</span></code> for Nova;
<code class="docutils literal notranslate"><span class="pre">hp2100</span></code> for the HP 21XX;
<code class="docutils literal notranslate"><span class="pre">h316</span></code> for the Honeywell 315/516;
<code class="docutils literal notranslate"><span class="pre">gri</span></code> for the GRI-909;
<code class="docutils literal notranslate"><span class="pre">pdp10</span></code> for the PDP-10;
<code class="docutils literal notranslate"><span class="pre">vax</span></code> for the VAX;
<code class="docutils literal notranslate"><span class="pre">sds</span></code> for the SDS-940):</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">name.h</span></code> contains definitions for the particular simulator</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">name_sys.c</span></code> contains all the SCP interfaces except the instruction simulator</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">name_cpu.c</span></code> contains the instruction simulator and CPU data structures</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">name_stddev.c</span></code> contains the peripherals which were standard with the real system.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">name_lp.c</span></code> contains the line printer.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">name_mt.c</span></code> contains the mag tape controller and drives, etc.</p></li>
</ul>
<p>The SIMH standard definitions are in <code class="docutils literal notranslate"><span class="pre">sim_defs.h</span></code>.
Most definitions required by a VM can be obtained simply by including that file.
A few require additional header files; those are called out below.
The base components of SIMH are:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Source module</p></th>
<th class="head"><p>Header file</p></th>
<th class="head"><p>Module</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">scp.c</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">scp.h</span></code></p></td>
<td><p>Control package</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">sim_console.c</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">sim_console.h</span></code></p></td>
<td><p>Terminal I/O library</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">sim_fio.c</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">sim_fio.h</span></code></p></td>
<td><p>File I/O library</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">sim_timer.c</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">sim_timer.h</span></code></p></td>
<td><p>Timer library</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sim-sock-c"><code class="docutils literal notranslate"><span class="pre">sim_sock.c</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">sim_sock.h</span></code></p></td>
<td><p>Socket I/O library</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">sim_ether.c</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">sim_ether.h</span></code></p></td>
<td><p>Ethernet I/O library</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sim-serial-c"><code class="docutils literal notranslate"><span class="pre">sim_serial.c</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">sim_serial.h</span></code></p></td>
<td><p>Serial Port I/O library</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sim-tmxr-c"><code class="docutils literal notranslate"><span class="pre">sim_tmxr.c</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">sim_tmxr.h</span></code></p></td>
<td><p>Terminal multiplexer simulation library</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sim-disk-c"><code class="docutils literal notranslate"><span class="pre">sim_disk.c</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">sim_disk.h</span></code></p></td>
<td><p>Disk simulation library</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sim-tape-c"><code class="docutils literal notranslate"><span class="pre">sim_tape.c</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">sim_tape.h</span></code></p></td>
<td><p>Magtape simulation library</p></td>
</tr>
</tbody>
</table>
<section id="cpu-organization">
<h3><span class="sectnum">1.3.1. </span>CPU organization<a class="headerlink" href="#cpu-organization" title="Permalink to this heading">¶</a></h3>
<p>Most CPUs perform at least the following functions:</p>
<ul class="simple">
<li><p>Time keeping</p></li>
<li><p>Instruction fetching</p></li>
<li><p>Address decoding</p></li>
<li><p>Execution of non-I/O instructions</p></li>
<li><p>I/O command processing</p></li>
<li><p>Interrupt processing</p></li>
</ul>
<p>Instruction execution is actually the least complicated part of the design;
memory and I/O organization should be tackled first.</p>
<section id="time-base">
<span id="section-3-1-1"></span><h4><span class="sectnum">1.3.1.1. </span>Time base<a class="headerlink" href="#time-base" title="Permalink to this heading">¶</a></h4>
<p>In order to simulate asynchronous events,
such as I/O completion,
the VM must define and keep a time base.
This can be accurate
(for example, nanoseconds of execution)
or arbitrary
(for example, number of instructions executed),
but it must be used consistently throughout the VM.
Many existing VMs count time in instructions,
some count time in cycles that may align with cycles in the original hardware that may reflect different instructions and/or combinations of memory references.</p>
<p>The CPU is responsible for counting down the event counter <a class="reference internal" href="#sim-interval"><code class="docutils literal notranslate"><span class="pre">sim_interval</span></code></a> and calling the asynchronous event controller <a class="reference internal" href="#sim-process-event"><code class="docutils literal notranslate"><span class="pre">sim_process_event</span></code></a>.
SCP does the record keeping for timing.</p>
<p>SCP will display pending events or other activities and report the number these event times reflect using the string <code class="docutils literal notranslate"><span class="pre">sim_vm_interval_units</span></code>.
The <code class="docutils literal notranslate"><span class="pre">sim_vm_interval_units</span></code> defaults to <code class="docutils literal notranslate"><span class="pre">&quot;instructions&quot;</span></code>,
but the simulator may change this to <code class="docutils literal notranslate"><span class="pre">&quot;cycles&quot;</span></code> if the simulator tracks machine state updates internally based on cycles.</p>
<p>A simulator’s time base needs to be specifically considered when writing simulated devices.
The correct choice that a <a class="reference internal" href="#device"><code class="docutils literal notranslate"><span class="pre">DEVICE</span></code></a> may use depends on,
not only the <a class="reference internal" href="#sim-interval"><code class="docutils literal notranslate"><span class="pre">sim_interval</span></code></a> decrement strategy,
but also the nature of how long the <a class="reference internal" href="#device"><code class="docutils literal notranslate"><span class="pre">DEVICE</span></code></a> being simulated completed various activities actually being simulated.
Usually, <a class="reference internal" href="#device"><code class="docutils literal notranslate"><span class="pre">DEVICE</span></code></a>s simulate some physical interaction that the CPU made with mechanical components
(tape drives, card readers, disk drives, etc.).
The time that activities on these mechanical devices was many times the instruction execution rate of the processor (100s, 1000s or more).
A <a class="reference internal" href="#device"><code class="docutils literal notranslate"><span class="pre">DEVICE</span></code></a> author usually chooses <a class="reference internal" href="#device"><code class="docutils literal notranslate"><span class="pre">DEVICE</span></code></a> delays that are something between:</p>
<ol class="arabic simple">
<li><p>The amount of <a class="reference internal" href="#sim-interval"><code class="docutils literal notranslate"><span class="pre">sim_interval</span></code></a> decrements that relates to how long the activities on that particular <a class="reference internal" href="#device"><code class="docutils literal notranslate"><span class="pre">DEVICE</span></code></a> actually took.</p></li>
<li><p>The absolute minimum that software
(operating systems, applications, or diagnostics)
running within the simulator were capable of receiving a completion notification for the particular <a class="reference internal" href="#device"><code class="docutils literal notranslate"><span class="pre">DEVICE</span></code></a> activity.</p></li>
</ol>
<p>The absolute minimum case would often reflect that the software in question (device driver, or other) may setup some sort of I/O to the device
but not actually be prepared to realize the operation’s completion one instruction after whatever the CPU did to initiate the operation
(for instance the interrupt handler for device’s I/O completion).
It probably would have been smarter if the original software author established the interrupt handler before initiating the I/O activity,
but real hardware never responded in one instruction time,
so that software always worked on hardware.
Since the goal of the simulation is to have the simulator work with existing software,
the <a class="reference internal" href="#device"><code class="docutils literal notranslate"><span class="pre">DEVICE</span></code></a> simulation should reflect this goal.
This minimum value is usually observed during <a class="reference internal" href="#device"><code class="docutils literal notranslate"><span class="pre">DEVICE</span></code></a> simulator development and thus adjusted by the failure of such software.</p>
</section>
<section id="step-function">
<h4><span class="sectnum">1.3.1.2. </span>Step function<a class="headerlink" href="#step-function" title="Permalink to this heading">¶</a></h4>
<p>SCP implements a stepping function using the <code class="docutils literal notranslate"><span class="pre">STEP</span></code> command.
<code class="docutils literal notranslate"><span class="pre">STEP</span></code> counts down a specified number of time units (as described in <a class="reference internal" href="#section-3-1-1">section 3.1.1</a>) and then stops simulation.
The VM can override the <code class="docutils literal notranslate"><span class="pre">STEP</span></code> command’s counts by calling routine <code class="docutils literal notranslate"><span class="pre">sim_cancel_step</span></code>:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">t_stat</span><span class="w"> </span><span class="n">sim_cancel_step</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"> </span><span class="cm">/* cancel STEP count down */</span>
</pre></div>
</div>
<p>The VM can then inspect variable <code class="docutils literal notranslate"><span class="pre">sim_step</span></code> to see if a <code class="docutils literal notranslate"><span class="pre">STEP</span></code> command is in progress.
If <code class="docutils literal notranslate"><span class="pre">sim_step</span></code> is non-zero,
it represents the number of steps to execute.
The VM can count down <code class="docutils literal notranslate"><span class="pre">sim_step</span></code> using its own counting method,
such as cycles, instructions, or memory references.
If the VM counts steps in units other than instructions,
it can set the <code class="docutils literal notranslate"><span class="pre">sim_vm_step_unit</span></code> string pointer to reflect this.</p>
</section>
<section id="memory-organization">
<h4><span class="sectnum">1.3.1.3. </span>Memory organization<a class="headerlink" href="#memory-organization" title="Permalink to this heading">¶</a></h4>
<p>The criterion for memory layout is very simple:
use the SIMH data type that is as large as
(or if necessary, larger than),
the word length of the real machine.
Note that the criterion is word length, not addressability:
the PDP-11 has byte addressable memory,
but it is a 16-bit machine, and its memory is defined as <code class="code highlight c docutils literal highlight-c"><span class="n">uint16</span><span class="w"> </span><span class="n">M</span><span class="p">[]</span></code>.
It may seem tempting to define memory as a union of <code class="code highlight c docutils literal highlight-c"><span class="n">int8</span></code> and <code class="code highlight c docutils literal highlight-c"><span class="n">int16</span></code> data types,
but this would make the resulting VM endian-dependent.
Instead, the VM should be based on the underlying word size of the real machine,
and byte manipulation should be done explicitly.
Examples:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Simulator</p></th>
<th class="head"><p>Memory size</p></th>
<th class="head"><p>Memory declaration</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>IBM 1620</p></td>
<td><p>5-bit</p></td>
<td><p><code class="code highlight c docutils literal highlight-c"><span class="n">uint8</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>IBM 1401</p></td>
<td><p>7-bit</p></td>
<td><p><code class="code highlight c docutils literal highlight-c"><span class="n">uint8</span></code></p></td>
</tr>
<tr class="row-even"><td><p>PDP-8</p></td>
<td><p>12-bit</p></td>
<td><p><code class="code highlight c docutils literal highlight-c"><span class="n">uint16</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>PDP-11, Nova</p></td>
<td><p>16-bit</p></td>
<td><p><code class="code highlight c docutils literal highlight-c"><span class="n">uint16</span></code></p></td>
</tr>
<tr class="row-even"><td><p>PDP-1</p></td>
<td><p>18-bit</p></td>
<td><p><code class="code highlight c docutils literal highlight-c"><span class="n">uint32</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>VAX</p></td>
<td><p>32-bit</p></td>
<td><p><code class="code highlight c docutils literal highlight-c"><span class="n">uint32</span></code></p></td>
</tr>
<tr class="row-even"><td><p>PDP-10, IBM 7094</p></td>
<td><p>36-bit</p></td>
<td><p><code class="code highlight c docutils literal highlight-c"><span class="n">t_uint64</span></code></p></td>
</tr>
</tbody>
</table>
</section>
<section id="interrupt-organization">
<h4><span class="sectnum">1.3.1.4. </span>Interrupt organization<a class="headerlink" href="#interrupt-organization" title="Permalink to this heading">¶</a></h4>
<p>The design of the VM’s interrupt structure is a complex interaction between efficiency and fidelity to the hardware.
If the VM’s interrupt structure is too abstract,
interrupt driven software may not run.
On the other hand, if it follows the hardware too literally,
it may significantly reduce simulation speed.
One rule I can offer is to minimize the fetch-phase cost of interrupts,
even if this complicates the (much less frequent) evaluation of the interrupt system following an I/O operation or asynchronous event.
Another is not to over-generalize;
even if the real hardware could support 64 or 256 interrupting devices,
the simulators will be running much smaller configurations.
I’ll start with a simple interrupt structure and then offer suggestions for generalization.</p>
<p>In the simplest structure,
interrupt requests correspond to device flags and are kept in an interrupt request variable, with one flag per bit.
The fetch-phase evaluation of interrupts consists of two steps:
are interrupts enabled, and is there an interrupt outstanding?
If all the interrupt requests are kept as single-bit flags in a variable,
the fetch-phase test is very fast:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">int_enable</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">int_requests</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="cm">/* …process interrupt… */</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Indeed, the interrupt enable flag can be made the highest bit in the interrupt request variable,
and the two tests combined:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">int_requests</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">INT_ENABLE</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="cm">/* …process interrupt… */</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Setting or clearing device flags directly sets or clears the appropriate interrupt request flag:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="nl">set</span><span class="p">:</span><span class="w">    </span><span class="n">int_requests</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">int_requests</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">DEVICE_FLAG</span><span class="p">;</span>
<span class="nl">clear</span><span class="p">:</span><span class="w">  </span><span class="n">int_requests</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">int_requests</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="o">~</span><span class="n">DEVICE_FLAG</span><span class="p">;</span>
</pre></div>
</div>
<p>At a slightly higher complexity,
interrupt requests do not correspond directly to device flags but are based on masking the device flags with an enable (or disable) mask.
There are now two parallel variables: device flags and interrupt enable mask.
The fetch-phase test is now:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">int_enable</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="p">(</span><span class="n">dev_flags</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">int_enables</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="cm">/* …process interrupt… */</span>
<span class="p">}</span>
</pre></div>
</div>
<p>As a next step,
the VM may keep a summary interrupt request variable,
which is updated by any change to a device flag or interrupt enable/disable:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="nl">enable</span><span class="p">:</span><span class="w">   </span><span class="n">int_requests</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">device_flags</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">int_enables</span><span class="p">;</span>
<span class="nl">disable</span><span class="p">:</span><span class="w">  </span><span class="n">int_requests</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">device_flags</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="o">~</span><span class="n">int_disables</span><span class="p">;</span>
</pre></div>
</div>
<p>This simplifies the fetch phase test slightly.</p>
<p>At yet higher complexity,
the interrupt system may be too complex or too large to evaluate during the fetch-phase.
In this case, an interrupt pending flag is created,
and it is evaluated by subroutine call whenever a change could occur
(start of execution, I/O instruction issued, device time out occurs).
This makes fetch-phase evaluation simple and isolates interrupt evaluation to a common subroutine.</p>
<p>If required for interrupt processing,
the highest priority interrupting device can be determined by scanning the interrupt request variable from high priority to low until a set bit is found.
The bit position can then be back-mapped through a table to determine the address or interrupt vector of the interrupting device.</p>
</section>
<section id="i-o-dispatching">
<h4><span class="sectnum">1.3.1.5. </span>I/O dispatching<a class="headerlink" href="#i-o-dispatching" title="Permalink to this heading">¶</a></h4>
<p>I/O dispatching consists of four steps:</p>
<ul class="simple">
<li><p>Identify the I/O command and analyze for the device address.</p></li>
<li><p>Locate the selected device.</p></li>
<li><p>Break down the I/O command into standard fields.</p></li>
<li><p>Call the device processor.</p></li>
</ul>
<p>Analyzing an I/O command is usually easy.
Most systems have one or more explicit I/O instructions containing an I/O command and a device address.
Memory mapped I/O is more complicated;
the identification of a reference to I/O space becomes part of memory addressing.
This usually requires centralizing memory reads and writes into subroutines,
rather than as inline code.</p>
<p>Once an I/O command has been analyzed,
the CPU must locate the device subroutine.
The simplest way is a large switch statement with hardwired subroutine calls.
More modular is to call through a dispatch table,
with <code class="code highlight c docutils literal highlight-c"><span class="nb">NULL</span></code> entries representing non-existent devices;
this also simplifies support for modifiable device addresses and configurable devices.
Before calling the device routine,
the CPU usually breaks down the I/O command into standard fields.
This simplifies writing the peripheral simulator.</p>
</section>
<section id="instruction-execution">
<h4><span class="sectnum">1.3.1.6. </span>Instruction execution<a class="headerlink" href="#instruction-execution" title="Permalink to this heading">¶</a></h4>
<p>Instruction execution is the responsibility of VM subroutine <a class="reference internal" href="#id7"><code class="docutils literal notranslate"><span class="pre">sim_instr</span></code></a>.
It is called from SCP as a result of a <code class="docutils literal notranslate"><span class="pre">RUN</span></code>, <code class="docutils literal notranslate"><span class="pre">GO</span></code>, <code class="docutils literal notranslate"><span class="pre">CONT</span></code>, or <code class="docutils literal notranslate"><span class="pre">BOOT</span></code> command.
It begins executing instructions at the current PC
(<a class="reference internal" href="#sim-pc"><code class="docutils literal notranslate"><span class="pre">sim_PC</span></code></a> points to its register description block)
and continues until halted by an error or an external event.</p>
<p>When called, the CPU needs to account for any state changes that the user made.
For example, it may need to re-evaluate whether an interrupt is pending,
or restore frequently used state to local register variables for efficiency.
The actual instruction fetch and execute cycle is usually structured as a loop controlled by an error variable, e.g.,</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">reason</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="k">do</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="cm">/* … */</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">reason</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="cm">/* Or */</span>
<span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">reason</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="cm">/* … */</span><span class="w"> </span><span class="p">}</span>
</pre></div>
</div>
<p>Within this loop, the usual order of events is:</p>
<ul>
<li><p>If the event timer <a class="reference internal" href="#sim-interval"><code class="docutils literal notranslate"><span class="pre">sim_interval</span></code></a> has reached zero, process any timed events.
This is done by SCP subroutine <a class="reference internal" href="#sim-process-event"><code class="docutils literal notranslate"><span class="pre">sim_process_event</span></code></a>.
Because this is the polling mechanism for user-generated processor halts (<code class="docutils literal notranslate"><span class="pre">^E</span></code>),
errors must be recognized immediately:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">sim_interval</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">reason</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sim_process_event</span><span class="w"> </span><span class="p">())</span>
<span class="w">        </span><span class="k">break</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</li>
<li><p>Check for outstanding interrupts and process if required.</p></li>
<li><p>Check for other processor-unique events,
such as wait-state outstanding or traps outstanding.</p></li>
<li><p>Check for an instruction breakpoint.
SCP has a comprehensive breakpoint facility.
It allows a VM to define many different kinds of breakpoints.
The VM checks for execution (type E) breakpoints during instruction fetch.</p></li>
<li><p>Fetch the next instruction,
increment the PC,
optionally decode the address,
and dispatch (via a <code class="docutils literal notranslate"><span class="pre">switch</span></code> statement) for execution.</p></li>
</ul>
<p>A few guidelines for implementation:</p>
<ul class="simple">
<li><p>In general, code should reflect the hardware being simulated.
This is usually simplest and easiest to debug.</p></li>
<li><p>The VM should provide some debugging aids.
The existing CPU’s all provide multiple instruction breakpoints,
a PC change queue,
error stops on invalid instructions or operations,
and symbolic examination and modification of memory.</p></li>
</ul>
</section>
</section>
<section id="peripheral-device-organization">
<h3><span class="sectnum">1.3.2. </span>Peripheral device organization<a class="headerlink" href="#peripheral-device-organization" title="Permalink to this heading">¶</a></h3>
<p>The basic elements of a VM are devices,
each corresponding roughly to a real chunk of hardware.
A device consists of register-based state and one or more units.
Thus, a multi-drive disk subsystem is a single device
(representing the hardware of the real controller) and one or more units
(each representing a single disk drive).
Sometimes the device and its unit are the same entity as,
for example,
in the case of a paper tape reader.
However, a single physical device,
such as the console,
may be broken up for convenience into separate input and output devices.</p>
<p>In general, units correspond to individual sources of input or output
(one tape transport, one A-to-D channel).
Units are the basic medium for both device timing and device I/O.
Except for the console, terminals, and network devices,
all other I/O devices are simulated as host-resident files.
SCP allows the user to make an explicit association between a host-resident file and a simulated hardware entity.</p>
<p>Both devices and units have state.
Devices operate on <em>registers</em>,
which contain information about the state of the device,
and indirectly, about the state of the units.
Units operate on <em>data sets</em>,
which may be thought of as individual instances of input or output,
such as a disk pack or a punched paper tape.
In a typical multi-unit device,
all units are the same,
and the device performs similar operations on all of them,
depending on which one has been selected by the program being simulated.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>SIMH, like MIMIC, restricts registers to devices.
Replicated registers, for example, disk drive current state,
are handled via register arrays).</p>
</div>
<p>For each structural level,
SIMH defines,
and the VM must supply,
a corresponding data structure.
<a class="reference internal" href="#device"><code class="docutils literal notranslate"><span class="pre">DEVICE</span></code></a> structures correspond to devices,
<a class="reference internal" href="#reg"><code class="docutils literal notranslate"><span class="pre">REG</span></code></a> structures to registers,
and <a class="reference internal" href="#unit"><code class="docutils literal notranslate"><span class="pre">UNIT</span></code></a> structures to units.
These structures are described in detail in <a class="reference internal" href="#section-4">section 4</a>.</p>
<p>The primary functions of a peripheral are:</p>
<ul class="simple">
<li><p>command decoding and execution</p></li>
<li><p>device timing</p></li>
<li><p>data transmission</p></li>
</ul>
<p>Command decoding is fairly obvious.
At least one section of the peripheral code module will be devoted to processing directives issued by the CPU.
Typically, the command decoder will be responsible for register and flag manipulation,
and for issuing or canceling I/O requests.
The former is easy,
but the later requires a thorough understanding of device timing.</p>
<section id="device-timing">
<h4><span class="sectnum">1.3.2.1. </span>Device timing<a class="headerlink" href="#device-timing" title="Permalink to this heading">¶</a></h4>
<p>The principal problem in I/O device simulation is imitating asynchronous operations in a sequential simulation environment.
Fortunately, the timing characteristics of most I/O devices do not vary with external circumstances.
The distinction between devices whose timing is externally generated
(e.g., console keyboard)
and those whose timing is internally generated (disk, paper tape reader) is crucial.
With an externally timed device,
there is no way to know when an in-progress operation will begin or end; with an internally timed device,
given the time when an operation starts,
the end time can be calculated.</p>
<p>For an internally-timed device,
the elapsed time between the start and conclusion of an operation is called the wait time.
Some typical internally timed devices and their wait times include:</p>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p>PTR (300 char/sec)</p></td>
<td><p>3.3 msec</p></td>
</tr>
<tr class="row-even"><td><p>PTP (50 char/sec)</p></td>
<td><p>20 msec</p></td>
</tr>
<tr class="row-odd"><td><p>CLK (line frequency)</p></td>
<td><p>16.6 msec</p></td>
</tr>
<tr class="row-even"><td><p>TTO (30 char/sec)</p></td>
<td><p>33 msec</p></td>
</tr>
</tbody>
</table>
<p>Mass storage devices,
such as disks and tapes,
do not have a fixed response time,
but a start-to-finish time can be calculated based on current versus desired position,
state of motion, etc.</p>
<p>For an externally-timed device,
there is no portable mechanism by which a VM can be notified of an external event
(for example, a key stroke).
Accordingly, all current VMs poll for keyboard input,
thus converting the externally-timed keyboard to a pseudo-internally timed device.
A more general restriction is that SIMH is single-threaded.
Threaded operations must be done by polling using the unit timing mechanism,
either with real units or fake units created expressly for polling.</p>
<p>SCP provides the supporting routines for device timing.
SCP maintains a list of units (called active units) that are in the process of timing out.
It also provides routines for querying or manipulating this list (called the active queue).
Lastly, it provides a routine for checking for timed-out units and executing a VM-specified action when a time-out occurs.</p>
<p>Device timing is done with the <a class="reference internal" href="#unit"><code class="docutils literal notranslate"><span class="pre">UNIT</span></code></a> structure,
described in <a class="reference internal" href="#section-4">section 4</a>.
To set up a timed operation, the peripheral calculates a waiting period for a unit and places that unit on the active queue.
The CPU counts down the waiting period.
When the waiting period has expired,
<a class="reference internal" href="#sim-process-event"><code class="docutils literal notranslate"><span class="pre">sim_process_event</span></code></a> removes the unit from the active queue and calls a device subroutine.
A device may also cancel an outstanding timed operation and query the state of the queue.
The timing subroutines are:</p>
<dl class="simple" id="sim-activate">
<dt><code class="code highlight c docutils literal highlight-c"><span class="n">t_stat</span><span class="w"> </span><span class="n">sim_activate</span><span class="w"> </span><span class="p">(</span><span class="n">UNIT</span><span class="w"> </span><span class="o">*</span><span class="n">uptr</span><span class="p">,</span><span class="w"> </span><span class="n">int32</span><span class="w"> </span><span class="n">wait</span><span class="p">)</span></code></dt><dd><p>This routine places the specified unit on the active queue with the specified waiting period.
A waiting period of 0 is legal; negative waits cause an error.
If the unit is already active, the active queue is not changed, and no error occurs.</p>
</dd>
</dl>
<dl class="simple" id="sim-activate-abs">
<dt><code class="code highlight c docutils literal highlight-c"><span class="n">t_stat</span><span class="w"> </span><span class="n">sim_activate_abs</span><span class="w"> </span><span class="p">(</span><span class="n">UNIT</span><span class="w"> </span><span class="o">*</span><span class="n">uptr</span><span class="p">,</span><span class="w"> </span><span class="n">int32</span><span class="w"> </span><span class="n">wait</span><span class="p">)</span></code></dt><dd><p>This routine places the specified unit on the active queue with the specified waiting period.
A waiting period of 0 is legal; negative waits cause an error.
If the unit is already active,
the specified waiting period overrides the currently pending waiting period.</p>
</dd>
</dl>
<dl class="simple" id="sim-activate-after">
<dt><code class="code highlight c docutils literal highlight-c"><span class="n">t_stat</span><span class="w"> </span><span class="n">sim_activate_after</span><span class="w"> </span><span class="p">(</span><span class="n">UNIT</span><span class="w"> </span><span class="o">*</span><span class="n">uptr</span><span class="p">,</span><span class="w"> </span><span class="n">uint32</span><span class="w"> </span><span class="n">usec_delay</span><span class="p">)</span></code></dt><dd><p>This routine places the specified unit on the active queue with the specified delay based on the simulator’s calibrated clock.
The specified delay must be greater than 0 µsecs.
If the unit is already active,
the active queue is not changed,
and no error occurs.</p>
</dd>
</dl>
<dl class="simple" id="sim-activate-after-d">
<dt><code class="code highlight c docutils literal highlight-c"><span class="n">t_stat</span><span class="w"> </span><span class="n">sim_activate_after_d</span><span class="w"> </span><span class="p">(</span><span class="n">UNIT</span><span class="w"> </span><span class="o">*</span><span class="n">uptr</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">usec_delay</span><span class="p">)</span></code></dt><dd><p>This routine places the specified unit on the active queue with the specified delay based on the simulator’s calibrated clock.
The specified delay must be greater than 0 µsecs.
If the unit is already active,
the active queue is not changed,
and no error occurs.</p>
</dd>
</dl>
<dl class="simple" id="sim-activate-after-abs">
<dt><code class="code highlight c docutils literal highlight-c"><span class="n">t_stat</span><span class="w"> </span><span class="n">sim_activate_after_abs</span><span class="w"> </span><span class="p">(</span><span class="n">UNIT</span><span class="w"> </span><span class="o">*</span><span class="n">uptr</span><span class="p">,</span><span class="w"> </span><span class="n">uint32</span><span class="w"> </span><span class="n">usec_delay</span><span class="p">)</span></code></dt><dd><p>This routine places the specified unit on the active queue with the specified delay based on the simulator’s calibrated clock.
The specified delay must be greater than 0 µsecs.
If the unit is already active,
the specified delay overrides the currently pending waiting period.</p>
</dd>
</dl>
<dl class="simple" id="sim-activate-after-abs-d">
<dt><code class="code highlight c docutils literal highlight-c"><span class="n">t_stat</span><span class="w"> </span><span class="n">sim_activate_after_abs_d</span><span class="w"> </span><span class="p">(</span><span class="n">UNIT</span><span class="w"> </span><span class="o">*</span><span class="n">uptr</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">usec_delay</span><span class="p">)</span></code></dt><dd><p>This routine places the specified unit on the active queue with the specified delay based on the simulator’s calibrated clock.
The specified delay must be greater than 0 µsecs.
If the unit is already active,
the specified delay overrides the currently pending waiting period.</p>
</dd>
</dl>
<dl class="simple" id="sim-cancel">
<dt><code class="code highlight c docutils literal highlight-c"><span class="n">t_stat</span><span class="w"> </span><span class="n">sim_cancel</span><span class="w"> </span><span class="p">(</span><span class="n">UNIT</span><span class="w"> </span><span class="o">*</span><span class="n">uptr</span><span class="p">)</span></code></dt><dd><p>This routine removes the specified unit from the active queue.
If the unit is not on the queue,
no error occurs.</p>
</dd>
</dl>
<dl class="simple" id="sim-is-active">
<dt><code class="code highlight c docutils literal highlight-c"><span class="n">t_bool</span><span class="w"> </span><span class="n">sim_is_active</span><span class="w"> </span><span class="p">(</span><span class="n">UNIT</span><span class="w"> </span><span class="o">*</span><span class="n">uptr</span><span class="p">)</span></code></dt><dd><p>This routine tests whether a unit is in the active queue.
If it is, the routine returns <code class="code highlight c docutils literal highlight-c"><span class="n">TRUE</span></code>(<code class="docutils literal notranslate"><span class="pre">1</span></code>);
if it is not, the routine returns <code class="code highlight c docutils literal highlight-c"><span class="n">FALSE</span></code>(<code class="docutils literal notranslate"><span class="pre">0</span></code>).</p>
</dd>
</dl>
<dl class="simple" id="sim-activate-time">
<dt><code class="code highlight c docutils literal highlight-c"><span class="n">int32</span><span class="w"> </span><span class="n">sim_activate_time</span><span class="w"> </span><span class="p">(</span><span class="n">UNIT</span><span class="w"> </span><span class="o">*</span><span class="n">uptr</span><span class="p">)</span></code></dt><dd><p>This routine returns the time the device has remaining in the queue<span class="math notranslate nohighlight">\(\ + 1\)</span>.
If it is not pending, the routine returns 0.</p>
</dd>
</dl>
<dl class="simple" id="sim-activate-time-usecs">
<dt><code class="code highlight c docutils literal highlight-c"><span class="kt">double</span><span class="w"> </span><span class="n">sim_activate_time_usecs</span><span class="w"> </span><span class="p">(</span><span class="n">UNIT</span><span class="w"> </span><span class="o">*</span><span class="n">uptr</span><span class="p">)</span></code></dt><dd><p>This routine returns the wall clock time in µsecs the device has remaining in the queue + 1.
If the unit is not pending, the routine returns 0.</p>
</dd>
</dl>
<dl class="simple" id="sim-gtime">
<dt><code class="code highlight c docutils literal highlight-c"><span class="kt">double</span><span class="w"> </span><span class="n">sim_gtime</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="p">)</span></code></dt><dd><p>This routine returns the time elapsed since the last <code class="docutils literal notranslate"><span class="pre">RUN</span></code> or <code class="docutils literal notranslate"><span class="pre">BOOT</span></code> command.</p>
</dd>
</dl>
<span id="sim-grtime"></span><dl class="simple" id="id1">
<dt><code class="code highlight c docutils literal highlight-c"><span class="n">uint32</span><span class="w"> </span><span class="n">sim_grtime</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="p">)</span></code></dt><dd><p>This routine returns the low-order 32b of the time elapsed since the last <code class="docutils literal notranslate"><span class="pre">RUN</span></code> or <code class="docutils literal notranslate"><span class="pre">BOOT</span></code> command.</p>
</dd>
</dl>
<dl class="simple" id="sim-qcount">
<dt><code class="code highlight c docutils literal highlight-c"><span class="n">int32</span><span class="w"> </span><span class="n">sim_qcount</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="p">)</span></code></dt><dd><p>This routine returns the number of entries on the clock queue.</p>
</dd>
</dl>
<dl class="simple" id="sim-process-event">
<dt><code class="code highlight c docutils literal highlight-c"><span class="n">t_stat</span><span class="w"> </span><span class="n">sim_process_event</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="p">)</span></code></dt><dd><p>This routine removes all timed out units from the active queue and calls the appropriate device subroutine to service the time-out.</p>
</dd>
</dl>
<dl class="simple" id="sim-interval">
<dt><code class="code highlight c docutils literal highlight-c"><span class="n">int32</span><span class="w"> </span><span class="n">sim_interval</span></code></dt><dd><p>This variable represents the time until the first unit on the event queue that is scheduled to happen.
<code class="docutils literal notranslate"><span class="pre">sim_inst</span></code> counts down this value
(usually by 1 for each instruction executed).
If there are no timed events outstanding,
SCP counts down a “null interval” of 10,000 time units.</p>
</dd>
</dl>
</section>
<section id="clock-calibration">
<h4><span class="sectnum">1.3.2.2. </span>Clock calibration<a class="headerlink" href="#clock-calibration" title="Permalink to this heading">¶</a></h4>
<p>The timing mechanism described in the previous section is approximate.
Devices, such as real-time clocks
which track wall time will be inaccurate.
SCP provides routines to synchronize multiple simulated clocks (to a maximum of 8) to wall time.</p>
<dl class="simple" id="sim-rtcn-init-unit-ticks">
<dt><code class="code highlight c docutils literal highlight-c"><span class="n">int32</span><span class="w"> </span><span class="n">sim_rtcn_init_unit_ticks</span><span class="w"> </span><span class="p">(</span><span class="n">UNIT</span><span class="w"> </span><span class="o">*</span><span class="n">uptr</span><span class="p">,</span><span class="w"> </span><span class="n">int32</span><span class="w"> </span><span class="n">clock_interval</span><span class="p">,</span><span class="w"> </span><span class="n">int32</span><span class="w"> </span><span class="n">clk</span><span class="p">,</span><span class="w"> </span><span class="n">int32</span><span class="w"> </span><span class="n">ticksper</span><span class="p">)</span></code></dt><dd><p>This routine initializes the clock calibration mechanism for simulated clock <code class="docutils literal notranslate"><span class="pre">clk</span></code> and <code class="docutils literal notranslate"><span class="pre">uptr</span></code> identifies which unit’s service routine performs clock tick activities.
The argument <code class="docutils literal notranslate"><span class="pre">clock_interval</span></code> is returned as the result.
The <code class="docutils literal notranslate"><span class="pre">ticksper</span></code> argument specifies the clock ticks per second.</p>
</dd>
</dl>
<dl class="simple" id="sim-rtcn-init-unit">
<dt><code class="code highlight c docutils literal highlight-c"><span class="n">int32</span><span class="w"> </span><span class="n">sim_rtcn_init_unit</span><span class="w"> </span><span class="p">(</span><span class="n">UNIT</span><span class="w"> </span><span class="o">*</span><span class="n">uptr</span><span class="p">,</span><span class="w"> </span><span class="n">int32</span><span class="w"> </span><span class="n">clock_interval</span><span class="p">,</span><span class="w"> </span><span class="n">int32</span><span class="w"> </span><span class="n">clk</span><span class="p">,</span><span class="w"> </span><span class="n">int32</span><span class="w"> </span><span class="n">ticksper</span><span class="p">)</span></code></dt><dd><p>This routine initializes the clock calibration mechanism for simulated clock <code class="docutils literal notranslate"><span class="pre">clk</span></code> and <code class="docutils literal notranslate"><span class="pre">uptr</span></code> identifies which unit’s service routine performs clock tick activities.
The argument <code class="docutils literal notranslate"><span class="pre">clock_interval</span></code> is returned as the result.</p>
</dd>
</dl>
<dl class="simple" id="sim-rtcn-calb">
<dt><code class="code highlight c docutils literal highlight-c"><span class="n">int32</span><span class="w"> </span><span class="n">sim_rtcn_calb</span><span class="w"> </span><span class="p">(</span><span class="n">int32</span><span class="w"> </span><span class="n">tickspersecond</span><span class="p">,</span><span class="w"> </span><span class="n">int32</span><span class="w"> </span><span class="n">clk</span><span class="p">)</span></code></dt><dd><p>This routine calibrates simulated clock <code class="docutils literal notranslate"><span class="pre">clk</span></code>.
The argument is the number of clock ticks expected per second.
The return value is the calibrated interval for the next tick.</p>
</dd>
</dl>
<dl class="simple" id="sim-rtcn-calb-tick">
<dt><code class="code highlight c docutils literal highlight-c"><span class="n">int32</span><span class="w"> </span><span class="n">sim_rtcn_calb_tick</span><span class="w"> </span><span class="p">(</span><span class="n">int32</span><span class="w"> </span><span class="n">clk</span><span class="p">)</span></code></dt><dd><p>This routine calibrates simulated clock <code class="docutils literal notranslate"><span class="pre">clk</span></code>.
The return value is the calibrated interval for the next tick.</p>
</dd>
</dl>
<p>Some host computers have relatively poor resolution clock ticks (<span class="math notranslate nohighlight">\(&gt;= 10ms\)</span>) and/or variable or high minimum sleep times (<span class="math notranslate nohighlight">\(&gt; 2ms\)</span>).
Some simulators have clocks which may need to tick faster than the clock resolution or minimum sleep times.
In order to provide accurate time services,
a simulator should notify the timing services that the simulated system has digested a previously generated clock tick.</p>
<dl class="simple" id="sim-rtcn-tick-ack">
<dt><code class="code highlight c docutils literal highlight-c"><span class="n">t_stat</span><span class="w"> </span><span class="n">sim_rtcn_tick_ack</span><span class="w"> </span><span class="p">(</span><span class="n">int32</span><span class="w"> </span><span class="n">delay</span><span class="p">,</span><span class="w"> </span><span class="n">int32</span><span class="w"> </span><span class="n">clk</span><span class="p">)</span></code></dt><dd><p>This routine informs the timing subsystem that the most recent clock tick for the simulated clock has been digested by the simulated system and the timing subsystem can potentially schedule a catchup ticks if necessary.
If a catchup clock tick is necessary,
the delay value indicates how soon the tick can be generated.</p>
</dd>
</dl>
<p>The VM must call <a class="reference internal" href="#sim-rtcn-init-unit-ticks"><code class="docutils literal notranslate"><span class="pre">sim_rtcn_init_unit_ticks</span></code></a> for each simulated clock in two places:
in the reset routine of the <a class="reference internal" href="#device"><code class="docutils literal notranslate"><span class="pre">DEVICE</span></code></a> which implements a clock device
(all reset routines are executed at simulator startup and when a <a class="reference internal" href="#device"><code class="docutils literal notranslate"><span class="pre">DEVICE</span></code></a> is enabled or disabled)
and whenever the real-time clock is started.
The simulator calls <a class="reference internal" href="#sim-rtcn-calb"><code class="docutils literal notranslate"><span class="pre">sim_rtcn_calb</span></code></a> to calculate the actual interval delay when the real-time clock is serviced:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/* clock start */</span>

<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">sim_is_active</span><span class="w"> </span><span class="p">(</span><span class="o">&amp;</span><span class="n">clk_unit</span><span class="p">))</span>
<span class="w">    </span><span class="n">sim_activate</span><span class="w"> </span><span class="p">(</span><span class="o">&amp;</span><span class="n">clk_unit</span><span class="p">,</span><span class="w"> </span><span class="n">sim_rtcn_init_unit_ticks</span><span class="w"> </span><span class="p">(</span><span class="o">&amp;</span><span class="n">clk_unit</span><span class="p">,</span><span class="w"> </span><span class="n">clk_delay</span><span class="p">,</span><span class="w"> </span><span class="n">clkno</span><span class="p">,</span><span class="w"> </span><span class="n">clk_ticks_per_second</span><span class="p">));</span>
<span class="cm">/* etc. */</span>

<span class="cm">/* clock service */</span>

<span class="n">sim_rtcn_calb_tick</span><span class="w"> </span><span class="p">(</span><span class="n">clkno</span><span class="p">);</span>
<span class="n">sim_activate_after</span><span class="w"> </span><span class="p">(</span><span class="o">&amp;</span><span class="n">clk_unit</span><span class="p">,</span><span class="w"> </span><span class="mi">1000000</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">clk_ticks_per_second</span><span class="p">);</span>

<span class="cm">/* clock register access */</span>

<span class="n">sim_rtcn_tick_ack</span><span class="w"> </span><span class="p">(</span><span class="mi">20</span><span class="p">,</span><span class="w"> </span><span class="n">clkno</span><span class="p">);</span>
</pre></div>
</div>
<p>The real-time clock is usually simulated clock 0;
other clocks are used for polling asynchronous multiplexers or intervals timers.</p>
<p>The underlying timer services will automatically run a calibrated clock whenever the simulator doesn’t have one registered and running or when the registered timer is running too fast for accurate clock calibration.
This will allow the <a class="reference internal" href="#sim-activate-after"><code class="docutils literal notranslate"><span class="pre">sim_activate_after</span></code></a> API to provide proper wall clock relative timing delays.</p>
<p>Some simulated systems use programmatic interval timers to implement clock ticks.
If a simulated system or simulated operating system uses a constant interval to provide the system clock ticks,
then clock device is a candidate to be a calibrated timer.
If the simulated operating system dynamically changes the programmatic interval more than once,
then such a device is not a calibrated timer,
but it certainly should use <a class="reference internal" href="#sim-activate-after"><code class="docutils literal notranslate"><span class="pre">sim_activate_after</span></code></a> and <a class="reference internal" href="#sim-activate-time"><code class="docutils literal notranslate"><span class="pre">sim_activate_time</span></code></a> to implement the programmatic interval delays.</p>
</section>
<section id="pre-calibration">
<h4><span class="sectnum">1.3.2.3. </span>Pre-calibration<a class="headerlink" href="#pre-calibration" title="Permalink to this heading">¶</a></h4>
<p>Some simulator situations expect that instruction execution rates be immediately close to the rate that the host system is capable of executing instructions at and for wall clock delays to be immediately precise.
The simulator framework provides a means of pre-calibrating the instruction execution rate.
A sequence of three to four instructions that run in a tight loop can be used at simulator startup time to compute the execution rate.</p>
<p>The following line in and around the CPU device reset routine will serve to facilitate the precalibration:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">vax_clock_precalibrate_commands</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="s">&quot;-m 100 INCL  120&quot;</span><span class="p">,</span>
<span class="w">    </span><span class="s">&quot;-m 103 INCL  124&quot;</span><span class="p">,</span>
<span class="w">    </span><span class="s">&quot;-m 106 MULL3 120,124,128&quot;</span><span class="p">,</span>
<span class="w">    </span><span class="s">&quot;-m 10D BRW   100&quot;</span><span class="p">,</span>
<span class="w">    </span><span class="s">&quot;PC 100&quot;</span><span class="p">,</span>
<span class="w">    </span><span class="nb">NULL</span>
<span class="p">};</span>

<span class="n">t_stat</span><span class="w"> </span><span class="nf">cpu_reset</span><span class="w"> </span><span class="p">(</span><span class="n">DEVICE</span><span class="w"> </span><span class="o">*</span><span class="n">dptr</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">sim_clock_precalibrate_commands</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vax_clock_precalibrate_commands</span><span class="p">;</span>
<span class="w">    </span><span class="n">sim_vm_initial_ips</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">SIM_INITIAL_IPS</span><span class="p">;</span>
<span class="w">    </span><span class="cm">/* [...] */</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Once pre-calibration has been done,
some wall clock delays on some (very slow) host systems may be unreasonably off with respect to actual instruction execution.
To accommodate for this the simulator may provide an initial expectation of how fast it can execute the pre-calibration instruction loop.
This estimate can be specified by the simulator in the CPU device reset routine.
An appropriate value for the <code class="docutils literal notranslate"><span class="pre">sim_vm_initial_ips</span></code> is best determined by comparing the VAX simulator pre-calibrated result
(displayed in the <code class="docutils literal notranslate"><span class="pre">SHOW</span> <span class="pre">CLOCK</span></code> command)
to your simulator’s pre-calibrated value.
If your value is approximately <em>N</em> times the VAX’s value,
then <code class="docutils literal notranslate"><span class="pre">sim_vm_initial_ips</span></code> should be set to <em>N</em> times <code class="docutils literal notranslate"><span class="pre">SIM_INITIAL_IPS</span></code>.</p>
</section>
<section id="idling">
<h4><span class="sectnum">1.3.2.4. </span>Idling<a class="headerlink" href="#idling" title="Permalink to this heading">¶</a></h4>
<p>Idling is a way of pausing simulation when no real work is happening,
without losing clock calibration.
The VM must detect when it is idle;
it can then inform the host of this situation by calling <code class="docutils literal notranslate"><span class="pre">sim_idle</span></code>:</p>
<dl class="simple" id="sim-idle">
<dt><code class="code highlight c docutils literal highlight-c"><span class="n">t_bool</span><span class="w"> </span><span class="n">sim_idle</span><span class="w"> </span><span class="p">(</span><span class="n">int32</span><span class="w"> </span><span class="n">clk</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">tick_decrement</span><span class="p">)</span></code></dt><dd><p>Attempt to idle the VM until the next scheduled I/O event,
using simulated clock <code class="docutils literal notranslate"><span class="pre">clk</span></code> as the time base,
and decrement <a class="reference internal" href="#sim-interval"><code class="docutils literal notranslate"><span class="pre">sim_interval</span></code></a> by an appropriate number of cycles.
If a calibrated timer is not available,
or the time until the next event is less than 1ms,
decrement <a class="reference internal" href="#sim-interval"><code class="docutils literal notranslate"><span class="pre">sim_interval</span></code></a> by <code class="docutils literal notranslate"><span class="pre">tick_decrement</span></code>;
otherwise, leave <a class="reference internal" href="#sim-interval"><code class="docutils literal notranslate"><span class="pre">sim_interval</span></code></a> unchanged.</p>
</dd>
</dl>
<p><code class="docutils literal notranslate"><span class="pre">sim_idle</span></code> returns <code class="code highlight c docutils literal highlight-c"><span class="n">TRUE</span></code> if the VM actually idled,
<code class="code highlight c docutils literal highlight-c"><span class="n">FALSE</span></code> if it did not.</p>
<p>In order for idling to be well-behaved on the host system,
simulated devices which poll for input (console and terminal multiplexors are examples),
the polling that these devices perform should be done at the same time as when the simulator will unavoidably be executing instructions.
The most common time this happens is when click tick interrupts are generated.
As such, these devices should schedule their polling activities to be aligned with the clock ticks which are happening anyway or some multiple of the clock tick value.</p>
<dl class="simple" id="sim-clock-coschedule">
<dt><code class="code highlight c docutils literal highlight-c"><span class="n">t_stat</span><span class="w"> </span><span class="n">sim_clock_coschedule</span><span class="w"> </span><span class="p">(</span><span class="n">UNIT</span><span class="w"> </span><span class="o">*</span><span class="n">uptr</span><span class="p">,</span><span class="w"> </span><span class="n">int32</span><span class="w"> </span><span class="n">interval</span><span class="p">)</span></code></dt><dd><p>This routine places the specified unit on the active queue behind the default timer at the specified interval rounded up to a whole number of timer ticks.
An interval value 0 is legal;
negative intervals cause an error.
If the unit is already active,
the active queue is not changed,
and no error occurs.</p>
</dd>
</dl>
<dl class="simple" id="sim-clock-coschedule-abs">
<dt><code class="code highlight c docutils literal highlight-c"><span class="n">t_stat</span><span class="w"> </span><span class="n">sim_clock_coschedule_abs</span><span class="w"> </span><span class="p">(</span><span class="n">UNIT</span><span class="w"> </span><span class="o">*</span><span class="n">uptr</span><span class="p">,</span><span class="w"> </span><span class="n">int32</span><span class="w"> </span><span class="n">interval</span><span class="p">)</span></code></dt><dd><p>This routine places the specified unit on the active queue behind the default timer at the specified interval rounded up to a whole number of timer ticks.
An interval value 0 is legal;
negative intervals cause an error.
If the unit is already active,
the specified waiting period overrides the currently pending waiting period.</p>
</dd>
</dl>
<dl class="simple" id="sim-clock-coschedule-tmr">
<dt><code class="code highlight c docutils literal highlight-c"><span class="n">t_stat</span><span class="w"> </span><span class="n">sim_clock_coschedule_tmr</span><span class="w"> </span><span class="p">(</span><span class="n">UNIT</span><span class="w"> </span><span class="o">*</span><span class="n">uptr</span><span class="p">,</span><span class="w"> </span><span class="n">int32</span><span class="w"> </span><span class="n">tmr</span><span class="p">,</span><span class="w"> </span><span class="n">int32</span><span class="w"> </span><span class="n">ticks</span><span class="p">)</span></code></dt><dd><p>This routine places the specified unit on the active queue behind the specified timer with the specified number of clock ticks between invocations.
A tick count of 0 is legal;
negative ticks cause an error.
If the unit is already active,
the active queue is not changed,
and no error occurs.
Events scheduled for 0 or 1 tick will fire on the next clock tick.</p>
</dd>
</dl>
<dl class="simple" id="sim-clock-coschedule-tmr-abs">
<dt><code class="code highlight c docutils literal highlight-c"><span class="n">t_stat</span><span class="w"> </span><span class="n">sim_clock_coschedule_tmr_abs</span><span class="w"> </span><span class="p">(</span><span class="n">UNIT</span><span class="w"> </span><span class="o">*</span><span class="n">uptr</span><span class="p">,</span><span class="w"> </span><span class="n">int32</span><span class="w"> </span><span class="n">tmr</span><span class="p">,</span><span class="w"> </span><span class="n">int32</span><span class="w"> </span><span class="n">ticks</span><span class="p">)</span></code></dt><dd><p>This routine places the specified unit on the active queue behind the specified timer with the specified number of clock ticks between invocations.
A tick count of 0 is legal;
negative ticks cause an error.
If the unit is already active,
the specified waiting period overrides the currently pending waiting period.
Events scheduled for 0 or 1 tick will fire on the next clock tick.</p>
</dd>
</dl>
<p>Because idling and throttling are mutually exclusive,
the VM must inform SCP when idling is turned on or off:</p>
<dl class="simple" id="sim-set-idle">
<dt><code class="code highlight c docutils literal highlight-c"><span class="n">t_stat</span><span class="w"> </span><span class="n">sim_set_idle</span><span class="w"> </span><span class="p">(</span><span class="n">UNIT</span><span class="w"> </span><span class="o">*</span><span class="n">uptr</span><span class="p">,</span><span class="w"> </span><span class="n">int32</span><span class="w"> </span><span class="n">val</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">cptr</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">desc</span><span class="p">)</span></code></dt><dd><p>Inform SCP that idling is enabled.</p>
</dd>
</dl>
<dl class="simple" id="sim-clr-idle">
<dt><code class="code highlight c docutils literal highlight-c"><span class="n">t_stat</span><span class="w"> </span><span class="n">sim_clr_idle</span><span class="w"> </span><span class="p">(</span><span class="n">UNIT</span><span class="w"> </span><span class="o">*</span><span class="n">uptr</span><span class="p">,</span><span class="w"> </span><span class="n">int32</span><span class="w"> </span><span class="n">val</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">cptr</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">desc</span><span class="p">)</span></code></dt><dd><p>Inform SCP that idling is disabled.</p>
</dd>
</dl>
<dl class="simple" id="sim-show-idle">
<dt><code class="code highlight c docutils literal highlight-c"><span class="n">t_stat</span><span class="w"> </span><span class="n">sim_show_idle</span><span class="w"> </span><span class="p">(</span><span class="kt">FILE</span><span class="w"> </span><span class="o">*</span><span class="n">st</span><span class="p">,</span><span class="w"> </span><span class="n">UNIT</span><span class="w"> </span><span class="o">*</span><span class="n">uptr</span><span class="p">,</span><span class="w"> </span><span class="n">int32</span><span class="w"> </span><span class="n">val</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">desc</span><span class="p">)</span></code></dt><dd><p>Display whether idling is enabled or disabled, as seen by SCP.</p>
</dd>
</dl>
</section>
<section id="data-i-o">
<h4><span class="sectnum">1.3.2.5. </span>Data I/O<a class="headerlink" href="#data-i-o" title="Permalink to this heading">¶</a></h4>
<p>For most devices, timing is half the battle
(for clocks it is the entire war);
the other half is I/O.
Some devices are simulated on real hardware
(for example, Ethernet controllers).
Most I/O devices are simulated as files on the host file system in little-endian format.
SCP provides facilities for associating files with units (<code class="docutils literal notranslate"><span class="pre">ATTACH</span></code> command)
and for reading and writing data from and to devices in an endian- and size-independent way.</p>
<p>For most devices, the VM designer does not have to be concerned about the formatting of simulated device files.
I/O occurs in 1, 2, 4, or 8 byte quantities;
SCP automatically chooses the correct data size and corrects for byte ordering.
Specific issues:</p>
<ul class="simple">
<li><p>Line printers should write data as 7-bit ASCII,
with newlines replacing carriage-return/line-feed sequences.</p></li>
<li><p>Disks should be viewed as linear data sets,
from sector 0 of surface 0 of cylinder 0 to the last sector on the disk.
This allows easy transcription of real disks to files usable by the simulator.</p></li>
<li><p>Magtapes, by convention, use a record based format.
Each record consists of a leading 32-bit record length,
the record data (padded with a byte of 0 if the record length is odd),
and a trailing 32-bit record length.
File marks are recorded as one record length of 0.</p></li>
<li><p>Cards have 12 bits of data per column,
but the data is most conveniently viewed as (ASCII) characters.
Column binary can be implemented using two successive characters per card column.</p></li>
</ul>
<p>Data I/O varies between fixed and variable capacity devices,
and between buffered and non-buffered devices.
A fixed capacity device differs from a variable capacity device in that the file attached to the former has a maximum size,
while the file attached to the latter may expand indefinitely.
A buffered device differs from a non-buffered device in that the former buffers its data set in host memory,
while the latter maintains it as a file.
Most variable capacity devices
(such as the paper tape reader and punch)
are sequential;
all buffered devices are fixed capacity.</p>
<section id="reading-and-writing-data">
<h5><span class="sectnum">1.3.2.5.1. </span>Reading and writing data<a class="headerlink" href="#reading-and-writing-data" title="Permalink to this heading">¶</a></h5>
<p>The <code class="docutils literal notranslate"><span class="pre">ATTACH</span></code> command creates an association between a host file and an I/O unit.
For non-buffered devices, <code class="docutils literal notranslate"><span class="pre">ATTACH</span></code> stores the file pointer for the host file in the <a class="reference internal" href="#unit-fileref"><code class="docutils literal notranslate"><span class="pre">fileref</span></code></a> field of the <a class="reference internal" href="#unit"><code class="docutils literal notranslate"><span class="pre">UNIT</span></code></a> structure.
For buffered devices, <code class="docutils literal notranslate"><span class="pre">ATTACH</span></code> reads the entire host file into a buffer pointed to by the <a class="reference internal" href="#unit-filebuf"><code class="docutils literal notranslate"><span class="pre">UNIT.filebuf</span></code></a> field of the <a class="reference internal" href="#unit"><code class="docutils literal notranslate"><span class="pre">UNIT</span></code></a> structure.
If unit flag <code class="docutils literal notranslate"><span class="pre">UNIT_MUSTBUF</span></code> is set,
the buffer is allocated dynamically;
otherwise, it must be statically allocated.</p>
<p>For non-buffered devices,
I/O is done with standard C subroutines plus the SCP routines <code class="docutils literal notranslate"><span class="pre">sim_fread</span></code> and <code class="docutils literal notranslate"><span class="pre">sim_fwrite</span></code>.
<code class="docutils literal notranslate"><span class="pre">sim_fread</span></code> and <code class="docutils literal notranslate"><span class="pre">sim_fwrite</span></code> are identical in calling sequence and function to <code class="code highlight c docutils literal highlight-c"><span class="n">fread</span></code> and <code class="code highlight c docutils literal highlight-c"><span class="n">fwrite</span></code>, respectively,
but will correct for endian dependencies.
For buffered devices,
I/O is done by copying data to or from the allocated buffer.
The device code must maintain the number (+1) of the highest address modified in the <a class="reference internal" href="#unit-hwmark"><code class="docutils literal notranslate"><span class="pre">hwmark</span></code></a> field of the <a class="reference internal" href="#unit"><code class="docutils literal notranslate"><span class="pre">UNIT</span></code></a> structure.
For both the non-buffered and buffered cases,
the device must perform all address calculations and positioning operations.</p>
<p>SIMH provides capabilities to access files &gt;2GB
(the <code class="code highlight c docutils literal highlight-c"><span class="n">int32</span></code> position limit).
If a VM is compiled with flags <code class="docutils literal notranslate"><span class="pre">USE_INT64</span></code> and <code class="docutils literal notranslate"><span class="pre">USE_ADDR64</span></code> defined,
then <code class="code highlight c docutils literal highlight-c"><span class="n">t_addr</span></code> is defined as <code class="code highlight c docutils literal highlight-c"><span class="n">t_uint64</span></code> rather than <code class="code highlight c docutils literal highlight-c"><span class="n">uint32</span></code>.
Routine <code class="docutils literal notranslate"><span class="pre">sim_fseek</span></code> allows simulated devices to perform random access in large files:</p>
<dl class="simple" id="sim-fseek">
<dt><code class="code highlight c docutils literal highlight-c"><span class="kt">int</span><span class="w"> </span><span class="n">sim_fseek</span><span class="w"> </span><span class="p">(</span><span class="kt">FILE</span><span class="w"> </span><span class="o">*</span><span class="n">handle</span><span class="p">,</span><span class="w"> </span><span class="n">t_addr</span><span class="w"> </span><span class="n">position</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">where</span><span class="p">)</span></code></dt><dd><p>Identical to the standard C <code class="code highlight c docutils literal highlight-c"><span class="n">fseek</span></code>, with two exceptions:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">SEEK_END</span></code> is not supported.</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">position</span></code> argument can be 64b wide.</p></li>
</ul>
</dd>
</dl>
<p>The <code class="docutils literal notranslate"><span class="pre">DETACH</span></code> command breaks the association between a host file and an I/O unit.
For buffered devices, <code class="docutils literal notranslate"><span class="pre">DETACH</span></code> writes the allocated buffer back to the host file.</p>
</section>
<section id="console-i-o">
<h5><span class="sectnum">1.3.2.5.2. </span>Console I/O<a class="headerlink" href="#console-i-o" title="Permalink to this heading">¶</a></h5>
<p>SCP provides three routines for console I/O.</p>
<dl class="simple" id="sim-poll-kbd">
<dt><code class="code highlight c docutils literal highlight-c"><span class="n">t_stat</span><span class="w"> </span><span class="n">sim_poll_kbd</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="p">)</span></code></dt><dd><p>This routine polls for keyboard input.
If there is a character, it returns <code class="docutils literal notranslate"><span class="pre">SCPE_KFLAG</span></code> + the character.
If the console is attached to a Telnet connection,
and the connection is lost,
the routine returns <code class="docutils literal notranslate"><span class="pre">SCPE_LOST</span></code>.
If there is no input, it returns <code class="docutils literal notranslate"><span class="pre">SCPE_OK</span></code>.</p>
</dd>
</dl>
<dl class="simple" id="sim-putchar">
<dt><code class="code highlight c docutils literal highlight-c"><span class="n">t_stat</span><span class="w"> </span><span class="n">sim_putchar</span><span class="w"> </span><span class="p">(</span><span class="n">int32</span><span class="w"> </span><span class="kt">char</span><span class="p">)</span></code></dt><dd><p>This routine types the specified ASCII character to the console.
If the console is attached to a Telnet connection,
and the connection is lost,
the routine returns <code class="docutils literal notranslate"><span class="pre">SCPE_LOST</span></code>.</p>
</dd>
</dl>
<dl class="simple" id="sim-putchar-s">
<dt><code class="code highlight c docutils literal highlight-c"><span class="n">t_stat</span><span class="w"> </span><span class="n">sim_putchar_s</span><span class="w"> </span><span class="p">(</span><span class="n">int32</span><span class="w"> </span><span class="kt">char</span><span class="p">)</span></code></dt><dd><p>This routine outputs the specified ASCII character to the console.
If the console is attached to a Telnet connection,
and the connection is lost,
the routine returns <code class="docutils literal notranslate"><span class="pre">SCPE_LOST</span></code>;
if the connection is backlogged,
the routine returns <code class="docutils literal notranslate"><span class="pre">SCPE_STALL</span></code> and the output should retried at a later time.</p>
</dd>
</dl>
</section>
<section id="simulators-for-computers-without-a-console-port">
<h5><span class="sectnum">1.3.2.5.3. </span>Simulators for computers without a console port<a class="headerlink" href="#simulators-for-computers-without-a-console-port" title="Permalink to this heading">¶</a></h5>
<p>If a computer being simulated doesn’t have a console port,
SCP will call <a class="reference internal" href="#sim-poll-kbd"><code class="docutils literal notranslate"><span class="pre">sim_poll_kbd</span></code></a> periodically to detect when a user types
<code class="docutils literal notranslate"><span class="pre">^E</span></code> (Control-E)
in the session running the simulator and they will be returned to the <code class="docutils literal notranslate"><span class="pre">sim&gt;</span></code> prompt.</p>
</section>
</section>
</section>
</section>
<section id="data-structures">
<span id="section-4"></span><h2><span class="sectnum">1.4. </span>Data structures<a class="headerlink" href="#data-structures" title="Permalink to this heading">¶</a></h2>
<p>The devices, units, and registers that make up a VM are formally described through a set of data structures which interface the VM to the control portions of SCP.
The devices themselves are pointed to by the device list array <code class="code highlight c docutils literal highlight-c"><span class="n">sim_devices</span><span class="p">[]</span></code>.
Within a device, both units and registers are allocated contiguously as arrays of structures.
In addition, many devices allow the user to set or clear options via a modifications table.</p>
<p>Note that a device must always have at least one unit,
even if that unit is not needed for simulation purposes.
A device that does not need registers need not provide a register table,
instead the registers field is set to <code class="code highlight c docutils literal highlight-c"><span class="nb">NULL</span></code>.</p>
<p>Device registers serve two purposes:</p>
<ol class="arabic simple">
<li><p>Provide a means of letting the simulator user (more often the developer) have visibility to examine and potentially change arbitrary state variables within the simulator from the <code class="docutils literal notranslate"><span class="pre">sim&gt;</span></code> prompt rather than having to use a debugger.</p></li>
<li><p>Provide <em>all</em> of the information in the internal state of a simulated device so that a <code class="docutils literal notranslate"><span class="pre">SAVE</span></code> command can capture that state and a subsequent <code class="docutils literal notranslate"><span class="pre">RESTORE</span></code> (after exiting and restarting the same simulator) will be able to proceed without any information being missing.</p></li>
</ol>
<p>A device unit serves two fundamental purposes in a simulator:</p>
<ol class="arabic simple">
<li><p>It acts as an entity which can generate events which are handled in the simulated instruction stream (via one of the <a class="reference internal" href="#sim-activate"><code class="docutils literal notranslate"><span class="pre">sim_activate</span></code></a> APIs)</p></li>
<li><p>It provides a place which holds an open file pointer for simulated devices which have content bound to file contents (via <code class="docutils literal notranslate"><span class="pre">ATTACH</span></code> commands).</p></li>
</ol>
<p>For example:
A <a class="reference internal" href="#unit"><code class="docutils literal notranslate"><span class="pre">UNIT</span></code></a> can be mapped to real units in a simulated device
(i.e., disk drives),
or it might serve merely to perform timing related activities,
or both of these might be present.
The <code class="docutils literal notranslate"><span class="pre">pdp11_rq</span></code> simulation has a combination of both of these.
There are 4 units which map one to one directly to simulated disk drives,
and there are 2 additional units.
One is used to time various things and one is used to provide instruction delays while walking through the MSCP initialization and command processing sequence.</p>
<section id="device-structure">
<span id="device"></span><h3><span class="sectnum">1.4.1. </span><code class="docutils literal notranslate"><span class="pre">DEVICE</span></code> structure<a class="headerlink" href="#device-structure" title="Permalink to this heading">¶</a></h3>
<p>Devices are defined by the <code class="docutils literal notranslate"><span class="pre">DEVICE</span></code> structure (<code class="code highlight c docutils literal highlight-c"><span class="k">typedef</span><span class="w"> </span><span class="n">DEVICE</span></code>):</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">DEVICE</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w">      </span><span class="o">*</span><span class="n">name</span><span class="p">;</span><span class="w">            </span><span class="cm">/* Name */</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">UNIT</span><span class="w">     </span><span class="o">*</span><span class="n">units</span><span class="p">;</span><span class="w">           </span><span class="cm">/* Units */</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">REG</span><span class="w">      </span><span class="o">*</span><span class="n">registers</span><span class="p">;</span><span class="w">       </span><span class="cm">/* Registers */</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">MTAB</span><span class="w">     </span><span class="o">*</span><span class="n">modifiers</span><span class="p">;</span><span class="w">       </span><span class="cm">/* Modifiers */</span>
<span class="w">    </span><span class="n">int32</span><span class="w">            </span><span class="n">numunits</span><span class="p">;</span><span class="w">        </span><span class="cm">/* Number of units */</span>
<span class="w">    </span><span class="n">uint32</span><span class="w">           </span><span class="n">aradix</span><span class="p">;</span><span class="w">          </span><span class="cm">/* Address radix */</span>
<span class="w">    </span><span class="n">uint32</span><span class="w">           </span><span class="n">awidth</span><span class="p">;</span><span class="w">          </span><span class="cm">/* Address width */</span>
<span class="w">    </span><span class="n">uint32</span><span class="w">           </span><span class="n">aincr</span><span class="p">;</span><span class="w">           </span><span class="cm">/* Addr increment */</span>
<span class="w">    </span><span class="n">uint32</span><span class="w">           </span><span class="n">dradix</span><span class="p">;</span><span class="w">          </span><span class="cm">/* Data radix */</span>
<span class="w">    </span><span class="n">uint32</span><span class="w">           </span><span class="n">dwidth</span><span class="p">;</span><span class="w">          </span><span class="cm">/* Data width */</span>
<span class="w">    </span><span class="n">t_stat</span><span class="w">         </span><span class="p">(</span><span class="o">*</span><span class="n">examine</span><span class="p">)();</span><span class="w">      </span><span class="cm">/* Examine routine */</span>
<span class="w">    </span><span class="n">t_stat</span><span class="w">         </span><span class="p">(</span><span class="o">*</span><span class="n">deposit</span><span class="p">)();</span><span class="w">      </span><span class="cm">/* Deposit routine */</span>
<span class="w">    </span><span class="n">t_stat</span><span class="w">         </span><span class="p">(</span><span class="o">*</span><span class="n">reset</span><span class="p">)();</span><span class="w">        </span><span class="cm">/* Reset routine */</span>
<span class="w">    </span><span class="n">t_stat</span><span class="w">         </span><span class="p">(</span><span class="o">*</span><span class="n">boot</span><span class="p">)();</span><span class="w">         </span><span class="cm">/* Boot routine */</span>
<span class="w">    </span><span class="n">t_stat</span><span class="w">         </span><span class="p">(</span><span class="o">*</span><span class="n">attach</span><span class="p">)();</span><span class="w">       </span><span class="cm">/* Attach routine */</span>
<span class="w">    </span><span class="n">t_stat</span><span class="w">         </span><span class="p">(</span><span class="o">*</span><span class="n">detach</span><span class="p">)();</span><span class="w">       </span><span class="cm">/* Detach routine */</span>
<span class="w">    </span><span class="kt">void</span><span class="w">            </span><span class="o">*</span><span class="n">ctxt</span><span class="p">;</span><span class="w">            </span><span class="cm">/* Context */</span>
<span class="w">    </span><span class="n">uint32</span><span class="w">           </span><span class="n">flags</span><span class="p">;</span><span class="w">           </span><span class="cm">/* Flags */</span>
<span class="w">    </span><span class="n">uint32</span><span class="w">           </span><span class="n">dctrl</span><span class="p">;</span><span class="w">           </span><span class="cm">/* Debug control flags */</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">DEBTAB</span><span class="w">   </span><span class="o">*</span><span class="n">debflags</span><span class="p">;</span><span class="w">        </span><span class="cm">/* Debug flag names */</span>
<span class="w">    </span><span class="n">t_stat</span><span class="w">         </span><span class="p">(</span><span class="o">*</span><span class="n">msize</span><span class="p">)();</span><span class="w">        </span><span class="cm">/* Memory size change */</span>
<span class="w">    </span><span class="kt">char</span><span class="w">            </span><span class="o">*</span><span class="n">lname</span><span class="p">;</span><span class="w">           </span><span class="cm">/* Logical name */</span>
<span class="w">    </span><span class="n">t_stat</span><span class="w">         </span><span class="p">(</span><span class="o">*</span><span class="n">help</span><span class="p">)();</span><span class="w">         </span><span class="cm">/* Help routine */</span>
<span class="w">    </span><span class="n">t_stat</span><span class="w">         </span><span class="p">(</span><span class="o">*</span><span class="n">attach_help</span><span class="p">)();</span><span class="w">  </span><span class="cm">/* Attach help routine */</span>
<span class="w">    </span><span class="kt">void</span><span class="w">            </span><span class="o">*</span><span class="n">help_ctxt</span><span class="p">;</span><span class="w">       </span><span class="cm">/* Help context */</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w">    </span><span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">description</span><span class="p">)();</span><span class="w">  </span><span class="cm">/* Device description */</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The fields are the following:</p>
<dl class="simple" id="device-name">
<dt><code class="docutils literal notranslate"><span class="pre">name</span></code></dt><dd><p>Device name, string of all capital alphanumeric characters.</p>
</dd>
</dl>
<dl class="simple" id="device-units">
<dt><code class="docutils literal notranslate"><span class="pre">units</span></code></dt><dd><p>Pointer to array of <a class="reference internal" href="#unit"><code class="docutils literal notranslate"><span class="pre">UNIT</span></code></a> structures, or <code class="code highlight c docutils literal highlight-c"><span class="nb">NULL</span></code> if none.</p>
</dd>
</dl>
<dl class="simple" id="device-registers">
<dt><code class="docutils literal notranslate"><span class="pre">registers</span></code></dt><dd><p>Pointer to array of <a class="reference internal" href="#reg"><code class="docutils literal notranslate"><span class="pre">REG</span></code></a> structures, or <code class="code highlight c docutils literal highlight-c"><span class="nb">NULL</span></code> if none.</p>
</dd>
</dl>
<dl class="simple" id="device-modifiers">
<dt><code class="docutils literal notranslate"><span class="pre">modifiers</span></code></dt><dd><p>Pointer to array of <a class="reference internal" href="#mtab"><code class="docutils literal notranslate"><span class="pre">MTAB</span></code></a> structures, or <code class="code highlight c docutils literal highlight-c"><span class="nb">NULL</span></code> if none.</p>
</dd>
</dl>
<dl class="simple" id="device-numunits">
<dt><code class="docutils literal notranslate"><span class="pre">numunits</span></code></dt><dd><p>Number of units in this device.</p>
</dd>
</dl>
<dl class="simple" id="device-aradix">
<dt><code class="docutils literal notranslate"><span class="pre">aradix</span></code></dt><dd><p>Radix for input and display of device addresses, 2 to 16 inclusive.</p>
</dd>
</dl>
<dl class="simple" id="device-awidth">
<dt><code class="docutils literal notranslate"><span class="pre">awidth</span></code></dt><dd><p>Width in bits of a device address, 1 to 64 inclusive.
See also: <a class="reference internal" href="#section-1-4-1-1">section 1.4.1.1</a>.</p>
</dd>
</dl>
<dl class="simple" id="device-aincr">
<dt><code class="docutils literal notranslate"><span class="pre">aincr</span></code></dt><dd><p>Increment between device addresses, normally 1;
however, byte-addressed devices with 16-bit words specify 2,
with 32-bit words 4.
See also: <a class="reference internal" href="#section-1-4-1-1">section 1.4.1.1</a>.</p>
</dd>
</dl>
<dl class="simple" id="device-dradix">
<dt><code class="docutils literal notranslate"><span class="pre">dradix</span></code></dt><dd><p>Radix for input and display of device data, 2 to 16 inclusive.</p>
</dd>
</dl>
<dl class="simple" id="device-dwidth">
<dt><code class="docutils literal notranslate"><span class="pre">dwidth</span></code></dt><dd><p>Width in bits of device data, 1 to 64 inclusive.</p>
</dd>
</dl>
<dl class="simple" id="device-examine">
<dt><code class="docutils literal notranslate"><span class="pre">examine</span></code></dt><dd><p>Address of special device data read routine, or <code class="code highlight c docutils literal highlight-c"><span class="nb">NULL</span></code> if none is required.</p>
</dd>
</dl>
<dl class="simple" id="device-deposit">
<dt><code class="docutils literal notranslate"><span class="pre">deposit</span></code></dt><dd><p>Address of special device data write routine, or <code class="code highlight c docutils literal highlight-c"><span class="nb">NULL</span></code> if none is required.</p>
</dd>
</dl>
<dl class="simple" id="device-reset">
<dt><code class="docutils literal notranslate"><span class="pre">reset</span></code></dt><dd><p>Address of device reset routine, or <code class="code highlight c docutils literal highlight-c"><span class="nb">NULL</span></code> if none is required.</p>
</dd>
</dl>
<dl class="simple" id="device-boot">
<dt><code class="docutils literal notranslate"><span class="pre">boot</span></code></dt><dd><p>Address of device bootstrap routine, or <code class="code highlight c docutils literal highlight-c"><span class="nb">NULL</span></code> if none is required.</p>
</dd>
</dl>
<dl class="simple" id="device-attach">
<dt><code class="docutils literal notranslate"><span class="pre">attach</span></code></dt><dd><p>Address of special device attach routine, or <code class="code highlight c docutils literal highlight-c"><span class="nb">NULL</span></code> if none is required.</p>
</dd>
</dl>
<dl class="simple" id="device-detach">
<dt><code class="docutils literal notranslate"><span class="pre">detach</span></code></dt><dd><p>Address of special device detach routine, or <code class="code highlight c docutils literal highlight-c"><span class="nb">NULL</span></code> if none is required.</p>
</dd>
</dl>
<dl class="simple" id="device-ctxt">
<dt><code class="docutils literal notranslate"><span class="pre">ctxt</span></code></dt><dd><p>Address of VM-specific device context table, or <code class="code highlight c docutils literal highlight-c"><span class="nb">NULL</span></code> if none is required.
See also: <a class="reference internal" href="#section-1-4-1-3">section 1.4.1.3</a>.</p>
</dd>
</dl>
<dl class="simple" id="device-flags">
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>Device flags. See <a class="reference internal" href="#section-1-4-1-2">section 1.4.1.2</a>.</p>
</dd>
</dl>
<dl class="simple" id="device-dctrl">
<dt><code class="docutils literal notranslate"><span class="pre">dctrl</span></code></dt><dd><p>Debug control flags.</p>
</dd>
</dl>
<dl class="simple" id="device-debflags">
<dt><code class="docutils literal notranslate"><span class="pre">debflags</span></code></dt><dd><p>Pointer to array of <a class="reference internal" href="#debtab"><code class="docutils literal notranslate"><span class="pre">DEBTAB</span></code></a> structures, or <code class="code highlight c docutils literal highlight-c"><span class="nb">NULL</span></code> if none.</p>
</dd>
</dl>
<dl class="simple" id="device-msize">
<dt><code class="docutils literal notranslate"><span class="pre">msize</span></code></dt><dd><p>Address of memory size change routine, or <code class="code highlight c docutils literal highlight-c"><span class="nb">NULL</span></code> if none is required.</p>
</dd>
</dl>
<dl class="simple" id="device-lname">
<dt><code class="docutils literal notranslate"><span class="pre">lname</span></code></dt><dd><p>Pointer to logical name string, or <code class="code highlight c docutils literal highlight-c"><span class="nb">NULL</span></code> if not assigned.</p>
</dd>
</dl>
<dl class="simple" id="device-help">
<dt><code class="docutils literal notranslate"><span class="pre">help</span></code></dt><dd><p>Address of help routine, or <code class="code highlight c docutils literal highlight-c"><span class="nb">NULL</span></code> if none is required.</p>
</dd>
</dl>
<dl class="simple" id="device-attach-help">
<dt><code class="docutils literal notranslate"><span class="pre">attach_help</span></code></dt><dd><p>Address of attach help routine, or <code class="code highlight c docutils literal highlight-c"><span class="nb">NULL</span></code> if none is required.</p>
</dd>
</dl>
<dl class="simple" id="device-help-ctxt">
<dt><code class="docutils literal notranslate"><span class="pre">help_ctxt</span></code></dt><dd><p>Address of device-specific context which might be useful while displaying help for the current device,
or <code class="code highlight c docutils literal highlight-c"><span class="nb">NULL</span></code> if none is required.</p>
</dd>
</dl>
<dl class="simple" id="device-description">
<dt><code class="docutils literal notranslate"><span class="pre">description</span></code></dt><dd><p>Address of device description function, or <code class="code highlight c docutils literal highlight-c"><span class="nb">NULL</span></code> if not implemented.
The function returns a string which displays the description of the device being simulated.
This is part of the output of the <code class="docutils literal notranslate"><span class="pre">SHOW</span> <span class="pre">FEATURES</span></code> command.
It also is available (when provided) for dynamic insertion in the information produced by the <code class="docutils literal notranslate"><span class="pre">DEVICE</span></code> help routine.</p>
</dd>
</dl>
<section id="awidth-and-aincr">
<span id="section-1-4-1-1"></span><h4><span class="sectnum">1.4.1.1. </span><code class="docutils literal notranslate"><span class="pre">awidth</span></code> and <code class="docutils literal notranslate"><span class="pre">aincr</span></code><a class="headerlink" href="#awidth-and-aincr" title="Permalink to this heading">¶</a></h4>
<p>The <a class="reference internal" href="#device-awidth"><code class="docutils literal notranslate"><span class="pre">awidth</span></code></a> field specifies the width of the VM’s fundamental computer “word”.
For example, on the PDP-11, <a class="reference internal" href="#device-awidth"><code class="docutils literal notranslate"><span class="pre">awidth</span></code></a> is 16b, even though memory is byte-addressable.
The <a class="reference internal" href="#device-aincr"><code class="docutils literal notranslate"><span class="pre">aincr</span></code></a> field specifies how many addressing units comprise the fundamental “word”.
For example, on the PDP-11, <a class="reference internal" href="#device-aincr"><code class="docutils literal notranslate"><span class="pre">aincr</span></code></a> is 2 (2 bytes per word).</p>
<p>If <a class="reference internal" href="#device-aincr"><code class="docutils literal notranslate"><span class="pre">aincr</span></code></a> is greater than 1,
SCP assumes that data is naturally aligned on addresses that are multiples of <a class="reference internal" href="#device-aincr"><code class="docutils literal notranslate"><span class="pre">aincr</span></code></a>.
VMs that support arbitrary byte alignment of data (like the VAX) can follow one of two strategies:</p>
<ul class="simple">
<li><p>Set <code class="docutils literal notranslate"><span class="pre">awidth</span> <span class="pre">=</span> <span class="pre">8</span></code> and <code class="docutils literal notranslate"><span class="pre">aincr</span> <span class="pre">=</span> <span class="pre">1</span></code> and support only byte access in the examine/deposit routines.</p></li>
<li><p>Set <code class="docutils literal notranslate"><span class="pre">awidth</span></code> and <code class="docutils literal notranslate"><span class="pre">aincr</span></code> to the fundamental sizes and support unaligned data access in the examine/deposit routines.</p></li>
</ul>
<p>In a byte-addressable VM, <code class="docutils literal notranslate"><span class="pre">SAVE</span></code> and <code class="docutils literal notranslate"><span class="pre">RESTORE</span></code> will require <span class="math notranslate nohighlight">\((\mathtt{memory\_size\_bytes} / \mathtt{aincr})\)</span> iterations to save or restore memory.
Thus, it is significantly more efficient to use word-wide rather than byte-wide memory;
but requirements for unaligned access can add significantly to the complexity of the examine and deposit routines.</p>
</section>
<section id="section-1-4-1-2">
<span id="device-flag"></span><span id="id2"></span><h4><span class="sectnum">1.4.1.2. </span>Device flags<a class="headerlink" href="#section-1-4-1-2" title="Permalink to this heading">¶</a></h4>
<p>The <a class="reference internal" href="#device-flags"><code class="docutils literal notranslate"><span class="pre">flags</span></code></a> field contains indicators of current device status.
SIMH defines several flags:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Flag name</p></th>
<th class="head"><p>Meaning if set</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">DEV_DISABLE</span></code></p></td>
<td><p>Device can be set enabled or disabled</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">DEV_DIS</span></code></p></td>
<td><p>Device is currently disabled</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">DEV_DYNM</span></code></p></td>
<td><p>Device requires call on msize routine to change memory size</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">DEV_DEBUG</span></code></p></td>
<td><p>Device supports <code class="docutils literal notranslate"><span class="pre">SET</span> <span class="pre">DEBUG</span></code> command</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">DEV_SECTORS</span></code></p></td>
<td><p>Device capacity is in units of 512 byte sectors</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">DEV_DONTAUTO</span></code></p></td>
<td><p>Do not automatically detach already attached units</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">DEV_FLATHELP</span></code></p></td>
<td><p>Use traditional (unstructured) help</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">DEV_NOSAVE</span></code></p></td>
<td><p>Don’t save device state</p></td>
</tr>
</tbody>
</table>
<p>The flags field also contains an optional device type specification.
One of these may be specified when initializing the <a class="reference internal" href="#device-flags"><code class="docutils literal notranslate"><span class="pre">flags</span></code></a> field:</p>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">DEV_DISK</span></code></p></td>
<td><p>Device uses <code class="docutils literal notranslate"><span class="pre">sim_disk</span></code> library attach</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">DEV_TAPE</span></code></p></td>
<td><p>Device uses <code class="docutils literal notranslate"><span class="pre">sim_tape</span></code> library attach</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">DEV_MUX</span></code></p></td>
<td><p>Device uses <code class="docutils literal notranslate"><span class="pre">sim_tmxr</span></code> library attach</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">DEV_ETHER</span></code></p></td>
<td><p>Device uses <code class="docutils literal notranslate"><span class="pre">sim_ether</span></code> library attach</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">DEV_DISPLAY</span></code></p></td>
<td><p>Device uses <code class="docutils literal notranslate"><span class="pre">sim_video</span></code> library attach</p></td>
</tr>
</tbody>
</table>
<p>Starting at bit position <code class="docutils literal notranslate"><span class="pre">DEV_V_UF</span></code> up to but not including <code class="docutils literal notranslate"><span class="pre">DEV_V_RSV</span></code>,
the remaining flags are device-specific.
Device flags are automatically saved and restored;
the device need not supply a register for these bits.</p>
</section>
<section id="context">
<span id="section-1-4-1-3"></span><h4><span class="sectnum">1.4.1.3. </span>Context<a class="headerlink" href="#context" title="Permalink to this heading">¶</a></h4>
<p>The <a class="reference internal" href="#device-ctxt"><code class="docutils literal notranslate"><span class="pre">ctxt</span></code></a> field contains a pointer to a VM-specific device context table, if required.
SIMH never accesses this field.
The context field allows VM-specific code to walk VM-specific data structures from the <code class="docutils literal notranslate"><span class="pre">sim_devices</span></code> root pointer.</p>
</section>
<section id="examine-and-deposit-routines">
<h4><span class="sectnum">1.4.1.4. </span>Examine and deposit routines<a class="headerlink" href="#examine-and-deposit-routines" title="Permalink to this heading">¶</a></h4>
<p>For devices which maintain their data sets as host files,
SCP implements the examine and deposit data functions.
However, devices which maintain their data sets as private state (for example, the CPU) must supply special examine and deposit routines.
The calling sequences are:</p>
<dl class="simple" id="examine-routine">
<dt><code class="code highlight c docutils literal highlight-c"><span class="n">t_stat</span><span class="w"> </span><span class="n">examine_routine</span><span class="w"> </span><span class="p">(</span><span class="n">t_val</span><span class="w"> </span><span class="o">*</span><span class="n">eval_array</span><span class="p">,</span><span class="w"> </span><span class="n">t_addr</span><span class="w"> </span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="n">UNIT</span><span class="w"> </span><span class="o">*</span><span class="n">uptr</span><span class="p">,</span><span class="w"> </span><span class="n">int32</span><span class="w"> </span><span class="n">switches</span><span class="p">)</span></code></dt><dd><p>Copy <a class="reference internal" href="#sim-emax"><code class="docutils literal notranslate"><span class="pre">sim_emax</span></code></a> consecutive addresses for unit <code class="docutils literal notranslate"><span class="pre">uptr</span></code>, starting at <code class="docutils literal notranslate"><span class="pre">addr</span></code>, into <code class="docutils literal notranslate"><span class="pre">eval_array</span></code>.
The switch variable has <code class="code highlight c docutils literal highlight-c"><span class="n">bit</span><span class="o">&lt;</span><span class="n">n</span><span class="o">&gt;</span></code> set if the <code class="docutils literal notranslate"><span class="pre">n</span></code>th letter was specified as a switch to the examine command.</p>
</dd>
</dl>
<dl class="simple" id="deposit-routine">
<dt><code class="code highlight c docutils literal highlight-c"><span class="n">t_stat</span><span class="w"> </span><span class="n">deposit_routine</span><span class="w"> </span><span class="p">(</span><span class="n">t_val</span><span class="w"> </span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="n">t_addr</span><span class="w"> </span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="n">UNIT</span><span class="w"> </span><span class="o">*</span><span class="n">uptr</span><span class="p">,</span><span class="w"> </span><span class="n">int32</span><span class="w"> </span><span class="n">switches</span><span class="p">)</span></code></dt><dd><p>Store the specified <code class="docutils literal notranslate"><span class="pre">value</span></code> in the specified <code class="docutils literal notranslate"><span class="pre">addr</span></code> for unit <code class="docutils literal notranslate"><span class="pre">uptr</span></code>.
The switch variable is the same as for the examine routine.</p>
</dd>
</dl>
</section>
<section id="reset-routine">
<h4><span class="sectnum">1.4.1.5. </span>Reset routine<a class="headerlink" href="#reset-routine" title="Permalink to this heading">¶</a></h4>
<p>The reset routine implements the device reset function for the <code class="docutils literal notranslate"><span class="pre">RESET</span></code>, <code class="docutils literal notranslate"><span class="pre">RUN</span></code>, and <code class="docutils literal notranslate"><span class="pre">BOOT</span></code> commands.
Its calling sequence is:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">t_stat</span><span class="w"> </span><span class="n">reset_routine</span><span class="w"> </span><span class="p">(</span><span class="n">DEVICE</span><span class="w"> </span><span class="o">*</span><span class="n">dptr</span><span class="p">)</span><span class="w">  </span><span class="cm">/* Reset the specified device to its initial state */</span>
</pre></div>
</div>
<p>A typical reset routine clears all device flags and cancels any outstanding timing operations.
Switch <code class="docutils literal notranslate"><span class="pre">-p</span></code> (available via global variable <code class="docutils literal notranslate"><span class="pre">sim_switches</span></code>) specifies a reset to power-up state.</p>
<p>The reset routine is a reasonable place to perform one time initialization activities specific to the device keeping a static variable indicating that the one time initialization has been performed.</p>
</section>
<section id="boot-routine">
<h4><span class="sectnum">1.4.1.6. </span>Boot routine<a class="headerlink" href="#boot-routine" title="Permalink to this heading">¶</a></h4>
<p>If a device responds to a <code class="docutils literal notranslate"><span class="pre">BOOT</span></code> command,
the boot routine implements the bootstrapping function.
Its calling sequence is:</p>
<dl class="simple" id="id3">
<dt><code class="code highlight c docutils literal highlight-c"><span class="n">t_stat</span><span class="w"> </span><span class="n">boot_routine</span><span class="w"> </span><span class="p">(</span><span class="n">int32</span><span class="w"> </span><span class="n">unit_num</span><span class="p">,</span><span class="w"> </span><span class="n">DEVICE</span><span class="w"> </span><span class="o">*</span><span class="n">dptr</span><span class="p">)</span></code></dt><dd><p>Bootstrap unit <code class="docutils literal notranslate"><span class="pre">unit_num</span></code> on the device <code class="docutils literal notranslate"><span class="pre">dptr</span></code>.</p>
</dd>
</dl>
<p>A typical bootstrap routine copies a bootstrap loader into main memory and sets the PC to the starting address of the loader.
SCP then starts simulation at the specified address.</p>
</section>
<section id="attach-and-detach-routines">
<h4><span class="sectnum">1.4.1.7. </span>Attach and detach routines<a class="headerlink" href="#attach-and-detach-routines" title="Permalink to this heading">¶</a></h4>
<p>Normally, the <code class="docutils literal notranslate"><span class="pre">ATTACH</span></code> and <code class="docutils literal notranslate"><span class="pre">DETACH</span></code> commands are handled by SCP.
However, devices which need to pre- or post-process these commands must supply special attach and detach routines.
The calling sequences are:</p>
<dl class="simple" id="attach-routine">
<dt><code class="code highlight c docutils literal highlight-c"><span class="n">t_stat</span><span class="w"> </span><span class="n">attach_routine</span><span class="w"> </span><span class="p">(</span><span class="n">UNIT</span><span class="w"> </span><span class="o">*</span><span class="n">uptr</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">file</span><span class="p">)</span></code></dt><dd><p>Attach the specified <code class="docutils literal notranslate"><span class="pre">file</span></code> to the unit <code class="docutils literal notranslate"><span class="pre">uptr</span></code>.
<code class="docutils literal notranslate"><span class="pre">sim_switches</span></code> contains the command switch;
bit <code class="docutils literal notranslate"><span class="pre">SIM_SW_REST</span></code> indicates that attach is being called by the <code class="docutils literal notranslate"><span class="pre">RESTORE</span></code> command rather than the <code class="docutils literal notranslate"><span class="pre">ATTACH</span></code> command.</p>
</dd>
</dl>
<dl class="simple" id="detach-routine">
<dt><code class="code highlight c docutils literal highlight-c"><span class="n">t_stat</span><span class="w"> </span><span class="n">detach_routine</span><span class="w"> </span><span class="p">(</span><span class="n">UNIT</span><span class="w"> </span><span class="o">*</span><span class="n">uptr</span><span class="p">)</span></code></dt><dd><p>Detach unit <code class="docutils literal notranslate"><span class="pre">uptr</span></code>.</p>
</dd>
</dl>
<p>In practice, these routines usually invoke the standard SCP routines, <code class="docutils literal notranslate"><span class="pre">attach_unit</span></code> and <code class="docutils literal notranslate"><span class="pre">detach_unit</span></code>, respectively.
For example, here are special attach and detach routines to update line printer error state:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">t_stat</span><span class="w"> </span><span class="nf">lpt_attach</span><span class="w"> </span><span class="p">(</span><span class="n">UNIT</span><span class="w"> </span><span class="o">*</span><span class="n">uptr</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">cptr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">t_stat</span><span class="w"> </span><span class="n">r</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">((</span><span class="n">r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">attach_unit</span><span class="w"> </span><span class="p">(</span><span class="n">uptr</span><span class="p">,</span><span class="w"> </span><span class="n">cptr</span><span class="p">))</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">SCPE_OK</span><span class="p">)</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">r</span><span class="p">;</span>
<span class="w">    </span><span class="n">lpt_error</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">SCPE_OK</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">t_stat</span><span class="w"> </span><span class="nf">lpt_detach</span><span class="w"> </span><span class="p">(</span><span class="n">UNIT</span><span class="w"> </span><span class="o">*</span><span class="n">uptr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">lpt_error</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">detach_unit</span><span class="w"> </span><span class="p">(</span><span class="n">uptr</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>If the VM specifies an <code class="docutils literal notranslate"><span class="pre">ATTACH</span></code> or <code class="docutils literal notranslate"><span class="pre">DETACH</span></code> routine,
SCP bypasses its normal tests before calling the VM routine.
Thus, a VM <code class="docutils literal notranslate"><span class="pre">DETACH</span></code> routine cannot be assured that the unit is actually attached and must test the unit flags if required.</p>
<p>SCP executes a <code class="docutils literal notranslate"><span class="pre">DETACH</span> <span class="pre">ALL</span></code> command as part of simulator exit.
Normally, <code class="docutils literal notranslate"><span class="pre">DETACH</span> <span class="pre">ALL</span></code> only calls a unit’s detach routine if the unit’s <code class="docutils literal notranslate"><span class="pre">UNIT_ATT</span></code> flag is set.
During simulator exit, the detach routine is also called if the unit is not flagged as attachable (<code class="docutils literal notranslate"><span class="pre">UNIT_ATTABLE</span></code> is not set).
This allows the detach routine of a non-attachable unit to function as a simulator-specific cleanup routine for the unit, device, or entire simulator.</p>
</section>
<section id="memory-size-change-routine">
<h4><span class="sectnum">1.4.1.8. </span>Memory size change routine<a class="headerlink" href="#memory-size-change-routine" title="Permalink to this heading">¶</a></h4>
<p>Most units instantiate any memory array at the maximum size possible.
This allows apparent memory size to be changed by varying the <a class="reference internal" href="#unit-capac"><code class="docutils literal notranslate"><span class="pre">capac</span></code></a> field in the unit structure.
For some devices (like the VAX CPU),
instantiating the maximum memory size would impose a significant resource burden if less memory was actually needed.
These devices must provide a routine,
the memory size change routine,
for <code class="docutils literal notranslate"><span class="pre">RESTORE</span></code> to use if memory size must be changed:</p>
<dl class="simple" id="change-mem-size">
<dt><code class="code highlight c docutils literal highlight-c"><span class="n">t_stat</span><span class="w"> </span><span class="n">change_mem_size</span><span class="w"> </span><span class="p">(</span><span class="n">UNIT</span><span class="w"> </span><span class="o">*</span><span class="n">uptr</span><span class="p">,</span><span class="w"> </span><span class="n">int32</span><span class="w"> </span><span class="n">val</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">cptr</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">desc</span><span class="p">)</span></code></dt><dd><p>Change the capacity (memory size) of unit <code class="docutils literal notranslate"><span class="pre">uptr</span></code> to <code class="docutils literal notranslate"><span class="pre">val</span></code>.
The <code class="docutils literal notranslate"><span class="pre">cptr</span></code> and <code class="docutils literal notranslate"><span class="pre">desc</span></code> arguments are included for compatibility with the <code class="docutils literal notranslate"><span class="pre">SET</span></code> command’s validation routine calling sequence.</p>
</dd>
</dl>
</section>
<section id="debug-controls">
<h4><span class="sectnum">1.4.1.9. </span>Debug controls<a class="headerlink" href="#debug-controls" title="Permalink to this heading">¶</a></h4>
<p>Devices can support debug printouts.
Debug printouts are controlled by the <code class="docutils literal notranslate"><span class="pre">SET</span> <span class="pre">{NO}DEBUG</span></code> command,
which specifies where debug output should be printed;
and by the <code class="docutils literal notranslate"><span class="pre">SET</span> <span class="pre">&lt;device&gt;</span> <span class="pre">{NO}DEBUG</span></code> command,
which enables or disables individual debug printouts.</p>
<p>If a device supports debug printouts, <a class="reference internal" href="#device-flag">device flag</a> <code class="docutils literal notranslate"><span class="pre">DEV_DEBUG</span></code> must be set.
Field <a class="reference internal" href="#device-dctrl"><code class="docutils literal notranslate"><span class="pre">dctrl</span></code></a> is used for the debug control flags.
If a device supports only a single debug on/off flag,
then the <a class="reference internal" href="#device-debflags"><code class="docutils literal notranslate"><span class="pre">debflags</span></code></a> field should be set to <code class="code highlight c docutils literal highlight-c"><span class="nb">NULL</span></code>.
If a device supports multiple debug on/off flags,
then the correspondence between bit positions in <a class="reference internal" href="#device-dctrl"><code class="docutils literal notranslate"><span class="pre">dctrl</span></code></a> and debug flag names is specified by table <a class="reference internal" href="#device-debflags"><code class="docutils literal notranslate"><span class="pre">debflags</span></code></a>.
<a class="reference internal" href="#device-debflags"><code class="docutils literal notranslate"><span class="pre">debflags</span></code></a> points to a contiguous array of <code class="docutils literal notranslate"><span class="pre">DEBTAB</span></code> structures (<code class="code highlight c docutils literal highlight-c"><span class="k">typedef</span><span class="w"> </span><span class="n">DEBTAB</span></code>).
Each <code class="docutils literal notranslate"><span class="pre">DEBTAB</span></code> structure specifies a single debug flag:</p>
<div class="highlight-c notranslate" id="debtab"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">DEBTAB</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w">   </span><span class="n">name</span><span class="p">;</span><span class="w">  </span><span class="cm">/* Flag name */</span>
<span class="w">    </span><span class="n">uint32</span><span class="w">       </span><span class="n">mask</span><span class="p">;</span><span class="w">  </span><span class="cm">/* Control bit */</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w">  </span><span class="o">*</span><span class="n">desc</span><span class="p">;</span><span class="w">  </span><span class="cm">/* Description */</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The fields are the following:</p>
<dl class="simple" id="debug-name">
<dt><code class="docutils literal notranslate"><span class="pre">name</span></code></dt><dd><p>Name of the debug flag.</p>
</dd>
</dl>
<dl class="simple" id="debug-mask">
<dt><code class="docutils literal notranslate"><span class="pre">mask</span></code></dt><dd><p>Bit mask of the debug flag.</p>
</dd>
</dl>
<dl class="simple" id="debug-desc">
<dt><code class="docutils literal notranslate"><span class="pre">desc</span></code></dt><dd><p>Description of the debug flag.</p>
</dd>
</dl>
<p>The array is terminated with a <code class="code highlight c docutils literal highlight-c"><span class="nb">NULL</span></code> entry.</p>
<p>The use and definition of debug mask values is up to the particular simulator device.
Some simulator support libraries define their own debug mask values that can be used to display various details about the internal activities of the respective library.
Libraries defined debug masks a defined starting at the high bits in 32-bit the mask word,
so device specific masks should start their mask definitions with the low bits to avoid unexpected debug output if the definitions collide.</p>
<p>Simulator code can produce debug output by calling <code class="docutils literal notranslate"><span class="pre">sim_debug</span></code> which is declared
(in header file <code class="docutils literal notranslate"><span class="pre">scp.h</span></code>):</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">sim_debug</span><span class="w"> </span><span class="p">(</span><span class="n">uint32</span><span class="w"> </span><span class="n">dbits</span><span class="p">,</span><span class="w"> </span><span class="n">DEVICE</span><span class="o">*</span><span class="w"> </span><span class="n">dptr</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">fmt</span><span class="p">,</span><span class="w"> </span><span class="cm">/* … */</span><span class="p">);</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">dbits</span></code> is a flag which matches a mask in a <code class="docutils literal notranslate"><span class="pre">sim_debtab</span></code> structure,
and the the <code class="docutils literal notranslate"><span class="pre">dptr</span></code> is the <a class="reference internal" href="#device"><code class="docutils literal notranslate"><span class="pre">DEVICE</span></code></a> which has the corresponding <a class="reference internal" href="#device-dctrl"><code class="docutils literal notranslate"><span class="pre">dctrl</span></code></a> field.</p>
<p>Additionally support exists for displaying bit and bitfield values.
Bit field values are defined using the <a class="reference internal" href="#bitfield"><code class="docutils literal notranslate"><span class="pre">BITFIELD</span></code></a> structure and the <a class="reference internal" href="#bit"><code class="docutils literal notranslate"><span class="pre">BIT</span></code></a> macros to declare the bits and bitfields.</p>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p><code class="code highlight c docutils literal highlight-c"><span class="n">BIT</span><span class="p">(</span><span class="n">nm</span><span class="p">)</span></code></p></td>
<td><p>Single bit definition</p></td>
</tr>
<tr class="row-even"><td><p><code class="code highlight c docutils literal highlight-c"><span class="n">BITNC</span></code></p></td>
<td><p>Don’t care bit definition</p></td>
</tr>
<tr class="row-odd"><td><p><code class="code highlight c docutils literal highlight-c"><span class="n">BITF</span><span class="p">(</span><span class="n">nm</span><span class="p">,</span><span class="n">sz</span><span class="p">)</span></code></p></td>
<td><p>Bitfield definition</p></td>
</tr>
<tr class="row-even"><td><p><code class="code highlight c docutils literal highlight-c"><span class="n">BITNCF</span><span class="p">(</span><span class="n">sz</span><span class="p">)</span></code></p></td>
<td><p>Don’t care bitfield definition</p></td>
</tr>
<tr class="row-odd"><td><p><code class="code highlight c docutils literal highlight-c"><span class="n">BITFFMT</span><span class="p">(</span><span class="n">nm</span><span class="p">,</span><span class="n">sz</span><span class="p">,</span><span class="n">fmt</span><span class="p">)</span></code></p></td>
<td><p>Bitfield definition with output format</p></td>
</tr>
<tr class="row-even"><td><p><code class="code highlight c docutils literal highlight-c"><span class="n">BITFNAM</span><span class="p">(</span><span class="n">nm</span><span class="p">,</span><span class="n">sz</span><span class="p">,</span><span class="n">names</span><span class="p">)</span></code></p></td>
<td><p>Bitfield definition with <code class="code highlight c docutils literal highlight-c"><span class="n">value</span><span class="o">-&gt;</span><span class="n">name</span></code> map</p></td>
</tr>
<tr class="row-odd"><td><p><code class="code highlight c docutils literal highlight-c"><span class="n">ENDBITS</span></code></p></td>
<td></td>
</tr>
</tbody>
</table>
<p>For example:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">rp_fname</span><span class="p">[</span><span class="n">CS1_N_FNC</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="s">&quot;NOP&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;UNLD&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;SEEK&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;RECAL&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;DCLR&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;RLS&quot;</span><span class="p">,</span>
<span class="w">    </span><span class="s">&quot;OFFS&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;RETN&quot;</span><span class="p">,</span><span class="s">&quot;PRESET&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;PACK&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;SEARCH&quot;</span><span class="p">,</span>
<span class="w">    </span><span class="s">&quot;WRCHK&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;WRITE&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;WRHDR&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;READ&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;RDHDR&quot;</span>
<span class="p">};</span>

<span class="n">BITFIELD</span><span class="w"> </span><span class="n">xx_csr_bits</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">BIT</span><span class="p">(</span><span class="n">GO</span><span class="p">),</span><span class="w">                   </span><span class="cm">/* Go */</span>
<span class="w">    </span><span class="n">BITFNAM</span><span class="p">(</span><span class="n">FUNC</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="n">rp_fname</span><span class="p">),</span><span class="w">  </span><span class="cm">/* Function code */</span>
<span class="w">    </span><span class="n">BIT</span><span class="p">(</span><span class="n">IE</span><span class="p">),</span><span class="w">                   </span><span class="cm">/* Interrupt enable */</span>
<span class="w">    </span><span class="n">BIT</span><span class="p">(</span><span class="n">RDY</span><span class="p">),</span><span class="w">                  </span><span class="cm">/* Drive ready */</span>
<span class="w">    </span><span class="n">BIT</span><span class="p">(</span><span class="n">DVA</span><span class="p">),</span><span class="w">                  </span><span class="cm">/* Drive available */</span>
<span class="w">    </span><span class="n">BITNCF</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span><span class="w">                 </span><span class="cm">/* 12 reserved */</span>
<span class="w">    </span><span class="n">BIT</span><span class="p">(</span><span class="n">TRE</span><span class="p">),</span><span class="w">                  </span><span class="cm">/* Transfer error */</span>
<span class="w">    </span><span class="n">BIT</span><span class="p">(</span><span class="n">SC</span><span class="p">),</span><span class="w">                   </span><span class="cm">/* Special condition */</span>
<span class="w">    </span><span class="n">ENDBITS</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The fields in a register can be displayed (along with transition indicators) by calling <code class="docutils literal notranslate"><span class="pre">sim_debug_bits_hdr</span></code> or <code class="docutils literal notranslate"><span class="pre">sim_debug_bits</span></code>.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">sim_debug_bits_hdr</span><span class="w"> </span><span class="p">(</span><span class="n">uint32</span><span class="w"> </span><span class="n">dbits</span><span class="p">,</span><span class="w"> </span><span class="n">DEVICE</span><span class="o">*</span><span class="w"> </span><span class="n">dptr</span><span class="p">,</span>
<span class="w">                         </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">header</span><span class="p">,</span><span class="w"> </span><span class="n">BITFIELD</span><span class="o">*</span><span class="w"> </span><span class="n">bitdefs</span><span class="p">,</span>
<span class="w">                         </span><span class="n">uint32</span><span class="w"> </span><span class="n">before</span><span class="p">,</span><span class="w"> </span><span class="n">uint32</span><span class="w"> </span><span class="n">after</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">terminate</span><span class="p">);</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">sim_debug_bits</span><span class="w"> </span><span class="p">(</span><span class="n">uint32</span><span class="w"> </span><span class="n">dbits</span><span class="p">,</span><span class="w"> </span><span class="n">DEVICE</span><span class="o">*</span><span class="w"> </span><span class="n">dptr</span><span class="p">,</span><span class="w"> </span><span class="n">BITFIELD</span><span class="o">*</span><span class="w"> </span><span class="n">bitdefs</span><span class="p">,</span>
<span class="w">                     </span><span class="n">uint32</span><span class="w"> </span><span class="n">before</span><span class="p">,</span><span class="w"> </span><span class="n">uint32</span><span class="w"> </span><span class="n">after</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">terminate</span><span class="p">);</span>
</pre></div>
</div>
</section>
<section id="device-specific-help-support">
<h4><span class="sectnum">1.4.1.10. </span>Device-specific help support<a class="headerlink" href="#device-specific-help-support" title="Permalink to this heading">¶</a></h4>
<p>A device declaration may specify a device type or class in the <code class="docutils literal notranslate"><span class="pre">flags</span></code> field by providing one of
<code class="docutils literal notranslate"><span class="pre">DEV_DISK</span></code>,
<code class="docutils literal notranslate"><span class="pre">DEV_TAPE</span></code>,
<code class="docutils literal notranslate"><span class="pre">DEV_MUX</span></code>,
<code class="docutils literal notranslate"><span class="pre">DEV_ETHER</span></code>
or <code class="docutils literal notranslate"><span class="pre">DEV_DISPLAY</span></code> values when initializing the flags.
The device type allows the SCP <code class="docutils literal notranslate"><span class="pre">HELP</span></code> command routine to provide some default help information for devices which don’t otherwise specify a device specific help routine or an <a class="reference internal" href="#attach-help"><code class="docutils literal notranslate"><span class="pre">attach_help</span></code></a> routine.</p>
</section>
<section id="help-routine">
<h4><span class="sectnum">1.4.1.11. </span>Help routine<a class="headerlink" href="#help-routine" title="Permalink to this heading">¶</a></h4>
<p>A device declaration may provide a routine which will display help about that device when a user enters a <code class="docutils literal notranslate"><span class="pre">HELP</span> <span class="pre">dev</span></code> command.</p>
<dl class="simple" id="help">
<dt><code class="code highlight c docutils literal highlight-c"><span class="n">t_stat</span><span class="w"> </span><span class="n">help</span><span class="w"> </span><span class="p">(</span><span class="kt">FILE</span><span class="w"> </span><span class="o">*</span><span class="n">st</span><span class="p">,</span><span class="w"> </span><span class="n">DEVICE</span><span class="w"> </span><span class="o">*</span><span class="n">dptr</span><span class="p">,</span><span class="w"> </span><span class="n">UNIT</span><span class="w"> </span><span class="o">*</span><span class="n">uptr</span><span class="p">,</span><span class="w"> </span><span class="n">int32</span><span class="w"> </span><span class="n">flag</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">cptr</span><span class="p">)</span></code></dt><dd><p>Write help information about the device and/or unit usage.
The <code class="docutils literal notranslate"><span class="pre">flag</span></code> and <code class="docutils literal notranslate"><span class="pre">cptr</span></code> arguments are included for compatibility with the <code class="docutils literal notranslate"><span class="pre">HELP</span></code> command’s validation routine calling sequence.</p>
</dd>
</dl>
</section>
<section id="attach-help-routine">
<h4><span class="sectnum">1.4.1.12. </span>Attach help routine<a class="headerlink" href="#attach-help-routine" title="Permalink to this heading">¶</a></h4>
<p>A device declaration may provide a routine which will display help about the attach command for this device.</p>
<dl class="simple" id="attach-help">
<dt><code class="code highlight c docutils literal highlight-c"><span class="n">t_stat</span><span class="w"> </span><span class="n">attach_help</span><span class="w"> </span><span class="p">(</span><span class="kt">FILE</span><span class="w"> </span><span class="o">*</span><span class="n">st</span><span class="p">,</span><span class="w"> </span><span class="n">DEVICE</span><span class="w"> </span><span class="o">*</span><span class="n">dptr</span><span class="p">,</span><span class="w"> </span><span class="n">UNIT</span><span class="w"> </span><span class="o">*</span><span class="n">uptr</span><span class="p">,</span><span class="w"> </span><span class="n">int32</span><span class="w"> </span><span class="n">flag</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">cptr</span><span class="p">)</span></code></dt><dd><p>Write help information about the device and/or unit attach usage.
The <code class="docutils literal notranslate"><span class="pre">flag</span></code> and <code class="docutils literal notranslate"><span class="pre">cptr</span></code> arguments are included for compatibility with the <code class="docutils literal notranslate"><span class="pre">HELP</span></code> command’s validation routine calling sequence.</p>
</dd>
</dl>
</section>
</section>
<section id="unit-structure">
<span id="unit"></span><h3><span class="sectnum">1.4.2. </span><code class="docutils literal notranslate"><span class="pre">UNIT</span></code> structure<a class="headerlink" href="#unit-structure" title="Permalink to this heading">¶</a></h3>
<p>Units are allocated as contiguous arrays.
Each unit is defined with a <code class="docutils literal notranslate"><span class="pre">UNIT</span></code> structure (<code class="code highlight c docutils literal highlight-c"><span class="k">typedef</span><span class="w"> </span><span class="n">UNIT</span></code>):</p>
<div class="highlight-c notranslate" id="unit-filebuf"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">UNIT</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">UNIT</span><span class="w">  </span><span class="o">*</span><span class="n">next</span><span class="p">;</span><span class="w">         </span><span class="cm">/* Next active */</span>
<span class="w">    </span><span class="n">t_stat</span><span class="w">      </span><span class="p">(</span><span class="o">*</span><span class="n">action</span><span class="p">)();</span><span class="w">    </span><span class="cm">/* Action routine */</span>
<span class="w">    </span><span class="kt">char</span><span class="w">         </span><span class="o">*</span><span class="n">filename</span><span class="p">;</span><span class="w">     </span><span class="cm">/* Open filename */</span>
<span class="w">    </span><span class="kt">FILE</span><span class="w">         </span><span class="o">*</span><span class="n">fileref</span><span class="p">;</span><span class="w">      </span><span class="cm">/* File reference */</span>
<span class="w">    </span><span class="kt">void</span><span class="w">         </span><span class="o">*</span><span class="n">filebuf</span><span class="p">;</span><span class="w">      </span><span class="cm">/* Memory buffer */</span>
<span class="w">    </span><span class="n">uint32</span><span class="w">        </span><span class="n">hwmark</span><span class="p">;</span><span class="w">       </span><span class="cm">/* High water mark */</span>
<span class="w">    </span><span class="n">int32</span><span class="w">         </span><span class="n">time</span><span class="p">;</span><span class="w">         </span><span class="cm">/* Time out */</span>
<span class="w">    </span><span class="n">uint32</span><span class="w">        </span><span class="n">flags</span><span class="p">;</span><span class="w">        </span><span class="cm">/* Flags */</span>
<span class="w">    </span><span class="n">uint32</span><span class="w">        </span><span class="n">dynflags</span><span class="p">;</span><span class="w">     </span><span class="cm">/* Dynamic flags */</span>
<span class="w">    </span><span class="n">t_addr</span><span class="w">        </span><span class="n">capac</span><span class="p">;</span><span class="w">        </span><span class="cm">/* Capacity */</span>
<span class="w">    </span><span class="n">t_addr</span><span class="w">        </span><span class="n">pos</span><span class="p">;</span><span class="w">          </span><span class="cm">/* File position */</span>
<span class="w">    </span><span class="kt">void</span><span class="w">        </span><span class="p">(</span><span class="o">*</span><span class="n">io_flush</span><span class="p">)();</span><span class="w">  </span><span class="cm">/* I/O flush routine */</span>
<span class="w">    </span><span class="n">uint32</span><span class="w">        </span><span class="n">iostarttime</span><span class="p">;</span><span class="w">  </span><span class="cm">/* I/O start time */</span>
<span class="w">    </span><span class="n">int32</span><span class="w">         </span><span class="n">buf</span><span class="p">;</span><span class="w">          </span><span class="cm">/* Buffer */</span>
<span class="w">    </span><span class="n">int32</span><span class="w">         </span><span class="n">wait</span><span class="p">;</span><span class="w">         </span><span class="cm">/* Wait */</span>
<span class="w">    </span><span class="n">int32</span><span class="w">         </span><span class="n">u3</span><span class="p">;</span><span class="w">           </span><span class="cm">/* Device-specific */</span>
<span class="w">    </span><span class="n">int32</span><span class="w">         </span><span class="n">u4</span><span class="p">;</span><span class="w">           </span><span class="cm">/* Device-specific */</span>
<span class="w">    </span><span class="n">int32</span><span class="w">         </span><span class="n">u5</span><span class="p">;</span><span class="w">           </span><span class="cm">/* Device-specific */</span>
<span class="w">    </span><span class="n">int32</span><span class="w">         </span><span class="n">u6</span><span class="p">;</span><span class="w">           </span><span class="cm">/* Device-specific */</span>
<span class="w">    </span><span class="kt">void</span><span class="w">         </span><span class="o">*</span><span class="n">up7</span><span class="p">;</span><span class="w">          </span><span class="cm">/* Device-specific */</span>
<span class="w">    </span><span class="kt">void</span><span class="w">         </span><span class="o">*</span><span class="n">up8</span><span class="p">;</span><span class="w">          </span><span class="cm">/* Device-specific */</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The simulator accessible fields are the following:</p>
<dl class="simple" id="unit-next">
<dt><code class="docutils literal notranslate"><span class="pre">next</span></code></dt><dd><p>Pointer to next unit in active queue, <code class="code highlight c docutils literal highlight-c"><span class="nb">NULL</span></code> if none.</p>
</dd>
</dl>
<dl class="simple" id="unit-action">
<dt><code class="docutils literal notranslate"><span class="pre">action</span></code></dt><dd><p>Address of unit time-out service routine.</p>
</dd>
</dl>
<dl class="simple" id="unit-filename">
<dt><code class="docutils literal notranslate"><span class="pre">filename</span></code></dt><dd><p>Pointer to name of attached file, <code class="code highlight c docutils literal highlight-c"><span class="nb">NULL</span></code> if none.</p>
</dd>
</dl>
<dl class="simple" id="unit-fileref">
<dt><code class="docutils literal notranslate"><span class="pre">fileref</span></code></dt><dd><p>Pointer to FILE structure of attached file, <code class="code highlight c docutils literal highlight-c"><span class="nb">NULL</span></code> if none.</p>
</dd>
</dl>
<dl class="simple" id="unit-hwmark">
<dt><code class="docutils literal notranslate"><span class="pre">hwmark</span></code></dt><dd><p>Buffered devices only; highest modified address<span class="math notranslate nohighlight">\(\ + 1\)</span>.</p>
</dd>
</dl>
<dl class="simple" id="unit-time">
<dt><code class="docutils literal notranslate"><span class="pre">time</span></code></dt><dd><p>Increment until time-out beyond previous unit in active queue.</p>
</dd>
</dl>
<dl class="simple" id="unit-flags">
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>Unit flags.</p>
</dd>
</dl>
<dl class="simple" id="unit-dynflags">
<dt><code class="docutils literal notranslate"><span class="pre">dynflags</span></code></dt><dd><p>Dynamic flags.</p>
</dd>
</dl>
<dl class="simple" id="unit-capac">
<dt><code class="docutils literal notranslate"><span class="pre">capac</span></code></dt><dd><p>Unit capacity, 0 if variable.</p>
</dd>
</dl>
<dl class="simple" id="unit-pos">
<dt><code class="docutils literal notranslate"><span class="pre">pos</span></code></dt><dd><p>Sequential devices only; next device address to be read or written.</p>
</dd>
</dl>
<dl class="simple" id="unit-io-flush">
<dt><code class="docutils literal notranslate"><span class="pre">io_flush</span></code></dt><dd><p>I/O flush routine, <code class="code highlight c docutils literal highlight-c"><span class="nb">NULL</span></code> if none.</p>
</dd>
</dl>
<dl class="simple" id="unit-iostarttime">
<dt><code class="docutils literal notranslate"><span class="pre">iostarttime</span></code></dt><dd><p>Simulation time (from <a class="reference internal" href="#sim-grtime"><code class="docutils literal notranslate"><span class="pre">sim_grtime()</span></code></a>) for use with <code class="docutils literal notranslate"><span class="pre">sim_activate_notbefore()</span></code>.</p>
</dd>
</dl>
<dl class="simple" id="unit-buf">
<dt><code class="docutils literal notranslate"><span class="pre">buf</span></code></dt><dd><p>By convention, the unit buffer, but can be used for other purposes.</p>
</dd>
</dl>
<dl class="simple" id="unit-wait">
<dt><code class="docutils literal notranslate"><span class="pre">wait</span></code></dt><dd><p>By convention, the unit wait time, but can be used for other purposes.</p>
</dd>
</dl>
<dl class="simple" id="unit-u3">
<dt><code class="docutils literal notranslate"><span class="pre">u3</span></code></dt><dd><p>User-defined.</p>
</dd>
</dl>
<dl class="simple" id="unit-u4">
<dt><code class="docutils literal notranslate"><span class="pre">u4</span></code></dt><dd><p>User-defined.</p>
</dd>
</dl>
<dl class="simple" id="unit-u5">
<dt><code class="docutils literal notranslate"><span class="pre">u5</span></code></dt><dd><p>User-defined.</p>
</dd>
</dl>
<dl class="simple" id="unit-u6">
<dt><code class="docutils literal notranslate"><span class="pre">u6</span></code></dt><dd><p>User-defined.</p>
</dd>
</dl>
<dl class="simple" id="unit-up7">
<dt><code class="docutils literal notranslate"><span class="pre">up7</span></code></dt><dd><p>User-defined void pointer (useful for a unit-specific context).</p>
</dd>
</dl>
<dl class="simple" id="unit-up8">
<dt><code class="docutils literal notranslate"><span class="pre">up8</span></code></dt><dd><p>User-defined void pointer (useful for a unit-specific context).</p>
</dd>
</dl>
<p><code class="docutils literal notranslate"><span class="pre">buf</span></code>,
<code class="docutils literal notranslate"><span class="pre">wait</span></code>,
<code class="docutils literal notranslate"><span class="pre">u3</span></code>,
<code class="docutils literal notranslate"><span class="pre">u4</span></code>,
<code class="docutils literal notranslate"><span class="pre">u5</span></code>,
<code class="docutils literal notranslate"><span class="pre">u6</span></code>,
and parts of <code class="docutils literal notranslate"><span class="pre">flags</span></code> are all saved and restored by the <code class="docutils literal notranslate"><span class="pre">SAVE</span></code> and <code class="docutils literal notranslate"><span class="pre">RESTORE</span></code> commands and thus can be used for unit state which must be preserved.
The values of <code class="docutils literal notranslate"><span class="pre">up7</span></code>,
<code class="docutils literal notranslate"><span class="pre">up8</span></code> and any device specific internal pointer variables must be established in the device reset or attach routines to be properly behaved across <code class="docutils literal notranslate"><span class="pre">SAVE</span></code>/<code class="docutils literal notranslate"><span class="pre">RESTORE</span></code> activities</p>
<p id="udata">Macro <code class="docutils literal notranslate"><span class="pre">UDATA</span></code> is available to fill in the common fields of a <code class="docutils literal notranslate"><span class="pre">UNIT</span></code>.
It is invoked by</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">UDATA</span><span class="w"> </span><span class="p">(</span><span class="n">action_routine</span><span class="p">,</span><span class="w"> </span><span class="n">flags</span><span class="p">,</span><span class="w"> </span><span class="n">capacity</span><span class="p">)</span>
</pre></div>
</div>
<div class="compound">
<p>Fields after <code class="docutils literal notranslate"><span class="pre">buf</span></code> can be filled in manually, e.g,</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">UNIT</span><span class="w"> </span><span class="n">lpt_unit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">UDATA</span><span class="w"> </span><span class="p">(</span><span class="o">&amp;</span><span class="n">lpt_svc</span><span class="p">,</span><span class="w"> </span><span class="n">UNIT_SEQ</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">UNIT_ATTABLE</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">),</span>
<span class="w">    </span><span class="mi">500</span>
<span class="p">};</span>
</pre></div>
</div>
<p>defines the line printer as a sequential unit with a wait time of 500.</p>
</div>
<section id="id4">
<h4><span class="sectnum">1.4.2.1. </span>Unit flags<a class="headerlink" href="#id4" title="Permalink to this heading">¶</a></h4>
<p>The <a class="reference internal" href="#unit-flags"><code class="docutils literal notranslate"><span class="pre">flags</span></code></a> field contains indicators of current unit status.
SIMH defines 13 flags:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Flag name</p></th>
<th class="head"><p>Meaning if set</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">UNIT_ATTABLE</span></code></p></td>
<td><p>The unit responds to <code class="docutils literal notranslate"><span class="pre">ATTACH</span></code> and <code class="docutils literal notranslate"><span class="pre">DETACH</span></code>.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">UNIT_RO</span></code></p></td>
<td><p>The unit is currently read-only.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">UNIT_FIX</span></code></p></td>
<td><p>The unit is fixed capacity.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">UNIT_SEQ</span></code></p></td>
<td><p>The unit is sequential.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">UNIT_ATT</span></code></p></td>
<td><p>The unit is currently attached to a file.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">UNIT_BINK</span></code></p></td>
<td><p>The unit measures “K” as 1024, rather than 1000.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">UNIT_BUFABLE</span></code></p></td>
<td><p>The unit buffers its data set in memory.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">UNIT_MUSTBUF</span></code></p></td>
<td><p>The unit allocates its data buffer dynamically.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">UNIT_BUF</span></code></p></td>
<td><p>The unit is currently buffering its data set in memory.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">UNIT_ROABLE</span></code></p></td>
<td><p>The unit can be <code class="docutils literal notranslate"><span class="pre">ATTACH</span></code>ed read only.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">UNIT_DISABLE</span></code></p></td>
<td><p>The unit responds to <code class="docutils literal notranslate"><span class="pre">ENABLE</span></code> and <code class="docutils literal notranslate"><span class="pre">DISABLE</span></code>.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">UNIT_DIS</span></code></p></td>
<td><p>The unit is currently disabled.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">UNIT_IDLE</span></code></p></td>
<td><p>The unit is idle eligible.</p></td>
</tr>
</tbody>
</table>
<p>A unit is “active” when it is in the SIMH event queue.
Units are made active by a call to <a class="reference internal" href="#sim-activate"><code class="docutils literal notranslate"><span class="pre">sim_activate</span></code></a> or a similar routine.
A request to idle SIMH is not performed unless the unit at the head of the event queue
(the unit with the shortest remaining time)
has the <code class="docutils literal notranslate"><span class="pre">UNIT_IDLE</span></code> flag set.
In VMs that want to support idling,
devices that poll for data
(such as console and mux terminals)
and clocks should use a multiple of the clock period as their poll interval,
they should use clock co-scheduling to properly align their servicing with clock ticks,
and all these units should be marked with <code class="docutils literal notranslate"><span class="pre">UNIT_IDLE</span></code>.
Other devices
(like disk)
usually have shorter service times,
and would not typically be marked with <code class="docutils literal notranslate"><span class="pre">UNIT_IDLE</span></code>.</p>
<p>Units for sequential devices (<code class="docutils literal notranslate"><span class="pre">UNIT_SEQ</span></code>) must update the unit structure <a class="reference internal" href="#unit-pos"><code class="docutils literal notranslate"><span class="pre">pos</span></code></a> member to reflect the position in the attached sequential device file as data is read or written to that file.
The <a class="reference internal" href="#unit-pos"><code class="docutils literal notranslate"><span class="pre">pos</span></code></a> value is used to position the attached file whenever simulation execution starts or resumes from the <code class="docutils literal notranslate"><span class="pre">sim&gt;</span></code> prompt.</p>
<p>Starting at bit position <code class="docutils literal notranslate"><span class="pre">UNIT_V_UF</span></code> up to but not including <code class="docutils literal notranslate"><span class="pre">UNIT_V_RSV</span></code>,
the remaining flags are unit-specific.
Unit-specific flags are set and cleared with the <code class="docutils literal notranslate"><span class="pre">SET</span></code> and <code class="docutils literal notranslate"><span class="pre">CLEAR</span></code> commands,
which reference the <a class="reference internal" href="#mtab"><code class="docutils literal notranslate"><span class="pre">MTAB</span></code></a> array (see below).
Unit-specific flags and <code class="docutils literal notranslate"><span class="pre">UNIT_DIS</span></code> are automatically saved and restored;
the device need not supply a register for these bits.</p>
</section>
<section id="service-routine">
<h4><span class="sectnum">1.4.2.2. </span>Service routine<a class="headerlink" href="#service-routine" title="Permalink to this heading">¶</a></h4>
<p>This routine is called by <a class="reference internal" href="#sim-process-event"><code class="docutils literal notranslate"><span class="pre">sim_process_event</span></code></a> when a unit times out.
Its calling sequence is:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">t_stat</span><span class="w"> </span><span class="n">service_routine</span><span class="w"> </span><span class="p">(</span><span class="n">UNIT</span><span class="w"> </span><span class="o">*</span><span class="n">uptr</span><span class="p">)</span>
</pre></div>
</div>
<p>The status returned by the service routine is passed by <a class="reference internal" href="#sim-process-event"><code class="docutils literal notranslate"><span class="pre">sim_process_event</span></code></a> back to the CPU.
If the user has typed the interrupt character (<code class="docutils literal notranslate"><span class="pre">^E</span></code>),
it returns <code class="docutils literal notranslate"><span class="pre">SCPE_STOP</span></code>.</p>
</section>
</section>
<section id="reg-structure">
<span id="reg"></span><h3><span class="sectnum">1.4.3. </span><code class="docutils literal notranslate"><span class="pre">REG</span></code> structure<a class="headerlink" href="#reg-structure" title="Permalink to this heading">¶</a></h3>
<p>Registers are allocated as contiguous array, with a <code class="code highlight c docutils literal highlight-c"><span class="nb">NULL</span></code> register at the end.
Each register is defined with a <code class="docutils literal notranslate"><span class="pre">REG</span></code> structure (<code class="code highlight c docutils literal highlight-c"><span class="k">typedef</span><span class="w"> </span><span class="n">REG</span></code>):</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">REG</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w">       </span><span class="o">*</span><span class="n">name</span><span class="p">;</span><span class="w">      </span><span class="cm">/* Name */</span>
<span class="w">    </span><span class="kt">void</span><span class="w">             </span><span class="o">*</span><span class="n">loc</span><span class="p">;</span><span class="w">       </span><span class="cm">/* Location */</span>
<span class="w">    </span><span class="n">uint32</span><span class="w">            </span><span class="n">radix</span><span class="p">;</span><span class="w">     </span><span class="cm">/* Radix */</span>
<span class="w">    </span><span class="n">uint32</span><span class="w">            </span><span class="n">width</span><span class="p">;</span><span class="w">     </span><span class="cm">/* Width */</span>
<span class="w">    </span><span class="n">uint32</span><span class="w">            </span><span class="n">offset</span><span class="p">;</span><span class="w">    </span><span class="cm">/* Starting bit */</span>
<span class="w">    </span><span class="n">uint32</span><span class="w">            </span><span class="n">depth</span><span class="p">;</span><span class="w">     </span><span class="cm">/* Save depth */</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w">       </span><span class="o">*</span><span class="n">desc</span><span class="p">;</span><span class="w">      </span><span class="cm">/* Description */</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">bitfield</span><span class="w">  </span><span class="o">*</span><span class="n">fields</span><span class="p">;</span><span class="w">    </span><span class="cm">/* Bit fields */</span>
<span class="w">    </span><span class="n">uint32</span><span class="w">            </span><span class="n">flags</span><span class="p">;</span><span class="w">     </span><span class="cm">/* Flags */</span>
<span class="w">    </span><span class="n">uint32</span><span class="w">            </span><span class="n">qptr</span><span class="p">;</span><span class="w">      </span><span class="cm">/* Current queue pointer */</span>
<span class="w">    </span><span class="kt">size_t</span><span class="w">            </span><span class="n">str_size</span><span class="p">;</span><span class="w">  </span><span class="cm">/* Structure size */</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The fields are the following:</p>
<dl class="simple" id="reg-name">
<dt><code class="docutils literal notranslate"><span class="pre">name</span></code></dt><dd><p>Register name, string of all capital alphanumeric characters.</p>
</dd>
</dl>
<dl class="simple" id="reg-loc">
<dt><code class="docutils literal notranslate"><span class="pre">loc</span></code></dt><dd><p>Pointer to location of the register value.</p>
</dd>
</dl>
<dl class="simple" id="reg-radix">
<dt><code class="docutils literal notranslate"><span class="pre">radix</span></code></dt><dd><p>Radix for input and display of data, 2 to 16 inclusive.</p>
</dd>
</dl>
<dl class="simple" id="reg-width">
<dt><code class="docutils literal notranslate"><span class="pre">width</span></code></dt><dd><p>Width in bits of data, 1 to 64 inclusive.</p>
</dd>
</dl>
<dl class="simple" id="reg-offset">
<dt><code class="docutils literal notranslate"><span class="pre">offset</span></code></dt><dd><p>Bit offset (from right-end of data).</p>
</dd>
</dl>
<dl class="simple" id="reg-depth">
<dt><code class="docutils literal notranslate"><span class="pre">depth</span></code></dt><dd><p>Size of data array (normally 1).</p>
</dd>
</dl>
<dl class="simple" id="reg-desc">
<dt><code class="docutils literal notranslate"><span class="pre">desc</span></code></dt><dd><p>Register description.</p>
</dd>
</dl>
<dl class="simple" id="reg-fields">
<dt><code class="docutils literal notranslate"><span class="pre">fields</span></code></dt><dd><p>Bit fields and formatting information.</p>
</dd>
</dl>
<dl class="simple" id="reg-qptr">
<dt><code class="docutils literal notranslate"><span class="pre">qptr</span></code></dt><dd><p>For a circular queue, the entry number for the first entry</p>
</dd>
</dl>
<dl class="simple" id="reg-str-size">
<dt><code class="docutils literal notranslate"><span class="pre">str_size</span></code></dt><dd><p>Structure size.</p>
</dd>
</dl>
<dl class="simple" id="reg-flags">
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>Flags and formatting information.</p>
</dd>
</dl>
<p>The <code class="docutils literal notranslate"><span class="pre">depth</span></code> field is used with “arrayed registers”.
Arrayed registers are used to represent structures with multiple data values,
such as the locations in a transfer buffer;
or structures which are replicated in every unit, such as a drive status register.
The <code class="docutils literal notranslate"><span class="pre">qptr</span></code> field is used with “queued registers”.
Queued registers are arrays that are organized as circular queues,
such as the PC change queue.
The <code class="docutils literal notranslate"><span class="pre">desc</span></code> field (if present) is displayed by the <code class="docutils literal notranslate"><span class="pre">HELP</span> <span class="pre">dev</span> <span class="pre">REGISTER</span></code> command to enumerate the device registers and describe them.
The <code class="docutils literal notranslate"><span class="pre">fields</span></code> field (if present) is used to display details of a register’s content according to the respective field descriptions.</p>
<p>A register that is 32b or less keeps its data in a 32b scalar variable (signed or unsigned).
A register that is 33b or more keeps its data in a 64b scalar variable (signed or unsigned).
There are several exceptions to this rule:</p>
<ul class="simple">
<li><p>An arrayed register keeps its data in a C-array whose SIMH data type is as large as
(or if necessary, larger than),
the width of a register element.
For example, an array of 6b registers would keep its data in a <code class="code highlight c docutils literal highlight-c"><span class="n">uint8</span></code> (or <code class="code highlight c docutils literal highlight-c"><span class="n">int8</span></code>) array;
an array of 16b registers would keep its data in a <code class="code highlight c docutils literal highlight-c"><span class="n">uint16</span></code> (or <code class="code highlight c docutils literal highlight-c"><span class="n">int16</span></code>) array;
an array of 24b registers would keep its data in a <code class="code highlight c docutils literal highlight-c"><span class="n">uint32</span></code> (or <code class="code highlight c docutils literal highlight-c"><span class="n">int32</span></code>) array.</p></li>
<li><p>A register flagged with <code class="docutils literal notranslate"><span class="pre">REG_FIT</span></code> obeys the sizing rules of an arrayed register,
rather than a normal scalar register.
This is useful for aliasing registers into memory or into structures.</p></li>
</ul>
<p id="bindata"><span id="hrdata"></span><span id="drdata"></span><span id="ordata"></span>Macros <code class="docutils literal notranslate"><span class="pre">ORDATA</span></code>, <code class="docutils literal notranslate"><span class="pre">DRDATA</span></code>, <code class="docutils literal notranslate"><span class="pre">HRDATA</span></code> and <code class="docutils literal notranslate"><span class="pre">BINDATA</span></code> define right-justified octal, decimal, hexadecimal, and binary registers, respectively.
They are invoked by:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">xRDATA</span><span class="w"> </span><span class="p">(</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">location</span><span class="p">,</span><span class="w"> </span><span class="n">width</span><span class="p">)</span>
</pre></div>
</div>
<p id="fldata">Macro <code class="docutils literal notranslate"><span class="pre">FLDATA</span></code> defines a one-bit binary flag at an arbitrary offset in a 32-bit word.
It is invoked by:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">FLDATA</span><span class="w"> </span><span class="p">(</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">location</span><span class="p">,</span><span class="w"> </span><span class="n">bit_position</span><span class="p">)</span>
</pre></div>
</div>
<p id="grdata">Macro <code class="docutils literal notranslate"><span class="pre">GRDATA</span></code> defines a register with arbitrary location and radix.
It is invoked by:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">GRDATA</span><span class="w"> </span><span class="p">(</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">location</span><span class="p">,</span><span class="w"> </span><span class="n">radix</span><span class="p">,</span><span class="w"> </span><span class="n">width</span><span class="p">,</span><span class="w"> </span><span class="n">bit_position</span><span class="p">)</span>
</pre></div>
</div>
<p id="brdata">Macro <code class="docutils literal notranslate"><span class="pre">BRDATA</span></code> defines an arrayed register whose data is kept in a standard C array.
It is invoked by:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">BRDATA</span><span class="w"> </span><span class="p">(</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">location</span><span class="p">,</span><span class="w"> </span><span class="n">radix</span><span class="p">,</span><span class="w"> </span><span class="n">width</span><span class="p">,</span><span class="w"> </span><span class="n">depth</span><span class="p">)</span>
</pre></div>
</div>
<p id="vbrdata">Macro <code class="docutils literal notranslate"><span class="pre">VBRDATA</span></code> defines an arrayed register whose scalar data elements are accessed as if they were in a standard C array,
but the location is an arbitrary pointer to memory.
It is invoked by:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">VBRDATA</span><span class="w"> </span><span class="p">(</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">location</span><span class="p">,</span><span class="w"> </span><span class="n">radix</span><span class="p">,</span><span class="w"> </span><span class="n">width</span><span class="p">,</span><span class="w"> </span><span class="n">depth</span><span class="p">)</span>
</pre></div>
</div>
<p>For all of these macros, the <code class="docutils literal notranslate"><span class="pre">flag</span></code> field can be filled in manually, e.g.,</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">REG</span><span class="w"> </span><span class="n">lpt_reg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">{</span><span class="w"> </span><span class="n">DRDATA</span><span class="w"> </span><span class="p">(</span><span class="n">POS</span><span class="p">,</span><span class="w"> </span><span class="n">lpt_unit</span><span class="p">.</span><span class="n">pos</span><span class="p">,</span><span class="w"> </span><span class="mi">31</span><span class="p">),</span><span class="w"> </span><span class="n">PV_LEFT</span><span class="w"> </span><span class="p">},</span>
<span class="w">    </span><span class="cm">/* … */</span>
<span class="p">};</span>
</pre></div>
</div>
<p id="urdata">Macro <code class="docutils literal notranslate"><span class="pre">URDATA</span></code> defines an arrayed register whose data is part of the <a class="reference internal" href="#unit"><code class="docutils literal notranslate"><span class="pre">UNIT</span></code></a> structure.
This macro must be used with great care.
If the fields are setup wrong,
or the data is actually kept somewhere else,
storing through this register declaration can trample over memory.
The macro is invoked by:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">URDATA</span><span class="w"> </span><span class="p">(</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">location</span><span class="p">,</span><span class="w"> </span><span class="n">radix</span><span class="p">,</span><span class="w"> </span><span class="n">width</span><span class="p">,</span><span class="w"> </span><span class="n">offset</span><span class="p">,</span><span class="w"> </span><span class="n">depth</span><span class="p">,</span><span class="w"> </span><span class="n">flags</span><span class="p">)</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">location</span></code> should be an offset in the <a class="reference internal" href="#unit"><code class="docutils literal notranslate"><span class="pre">UNIT</span></code></a> structure for unit 0.
The <code class="docutils literal notranslate"><span class="pre">width</span></code> should be 32 for an <code class="code highlight c docutils literal highlight-c"><span class="n">int32</span></code> or <code class="code highlight c docutils literal highlight-c"><span class="n">uint32</span></code> field,
and <code class="docutils literal notranslate"><span class="pre">T_ADDR_W</span></code> for a <code class="code highlight c docutils literal highlight-c"><span class="n">t_addr</span></code> field.
The <code class="docutils literal notranslate"><span class="pre">flags</span></code> can be any of the normal register flags;
<code class="docutils literal notranslate"><span class="pre">REG_UNIT</span></code> will be OR’d in automatically.
For example, the following declares an arrayed register of all the <a class="reference internal" href="#unit"><code class="docutils literal notranslate"><span class="pre">UNIT</span></code></a> position fields in a device with 4 units:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="p">{</span><span class="w"> </span><span class="n">URDATA</span><span class="w"> </span><span class="p">(</span><span class="n">POS</span><span class="p">,</span><span class="w"> </span><span class="n">dev_unit</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">pos</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="n">T_ADDR_W</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">}</span>
</pre></div>
</div>
<p id="strdata">Finally, macro <code class="docutils literal notranslate"><span class="pre">STRDATA</span></code> defines an arrayed register whose data is part of an arbitrary structure array.
This macro must be used with great care.
If the fields are set up wrong,
or the data is actually kept somewhere else,
storing through this register declaration can trample over memory.
The macro is invoked by:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">STRDATA</span><span class="w"> </span><span class="p">(</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">location</span><span class="p">,</span><span class="w"> </span><span class="n">radix</span><span class="p">,</span><span class="w"> </span><span class="n">width</span><span class="p">,</span><span class="w"> </span><span class="n">offset</span><span class="p">,</span><span class="w"> </span><span class="n">depth</span><span class="p">,</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="n">flags</span><span class="p">)</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">location</span></code> should be the address in the structure for the first element (<code class="docutils literal notranslate"><span class="pre">0</span></code>) of the structure array.
The <code class="docutils literal notranslate"><span class="pre">width</span></code> should be 32 for an <code class="code highlight c docutils literal highlight-c"><span class="n">int32</span></code> or <code class="code highlight c docutils literal highlight-c"><span class="n">uint32</span></code> field,
and <code class="docutils literal notranslate"><span class="pre">T_ADDR_W</span></code> for a <code class="code highlight c docutils literal highlight-c"><span class="n">t_addr</span></code> field.
The <code class="docutils literal notranslate"><span class="pre">flags</span></code> can be any of the normal register flags;
<code class="docutils literal notranslate"><span class="pre">REG_STRUCT</span></code> will be OR’d in automatically.
For example, the following declares an arrayed register of all the <a class="reference internal" href="#unit"><code class="docutils literal notranslate"><span class="pre">UNIT</span></code></a> position fields in a device with 4 units:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="p">{</span><span class="w"> </span><span class="n">STRDATA</span><span class="w"> </span><span class="p">(</span><span class="n">POS</span><span class="p">,</span><span class="w"> </span><span class="n">dev_unit</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">pos</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="n">T_ADDR_W</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">dev_unit</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">}</span>
</pre></div>
</div>
<p>Each of the <a class="reference internal" href="#ordata"><code class="docutils literal notranslate"><span class="pre">ORDATA</span></code></a>,
<a class="reference internal" href="#drdata"><code class="docutils literal notranslate"><span class="pre">DRDATA</span></code></a>,
<a class="reference internal" href="#fldata"><code class="docutils literal notranslate"><span class="pre">FLDATA</span></code></a>,
<a class="reference internal" href="#grdata"><code class="docutils literal notranslate"><span class="pre">GRDATA</span></code></a>,
<a class="reference internal" href="#brdata"><code class="docutils literal notranslate"><span class="pre">BRDATA</span></code></a>,
<a class="reference internal" href="#vbrdata"><code class="docutils literal notranslate"><span class="pre">VBRDATA</span></code></a>,
<a class="reference internal" href="#urdata"><code class="docutils literal notranslate"><span class="pre">URDATA</span></code></a> and <a class="reference internal" href="#strdata"><code class="docutils literal notranslate"><span class="pre">STRDATA</span></code></a> macros have corresponding <code class="docutils literal notranslate"><span class="pre">D</span></code> and <code class="docutils literal notranslate"><span class="pre">DF</span></code> macros
(<code class="docutils literal notranslate"><span class="pre">ORDATAD</span></code>,
<code class="docutils literal notranslate"><span class="pre">DRDATAD</span></code>,
<code class="docutils literal notranslate"><span class="pre">FLDATAD</span></code>,
<code class="docutils literal notranslate"><span class="pre">GRDATAD</span></code>,
<code class="docutils literal notranslate"><span class="pre">BRDATAD</span></code>,
<code class="docutils literal notranslate"><span class="pre">VBRDATAD</span></code>,
<code class="docutils literal notranslate"><span class="pre">URDATAD</span></code>,
<code class="docutils literal notranslate"><span class="pre">STRDATAD</span></code>,
<code class="docutils literal notranslate"><span class="pre">ORDATADF</span></code>,
<code class="docutils literal notranslate"><span class="pre">DRDATADF</span></code>,
<code class="docutils literal notranslate"><span class="pre">FLDATADF</span></code>,
<code class="docutils literal notranslate"><span class="pre">GRDATADF</span></code>,
<code class="docutils literal notranslate"><span class="pre">BRDATADF</span></code>,
<code class="docutils literal notranslate"><span class="pre">VBRDATADF</span></code>,
<code class="docutils literal notranslate"><span class="pre">URDATADF</span></code> and <code class="docutils literal notranslate"><span class="pre">STRDATADF</span></code>)
which can be used to provide initialization values to the <a class="reference internal" href="#reg-desc"><code class="docutils literal notranslate"><span class="pre">desc</span></code></a> fields in the <a class="reference internal" href="#reg"><code class="docutils literal notranslate"><span class="pre">REG</span></code></a> structure.</p>
<p id="savedata">Macro <code class="docutils literal notranslate"><span class="pre">SAVEDATA</span></code> defines an object which will be stored and restored from a saved simulator image without any consideration for the format it contains.
<code class="docutils literal notranslate"><span class="pre">SAVEDATA</span></code> <a class="reference internal" href="#reg"><code class="docutils literal notranslate"><span class="pre">REG</span></code></a>isters cannot be examined or deposited to.
This macro must be used with great care.
The data being saved and restored may not be meaningfully correct if the save environment has a different host architecture than the restoring one.
The macro is invoked by:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">SAVEDATA</span><span class="w"> </span><span class="p">(</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">location</span><span class="p">)</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">location</span></code> can be anywhere,
but should name an object (scalar, array, structure, etc)
that will be saved and restored in its entirety.
For example, the following declares an arrayed register of all the <a class="reference internal" href="#unit"><code class="docutils literal notranslate"><span class="pre">UNIT</span></code></a> position fields in a device with 4 units:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="p">{</span><span class="w"> </span><span class="n">BLOBDATA</span><span class="w"> </span><span class="p">(</span><span class="n">SETUP</span><span class="p">,</span><span class="w"> </span><span class="n">xs_dev</span><span class="p">.</span><span class="n">setup</span><span class="p">)</span><span class="w"> </span><span class="p">}</span>
</pre></div>
</div>
<p id="regdata">A generic register population macro exists called <code class="docutils literal notranslate"><span class="pre">REGDATA</span></code>.
Simulators using this macro will be protected against future changes to the <a class="reference internal" href="#reg"><code class="docutils literal notranslate"><span class="pre">REG</span></code></a> structure.
If new fields are added to this structure a new initialization macro will be provided,
but all uses of the prior macro will continue to work correctly.</p>
<p>All <a class="reference internal" href="#reg"><code class="docutils literal notranslate"><span class="pre">REG</span></code></a> variables should be initialized with one of the register initialization macros.
Using these macros protects these declarations from any changes that may occur to the <a class="reference internal" href="#reg"><code class="docutils literal notranslate"><span class="pre">REG</span></code></a> structure in the future,
since if any changes are made to the <a class="reference internal" href="#reg"><code class="docutils literal notranslate"><span class="pre">REG</span></code></a> structure,
the macros will be changed to reflect the necessary changes.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">REGDATA</span><span class="w"> </span><span class="p">(</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">location</span><span class="p">,</span><span class="w"> </span><span class="n">radix</span><span class="p">,</span><span class="w"> </span><span class="n">width</span><span class="p">,</span><span class="w"> </span><span class="n">offset</span><span class="p">,</span><span class="w"> </span><span class="n">depth</span><span class="p">,</span><span class="w"> </span><span class="n">desc</span><span class="p">,</span><span class="w"> </span><span class="n">fields</span><span class="p">,</span><span class="w"> </span><span class="n">flags</span><span class="p">,</span><span class="w"> </span><span class="n">qptr</span><span class="p">,</span><span class="w"> </span><span class="n">size</span><span class="p">)</span>
</pre></div>
</div>
<section id="register-flags">
<h4><span class="sectnum">1.4.3.1. </span>Register flags<a class="headerlink" href="#register-flags" title="Permalink to this heading">¶</a></h4>
<p>The <a class="reference internal" href="#reg-flags"><code class="docutils literal notranslate"><span class="pre">flags</span></code></a> field contains indicators that control register examination and deposit.</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Flag name</p></th>
<th class="head"><p>Meaning if specified</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">PV_RZRO</span></code></p></td>
<td><p>Print register right-justified with leading zeroes.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">PV_RSPC</span></code></p></td>
<td><p>Print register right-justified with leading spaces.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">PV_RCOMMA</span></code></p></td>
<td><p>Print register right-justified space fill commas every 3.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">PV_LEFT</span></code></p></td>
<td><p>Print register left-justified.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">REG_RO</span></code></p></td>
<td><p>Register is read-only.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">REG_HIDDEN</span></code></p></td>
<td><p>Register is hidden (will not appear in <code class="docutils literal notranslate"><span class="pre">EXAMINE</span> <span class="pre">STATE</span></code>).</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">REG_HRO</span></code></p></td>
<td><p>Register is read-only and hidden.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">REG_NZ</span></code></p></td>
<td><p>New register values must be non-zero.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">REG_UNIT</span></code></p></td>
<td><p>Register resides in the <a class="reference internal" href="#unit"><code class="docutils literal notranslate"><span class="pre">UNIT</span></code></a> structure.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">REG_STRUCT</span></code></p></td>
<td><p>Register resides in an arbitrary structure.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">REG_CIRC</span></code></p></td>
<td><p>Register is a circular queue.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">REG_VMIO</span></code></p></td>
<td><p>Register is displayed and parsed using VM data routines.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">REG_VMAD</span></code></p></td>
<td><p>Register is displayed and parsed using VM address routines.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">REG_FIT</span></code></p></td>
<td><p>Register container uses arrayed rather than scalar size rules.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">REG_DEPOSIT</span></code></p></td>
<td><p>Register updates invoke VM register update routine.</p></td>
</tr>
</tbody>
</table>
<p>The PV flags are mutually exclusive.
<code class="docutils literal notranslate"><span class="pre">PV_RZRO</span></code> is the default if no formatting flag is specified.</p>
<p>Starting at bit position <code class="docutils literal notranslate"><span class="pre">REG_V_UF</span></code>,
the remaining flags are user-defined.
These flags are passed to the VM-defined <code class="code highlight c docutils literal highlight-c"><span class="n">fprint_sym</span></code> and <code class="code highlight c docutils literal highlight-c"><span class="n">parse_sym</span></code> routines in the upper bits of the <code class="docutils literal notranslate"><span class="pre">addr</span></code> parameter;
they are merged with the lower 16 bits containing the register radix value.</p>
<p>If a user-defined flag or the <code class="docutils literal notranslate"><span class="pre">REG_VMIO</span></code> flag is specified in a register’s flag field,
the <code class="docutils literal notranslate"><span class="pre">EXAMINE</span></code> and <code class="docutils literal notranslate"><span class="pre">DEPOSIT</span></code> commands will call <code class="code highlight c docutils literal highlight-c"><span class="n">fprint_sym</span></code> and <code class="code highlight c docutils literal highlight-c"><span class="n">parse_sym</span></code> instead of the standard print and parse routines.
The user-defined flags passed in the <code class="docutils literal notranslate"><span class="pre">addr</span></code> parameter may be used to identify the register or determine how it is to be handled.</p>
<p>If the <code class="docutils literal notranslate"><span class="pre">REG_DEPOSIT</span></code> flag is specified in a register’s <a class="reference internal" href="#reg-flags"><code class="docutils literal notranslate"><span class="pre">flags</span></code></a> field,
register deposits will call VM-defined <code class="code highlight c docutils literal highlight-c"><span class="n">reg_update</span></code> after the register contents have been changed.
The VM-defined <code class="code highlight c docutils literal highlight-c"><span class="n">reg_update</span></code> routine may reference the user-defined flags specified in the register definition to identify the register or determine any consequences related to updating that register.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">REG_UNIT</span></code> is clear,
the register data is located at the address specified by the <code class="docutils literal notranslate"><span class="pre">loc</span></code> pointer.
If <code class="docutils literal notranslate"><span class="pre">REG_UNIT</span></code> is set,
the register name is used to refer to a field in a <a class="reference internal" href="#unit"><code class="docutils literal notranslate"><span class="pre">UNIT</span></code></a> structure,
and <code class="docutils literal notranslate"><span class="pre">loc</span></code> points to that field in the <a class="reference internal" href="#unit"><code class="docutils literal notranslate"><span class="pre">UNIT</span></code></a> struct for unit 0.
The examine and deposit commands will adjust that address by the unit number times the size of the <a class="reference internal" href="#unit"><code class="docutils literal notranslate"><span class="pre">UNIT</span></code></a> struct to determine the actual data address.</p>
</section>
</section>
<section id="bitfield-structure">
<span id="bitfield"></span><h3><span class="sectnum">1.4.4. </span><code class="docutils literal notranslate"><span class="pre">BITFIELD</span></code> structure<a class="headerlink" href="#bitfield-structure" title="Permalink to this heading">¶</a></h3>
<p>Bitfields are allocated as contiguous array, with a <code class="code highlight c docutils literal highlight-c"><span class="nb">NULL</span></code> bitfield at the end.
Each bitfield is defined with a <code class="docutils literal notranslate"><span class="pre">BITFIELD</span></code> structure (<code class="code highlight c docutils literal highlight-c"><span class="k">typedef</span><span class="w"> </span><span class="n">BITFIELD</span></code>):</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">BITFIELD</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w">   </span><span class="o">*</span><span class="n">name</span><span class="p">;</span><span class="w">              </span><span class="cm">/* Field name */</span>
<span class="w">    </span><span class="n">uint32</span><span class="w">        </span><span class="n">offset</span><span class="p">;</span><span class="w">            </span><span class="cm">/* Starting bit */</span>
<span class="w">    </span><span class="n">uint32</span><span class="w">        </span><span class="n">width</span><span class="p">;</span><span class="w">             </span><span class="cm">/* Width */</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w">  </span><span class="o">**</span><span class="n">valuenames</span><span class="p">;</span><span class="w">        </span><span class="cm">/* Map of values to strings */</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w">   </span><span class="o">*</span><span class="n">format</span><span class="p">;</span><span class="w">            </span><span class="cm">/* Value format string */</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The fields are the following:</p>
<dl class="simple" id="bitfield-name">
<dt><code class="docutils literal notranslate"><span class="pre">name</span></code></dt><dd><p>Field name, string of alphanumeric characters.</p>
</dd>
</dl>
<dl class="simple" id="bitfield-offset">
<dt><code class="docutils literal notranslate"><span class="pre">offset</span></code></dt><dd><p>Starting bit (normally populated automatically).</p>
</dd>
</dl>
<dl class="simple" id="bitfield-width">
<dt><code class="docutils literal notranslate"><span class="pre">width</span></code></dt><dd><p>Width in bits of data, 1 to 32 inclusive.</p>
</dd>
</dl>
<dl class="simple" id="bitfield-valuenames">
<dt><code class="docutils literal notranslate"><span class="pre">valuenames</span></code></dt><dd><p>Pointer to a string array which maps fields to values.</p>
</dd>
</dl>
<dl class="simple" id="bitfield-format">
<dt><code class="docutils literal notranslate"><span class="pre">format</span></code></dt><dd><p>Value format string.</p>
</dd>
</dl>
<p id="bitf"><span id="bit"></span>Macros <code class="docutils literal notranslate"><span class="pre">BIT</span></code> and <code class="docutils literal notranslate"><span class="pre">BITF</span></code> define single-bit and multi-bit fields, respectively.
They are invoked by:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">BIT</span><span class="w"> </span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
<span class="n">BITF</span><span class="w"> </span><span class="p">(</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">width</span><span class="p">)</span>
</pre></div>
</div>
<p id="bitncf"><span id="bitnc"></span>Macros <code class="docutils literal notranslate"><span class="pre">BITNC</span></code> and <code class="docutils literal notranslate"><span class="pre">BITNCF</span></code> define single-bit and multi-bit “don’t care” fields, respectively.
They are invoked by:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">BITNC</span>
<span class="n">BITFNCF</span><span class="w"> </span><span class="p">(</span><span class="n">width</span><span class="p">)</span>
</pre></div>
</div>
<p id="bitffmt">Macro <code class="docutils literal notranslate"><span class="pre">BITFFMT</span></code> defines a bitfield with an output format specifier.
It is invoked by:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">BITFFMT</span><span class="w"> </span><span class="p">(</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">width</span><span class="p">,</span><span class="w"> </span><span class="n">fmt</span><span class="p">)</span>
</pre></div>
</div>
<p id="bitfnam">Macro <code class="docutils literal notranslate"><span class="pre">BITFNAM</span></code> defines a bitfield with a value to name string map.
It is invoked by:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">BITFFMT</span><span class="w"> </span><span class="p">(</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">width</span><span class="p">,</span><span class="w"> </span><span class="n">maparray</span><span class="p">)</span>
</pre></div>
</div>
<p id="startbit">Macro <code class="docutils literal notranslate"><span class="pre">STARTBIT</span></code> resets fields to the beginning of the register.
This is useful when other conditions redefine the structure of a register’s contents.
It is invoked by:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">STARTBIT</span>
</pre></div>
</div>
</section>
<section id="mtab-structure">
<span id="mtab"></span><h3><span class="sectnum">1.4.5. </span><code class="docutils literal notranslate"><span class="pre">MTAB</span></code> structure<a class="headerlink" href="#mtab-structure" title="Permalink to this heading">¶</a></h3>
<p>Device-specific <code class="docutils literal notranslate"><span class="pre">SHOW</span></code> and <code class="docutils literal notranslate"><span class="pre">SET</span></code> commands are processed using the modifications array,
which is allocated as a contiguous array,
with a <code class="code highlight c docutils literal highlight-c"><span class="nb">NULL</span></code> at the end.
Each possible modification is defined with an <code class="docutils literal notranslate"><span class="pre">MTAB</span></code> structure (<code class="code highlight c docutils literal highlight-c"><span class="k">typedef</span><span class="w"> </span><span class="n">MTAB</span></code>),
which has the following fields:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">MTAB</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">uint32</span><span class="w">       </span><span class="n">mask</span><span class="p">;</span><span class="w">      </span><span class="cm">/* Mask */</span>
<span class="w">    </span><span class="n">uint32</span><span class="w">       </span><span class="n">match</span><span class="p">;</span><span class="w">     </span><span class="cm">/* Match */</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w">  </span><span class="o">*</span><span class="n">pstring</span><span class="p">;</span><span class="w">   </span><span class="cm">/* Print string */</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w">  </span><span class="o">*</span><span class="n">mstring</span><span class="p">;</span><span class="w">   </span><span class="cm">/* Match string */</span>
<span class="w">    </span><span class="n">t_stat</span><span class="w">     </span><span class="p">(</span><span class="o">*</span><span class="n">valid</span><span class="p">)();</span><span class="w">  </span><span class="cm">/* Validation routine */</span>
<span class="w">    </span><span class="n">t_stat</span><span class="w">     </span><span class="p">(</span><span class="o">*</span><span class="n">disp</span><span class="p">)();</span><span class="w">   </span><span class="cm">/* Display routine */</span>
<span class="w">    </span><span class="kt">void</span><span class="w">        </span><span class="o">*</span><span class="n">desc</span><span class="p">;</span><span class="w">      </span><span class="cm">/* Location descriptor */</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w">  </span><span class="o">*</span><span class="n">help</span><span class="p">;</span><span class="w">      </span><span class="cm">/* Help string */</span>
<span class="p">};</span>
</pre></div>
</div>
<p id="regular-mtab"><code class="docutils literal notranslate"><span class="pre">MTAB</span></code> supports two different structure interpretations:
regular and extended.
A regular <code class="docutils literal notranslate"><span class="pre">MTAB</span></code> entry modifies flags in the <a class="reference internal" href="#unit"><code class="docutils literal notranslate"><span class="pre">UNIT</span></code></a> <a class="reference internal" href="#unit-flags"><code class="docutils literal notranslate"><span class="pre">flags</span></code></a> word;
the descriptor entry is not used.
The fields are the following:</p>
<dl class="simple" id="mtab-mask">
<dt><code class="docutils literal notranslate"><span class="pre">mask</span></code></dt><dd><p>Bit mask for testing the <a class="reference internal" href="#unit-flags"><code class="docutils literal notranslate"><span class="pre">unit.flags</span></code></a> field.</p>
</dd>
</dl>
<dl class="simple" id="mtab-match">
<dt><code class="docutils literal notranslate"><span class="pre">match</span></code></dt><dd><p>Value to be stored (<code class="docutils literal notranslate"><span class="pre">SET</span></code>) or compared (<code class="docutils literal notranslate"><span class="pre">SHOW</span></code>).</p>
</dd>
</dl>
<dl class="simple" id="mtab-pstring">
<dt><code class="docutils literal notranslate"><span class="pre">pstring</span></code></dt><dd><p>Pointer to character string printed on a match (<code class="docutils literal notranslate"><span class="pre">SHOW</span></code>), or <code class="code highlight c docutils literal highlight-c"><span class="nb">NULL</span></code>.</p>
</dd>
</dl>
<dl class="simple" id="mtab-mstring">
<dt><code class="docutils literal notranslate"><span class="pre">mstring</span></code></dt><dd><p>Pointer to character string to be matched (<code class="docutils literal notranslate"><span class="pre">SET</span></code>), or <code class="code highlight c docutils literal highlight-c"><span class="nb">NULL</span></code>.</p>
</dd>
</dl>
<dl class="simple" id="mtab-valid">
<dt><code class="docutils literal notranslate"><span class="pre">valid</span></code></dt><dd><p>Address of validation routine (<code class="docutils literal notranslate"><span class="pre">SET</span></code>), or <code class="code highlight c docutils literal highlight-c"><span class="nb">NULL</span></code>.</p>
</dd>
</dl>
<dl class="simple" id="mtab-disp">
<dt><code class="docutils literal notranslate"><span class="pre">disp</span></code></dt><dd><p>Address of display routine (<code class="docutils literal notranslate"><span class="pre">SHOW</span></code>), or <code class="code highlight c docutils literal highlight-c"><span class="nb">NULL</span></code>.</p>
</dd>
</dl>
<p>For <code class="docutils literal notranslate"><span class="pre">SET</span></code>, a regular <code class="docutils literal notranslate"><span class="pre">MTAB</span></code> entry is interpreted as follows:</p>
<ol class="arabic simple">
<li><p>Test to see if the <code class="docutils literal notranslate"><span class="pre">mstring</span></code> entry exists.</p></li>
<li><p>Test to see if the <code class="docutils literal notranslate"><span class="pre">SET</span></code> parameter matches the <code class="docutils literal notranslate"><span class="pre">mstring</span></code>.</p></li>
<li><p>Call the validation routine, if any.</p></li>
<li><p>Apply the <code class="docutils literal notranslate"><span class="pre">mask</span></code> value to the <a class="reference internal" href="#unit"><code class="docutils literal notranslate"><span class="pre">UNIT</span></code></a> <code class="docutils literal notranslate"><span class="pre">flags</span></code> word and then or in the <code class="docutils literal notranslate"><span class="pre">match</span></code> value.</p></li>
</ol>
<p>For <code class="docutils literal notranslate"><span class="pre">SHOW</span></code>, a regular <code class="docutils literal notranslate"><span class="pre">MTAB</span></code> entry is interpreted as follows:</p>
<ol class="arabic simple">
<li><p>Test to see if the <code class="docutils literal notranslate"><span class="pre">mstring</span></code> entry exists.</p></li>
<li><p>Test to see if the <a class="reference internal" href="#unit"><code class="docutils literal notranslate"><span class="pre">UNIT</span></code></a> <code class="docutils literal notranslate"><span class="pre">flags</span></code> word, masked with the <code class="docutils literal notranslate"><span class="pre">mask</span></code> value, equals the <code class="docutils literal notranslate"><span class="pre">match</span></code> value.</p></li>
<li><p>If a display routine exists, call it, otherwise</p></li>
<li><p>Print the <code class="docutils literal notranslate"><span class="pre">pstring</span></code>.</p></li>
</ol>
<p id="extended-mtab">Extended <code class="docutils literal notranslate"><span class="pre">MTAB</span></code> entries have a different interpretation:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Mask</p></th>
<th class="head"><p>Entry flags</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">match</span></code></p></td>
<td><p>Value to be stored (<code class="docutils literal notranslate"><span class="pre">SET</span></code>)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">pstring</span></code></p></td>
<td><p>Pointer to character string printed on a match (<code class="docutils literal notranslate"><span class="pre">SHOW</span></code>), or <code class="code highlight c docutils literal highlight-c"><span class="nb">NULL</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">mstring</span></code></p></td>
<td><p>Pointer to character string to be matched (<code class="docutils literal notranslate"><span class="pre">SET</span></code>), or <code class="code highlight c docutils literal highlight-c"><span class="nb">NULL</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">valid</span></code></p></td>
<td><p>Address of validation routine (<code class="docutils literal notranslate"><span class="pre">SET</span></code>), or <code class="code highlight c docutils literal highlight-c"><span class="nb">NULL</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">disp</span></code></p></td>
<td><p>Address of display routine (<code class="docutils literal notranslate"><span class="pre">SHOW</span></code>), or <code class="code highlight c docutils literal highlight-c"><span class="nb">NULL</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">desc</span></code></p></td>
<td><p>Pointer to data address (valid clear) or
a validation-specific structure (valid set)</p></td>
</tr>
</tbody>
</table>
<table class="docutils align-left" id="id10">
<caption><span class="caption-text">Entry flag definitions</span><a class="headerlink" href="#id10" title="Permalink to this table">¶</a></caption>
<tbody>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">MTAB_XTD</span></code></p></td>
<td><p>Extended entry</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">MTAB_VDV</span></code></p></td>
<td><p>Valid for devices</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">MTAB_VUN</span></code></p></td>
<td><p>Valid for units</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">MTAB_VALR</span></code></p></td>
<td><p>Requires a value</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">MTAB_VALO</span></code></p></td>
<td><p>Optionally accepts a value</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">MTAB_NMO</span></code></p></td>
<td><p>Valid only in named <code class="docutils literal notranslate"><span class="pre">SHOW</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">MTAB_NC</span></code></p></td>
<td><p>Do not convert option value to uppercase</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">MTAB_SHP</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">SHOW</span></code> parameter takes optional value</p></td>
</tr>
</tbody>
</table>
<p>For <code class="docutils literal notranslate"><span class="pre">SET</span></code>, an extended <code class="docutils literal notranslate"><span class="pre">MTAB</span></code> entry is interpreted as follows:</p>
<ol class="arabic simple">
<li><p>Test to see if the <code class="docutils literal notranslate"><span class="pre">mstring</span></code> entry exists.</p></li>
<li><p>Test to see if the <code class="docutils literal notranslate"><span class="pre">SET</span></code> parameter matches the <code class="docutils literal notranslate"><span class="pre">mstring</span></code>.</p></li>
<li><p>Test to see if the entry is valid for the type of <code class="docutils literal notranslate"><span class="pre">SET</span></code> being done (<code class="docutils literal notranslate"><span class="pre">SET</span> <span class="pre">device</span></code> or <code class="docutils literal notranslate"><span class="pre">SET</span> <span class="pre">unit</span></code>).</p></li>
<li><p>If a validation routine exists, call it and return its status.
The validation routine is responsible for storing the result.</p></li>
<li><p>If <code class="docutils literal notranslate"><span class="pre">desc</span></code> is <code class="code highlight c docutils literal highlight-c"><span class="nb">NULL</span></code>, exit.</p></li>
<li><p>Otherwise, store the <code class="docutils literal notranslate"><span class="pre">match</span></code> value in the <code class="code highlight c docutils literal highlight-c"><span class="n">int32</span></code> pointed to by <code class="docutils literal notranslate"><span class="pre">desc</span></code>.</p></li>
</ol>
<p>For <code class="docutils literal notranslate"><span class="pre">SHOW</span></code>, an extended <code class="docutils literal notranslate"><span class="pre">MTAB</span></code> entry is interpreted as follows:</p>
<ol class="arabic simple">
<li><p>Test to see if the <code class="docutils literal notranslate"><span class="pre">mstring</span></code> entry exists.</p></li>
<li><p>Test to see if the entry is valid for the type of <code class="docutils literal notranslate"><span class="pre">SHOW</span></code> being done (device or unit).</p></li>
<li><p>If a display routine exists, call it, otherwise,</p></li>
<li><p>Print the <code class="docutils literal notranslate"><span class="pre">pstring</span></code>.</p></li>
</ol>
<p><code class="docutils literal notranslate"><span class="pre">SHOW</span> <span class="pre">[dev|unit]</span> <span class="pre">&lt;modifier&gt;{=&lt;value&gt;}</span></code> is a special case.
Only two kinds of modifiers can be displayed individually:
an extended <code class="docutils literal notranslate"><span class="pre">MTAB</span></code> entry that takes a value;
and any <code class="docutils literal notranslate"><span class="pre">MTAB</span></code> entry with both a display routine and a <code class="docutils literal notranslate"><span class="pre">pstring</span></code>.
Recall that if a display routine exists,
<code class="docutils literal notranslate"><span class="pre">SHOW</span></code> does not use the <code class="docutils literal notranslate"><span class="pre">pstring</span></code> entry.
For displaying a named modifier,
<code class="docutils literal notranslate"><span class="pre">pstring</span></code> is used as the string match.
This allows implementation of complex display routines that are only invoked by name, e.g.,</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">MTAB</span><span class="w"> </span><span class="n">cpu_tab</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">{</span><span class="w"> </span><span class="n">mask</span><span class="p">,</span><span class="w"> </span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;normal&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;NORMAL&quot;</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="w"> </span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span><span class="w"> </span><span class="n">MTAB_XTD</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">MTAB_VDV</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">MTAB_NMO</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;SPECIAL&quot;</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">spec_disp</span><span class="w"> </span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>A <code class="docutils literal notranslate"><span class="pre">SHOW</span> <span class="pre">CPU</span></code> command will display only the modifier named <code class="docutils literal notranslate"><span class="pre">NORMAL</span></code>;
but <code class="docutils literal notranslate"><span class="pre">SHOW</span> <span class="pre">CPU</span> <span class="pre">SPECIAL</span></code> will invoke the special display routine.</p>
<section id="validation-routine">
<h4><span class="sectnum">1.4.5.1. </span>Validation routine<a class="headerlink" href="#validation-routine" title="Permalink to this heading">¶</a></h4>
<p>The validation routine can be used to validate input during <code class="docutils literal notranslate"><span class="pre">SET</span></code> processing.
It can make other state changes required by the modification or initiate additional dialogs needed by the modifier.
Its calling sequence is:</p>
<dl class="simple" id="id5">
<dt><code class="code highlight c docutils literal highlight-c"><span class="n">t_stat</span><span class="w"> </span><span class="n">validation_routine</span><span class="w"> </span><span class="p">(</span><span class="n">UNIT</span><span class="w"> </span><span class="o">*</span><span class="n">uptr</span><span class="p">,</span><span class="w"> </span><span class="n">int32</span><span class="w"> </span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">cptr</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">desc</span><span class="p">)</span></code></dt><dd><p>Test that <code class="docutils literal notranslate"><span class="pre">uptr.flags</span></code> can be set to <code class="docutils literal notranslate"><span class="pre">value</span></code>.
<code class="docutils literal notranslate"><span class="pre">cptr</span></code> points to the value portion of the parameter string
(any characters after the <code class="docutils literal notranslate"><span class="pre">=</span></code> sign);
if <code class="docutils literal notranslate"><span class="pre">cptr</span></code> is <code class="code highlight c docutils literal highlight-c"><span class="nb">NULL</span></code>, no value was given.
<code class="docutils literal notranslate"><span class="pre">desc</span></code> points to the <a class="reference internal" href="#reg"><code class="docutils literal notranslate"><span class="pre">REG</span></code></a> or <code class="code highlight c docutils literal highlight-c"><span class="n">int32</span></code> used to store the parameter.</p>
</dd>
</dl>
</section>
<section id="display-routine">
<h4><span class="sectnum">1.4.5.2. </span>Display routine<a class="headerlink" href="#display-routine" title="Permalink to this heading">¶</a></h4>
<p>The display routine is called during <code class="docutils literal notranslate"><span class="pre">SHOW</span></code> processing to display device- or unit-specific state.
Its calling sequence is:</p>
<dl class="simple">
<dt><code class="code highlight c docutils literal highlight-c"><span class="n">t_stat</span><span class="w"> </span><span class="n">display_routine</span><span class="w"> </span><span class="p">(</span><span class="kt">FILE</span><span class="w"> </span><span class="o">*</span><span class="n">st</span><span class="p">,</span><span class="w"> </span><span class="n">UNIT</span><span class="w"> </span><span class="o">*</span><span class="n">uptr</span><span class="p">,</span><span class="w"> </span><span class="n">int32</span><span class="w"> </span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">desc</span><span class="p">)</span></code></dt><dd><p>Output device- or unit-specific state for <code class="docutils literal notranslate"><span class="pre">uptr</span></code> to stream <code class="docutils literal notranslate"><span class="pre">st</span></code>.
If the modifier is a regular <a class="reference internal" href="#mtab"><code class="docutils literal notranslate"><span class="pre">MTAB</span></code></a> entry,
or an extended entry without <code class="docutils literal notranslate"><span class="pre">MTAB_SHP</span></code> set,
<code class="docutils literal notranslate"><span class="pre">desc</span></code> points to the structure in the <code class="docutils literal notranslate"><span class="pre">MTAB</span></code> entry.
If the modifier is an <a class="reference internal" href="#extended-mtab">extended MTAB</a> entry with <code class="docutils literal notranslate"><span class="pre">MTAB_SHP</span></code> set,
<code class="docutils literal notranslate"><span class="pre">desc</span></code> points to the optional value string or <code class="code highlight c docutils literal highlight-c"><span class="nb">NULL</span></code> if no value was supplied.
<code class="docutils literal notranslate"><span class="pre">value</span></code> is the value field of the matched <a class="reference internal" href="#mtab"><code class="docutils literal notranslate"><span class="pre">MTAB</span></code></a> entry.</p>
</dd>
</dl>
<p>When the display routine is called,
<code class="docutils literal notranslate"><span class="pre">SHOW</span></code> hasn’t output anything.
<code class="docutils literal notranslate"><span class="pre">SHOW</span></code> will append a newline after the display routine returns,
except for extended entries with the <code class="docutils literal notranslate"><span class="pre">MTAB_NMO</span></code> flag set.</p>
</section>
<section id="help-flags">
<h4><span class="sectnum">1.4.5.3. </span>Help flags<a class="headerlink" href="#help-flags" title="Permalink to this heading">¶</a></h4>
<p>The flags <code class="docutils literal notranslate"><span class="pre">MTAB_VALR</span></code> and <code class="docutils literal notranslate"><span class="pre">MTAB_VALO</span></code> are used to construct command syntax examples when displaying help for <code class="docutils literal notranslate"><span class="pre">SET</span></code> and <code class="docutils literal notranslate"><span class="pre">SHOW</span></code> commands.
These flags do not otherwise influence the actions taken during processing of <code class="docutils literal notranslate"><span class="pre">SET</span></code> or <code class="docutils literal notranslate"><span class="pre">SHOW</span></code> commands.</p>
</section>
<section id="example-arguments-in-the-mstring">
<h4><span class="sectnum">1.4.5.4. </span>Example arguments in the <code class="docutils literal notranslate"><span class="pre">mstring</span></code><a class="headerlink" href="#example-arguments-in-the-mstring" title="Permalink to this heading">¶</a></h4>
<p>The value of the <a class="reference internal" href="#mtab-mstring"><code class="docutils literal notranslate"><span class="pre">mstring</span></code></a> field may contain examples of valid additional parameters which may be specified as values.
For example:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">MTAB</span><span class="w"> </span><span class="n">cr_mod</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">{</span><span class="w"> </span><span class="n">mask</span><span class="p">,</span><span class="w"> </span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;normal&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;NORMAL&quot;</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="w"> </span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span><span class="w"> </span><span class="n">MTAB_XTD</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">MTAB_VDV</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;TRANSLATION&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;TRANSLATION={DEFAULT|026|026FTN|029|EBCDIC}&quot;</span><span class="p">,</span>
<span class="w">      </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">cr_set_trans</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">cr_show_trans</span><span class="w"> </span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>This entry has an <a class="reference internal" href="#mtab-mstring"><code class="docutils literal notranslate"><span class="pre">mstring</span></code></a> value of <code class="docutils literal notranslate"><span class="pre">TRANSLATION={DEFAULT|026|026FTN|029|EBCDIC}</span></code>.
When comparisons are made against this string,
everything starting at the equal sign and beyond is irrelevant to the match activity since the input being compared has already been parsed with a delimiter of <code class="docutils literal notranslate"><span class="pre">=</span></code>.
The remaining parts of the <a class="reference internal" href="#mtab-mstring"><code class="docutils literal notranslate"><span class="pre">mstring</span></code></a> value are ignored, but are available when constructing <code class="docutils literal notranslate"><span class="pre">HELP</span> <span class="pre">dev</span> <span class="pre">SET</span></code> output.</p>
</section>
<section id="help-field">
<h4><span class="sectnum">1.4.5.5. </span>Help field<a class="headerlink" href="#help-field" title="Permalink to this heading">¶</a></h4>
<p>The <a class="reference internal" href="#mtab"><code class="docutils literal notranslate"><span class="pre">MTAB</span></code></a> entry’s help field is used when constructing <code class="docutils literal notranslate"><span class="pre">HELP</span> <span class="pre">dev</span> <span class="pre">SHOW</span></code> or <code class="docutils literal notranslate"><span class="pre">HELP</span> <span class="pre">dev</span> <span class="pre">SHOW</span></code> output.
It serves to describe the purpose or effect of the particular <code class="docutils literal notranslate"><span class="pre">SET</span> <span class="pre">dev</span></code> or <code class="docutils literal notranslate"><span class="pre">SHOW</span> <span class="pre">dev</span></code> command.
The help field is ignored when constructing <code class="docutils literal notranslate"><span class="pre">HELP</span> <span class="pre">dev</span> <span class="pre">SET</span></code> output for <a class="reference internal" href="#mtab"><code class="docutils literal notranslate"><span class="pre">MTAB</span></code></a> entries which have an equal sign in the <a class="reference internal" href="#mtab-mstring"><code class="docutils literal notranslate"><span class="pre">mstring</span></code></a> field.</p>
</section>
</section>
<section id="other-data-structures">
<h3><span class="sectnum">1.4.6. </span>Other data structures<a class="headerlink" href="#other-data-structures" title="Permalink to this heading">¶</a></h3>
<p id="sim-name"><code class="code highlight c docutils literal highlight-c"><span class="kt">char</span><span class="w"> </span><span class="n">sim_name</span><span class="p">[]</span></code> is a character array containing the VM name.</p>
<p id="sim-emax"><code class="code highlight c docutils literal highlight-c"><span class="n">int32</span><span class="w"> </span><span class="n">sim_emax</span></code> contains the maximum number of words needed to hold the largest instruction or data item in the VM.
Examine and deposit will process up to <code class="docutils literal notranslate"><span class="pre">sim_emax</span></code> words.</p>
<p id="sim-devices"><code class="code highlight c docutils literal highlight-c"><span class="n">DEVICE</span><span class="w"> </span><span class="o">*</span><span class="n">sim_devices</span><span class="p">[]</span></code> is an array of pointers to all the devices in the VM.
It is terminated by a <code class="code highlight c docutils literal highlight-c"><span class="nb">NULL</span></code>.
By convention, the CPU is always the first device in the array.</p>
<p id="sim-pc"><code class="code highlight c docutils literal highlight-c"><span class="n">REG</span><span class="w"> </span><span class="o">*</span><span class="n">sim_PC</span></code> points to the <a class="reference internal" href="#reg"><code class="docutils literal notranslate"><span class="pre">REG</span></code></a> structure for the program counter.
By convention, the PC is always the first register in the CPU’s register array.</p>
<p id="sim-stop-messages"><code class="code highlight c docutils literal highlight-c"><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">sim_stop_messages</span><span class="p">[</span><span class="n">SCPE_BASE</span><span class="p">]</span></code> is an array of pointers to character strings,
corresponding to error status returns greater than zero.
If <a class="reference internal" href="#id7"><code class="docutils literal notranslate"><span class="pre">sim_instr</span></code></a> returns status code <span class="math notranslate nohighlight">\(n &gt; 0\)</span> but less than <code class="docutils literal notranslate"><span class="pre">SCPE_BASE</span></code>,
then <code class="code highlight c docutils literal highlight-c"><span class="n">sim_stop_message</span><span class="p">[</span><span class="n">n</span><span class="p">]</span></code> is printed by SCP.
This array must have valid character pointers for all values <span class="math notranslate nohighlight">\(&lt; SCPE_BASE\)</span> which <a class="reference internal" href="#id7"><code class="docutils literal notranslate"><span class="pre">sim_instr</span></code></a> returns.
Declaring the array with dimension <code class="docutils literal notranslate"><span class="pre">SCPE_BASE</span></code> will properly allow the array to be filled in as needed with appropriate message text for any messages that are needed while also providing <code class="code highlight c docutils literal highlight-c"><span class="nb">NULL</span></code> pointers for the remaining possibilities.</p>
</section>
</section>
<section id="vm-provided-routines">
<h2><span class="sectnum">1.5. </span>VM-provided routines<a class="headerlink" href="#vm-provided-routines" title="Permalink to this heading">¶</a></h2>
<section id="id6">
<h3><span class="sectnum">1.5.1. </span>Instruction execution<a class="headerlink" href="#id6" title="Permalink to this heading">¶</a></h3>
<p id="id7"><span id="sim-instr"></span>Instruction execution is performed by routine <code class="docutils literal notranslate"><span class="pre">sim_instr</span></code>.
Its calling sequence is:</p>
<dl class="simple">
<dt><code class="code highlight c docutils literal highlight-c"><span class="n">t_stat</span><span class="w"> </span><span class="n">sim_instr</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="p">)</span></code></dt><dd><p>Execute from current PC until error or halt.</p>
</dd>
</dl>
</section>
<section id="binary-load-and-dump">
<h3><span class="sectnum">1.5.2. </span>Binary load and dump<a class="headerlink" href="#binary-load-and-dump" title="Permalink to this heading">¶</a></h3>
<p id="sim-load">If the VM responds to the <code class="docutils literal notranslate"><span class="pre">LOAD</span></code> (or <code class="docutils literal notranslate"><span class="pre">DUMP</span></code>) command,
the load (or dump) routine is implemented by routine <code class="docutils literal notranslate"><span class="pre">sim_load</span></code>.
Its calling sequence is:</p>
<dl class="simple">
<dt><code class="code highlight c docutils literal highlight-c"><span class="n">t_stat</span><span class="w"> </span><span class="n">sim_load</span><span class="w"> </span><span class="p">(</span><span class="kt">FILE</span><span class="w"> </span><span class="o">*</span><span class="n">fptr</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">fnam</span><span class="p">,</span><span class="w"> </span><span class="n">t_bool</span><span class="w"> </span><span class="n">flag</span><span class="p">)</span></code></dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">flag</span></code><span class="math notranslate nohighlight">\(\ = 0\)</span>,
load data from binary file <code class="docutils literal notranslate"><span class="pre">fptr</span></code>.
If <code class="docutils literal notranslate"><span class="pre">flag</span></code><span class="math notranslate nohighlight">\(\ = 1\)</span>,
dump data to binary file <code class="docutils literal notranslate"><span class="pre">fptr</span></code>.
For either command,
<code class="docutils literal notranslate"><span class="pre">buf</span></code> contains any VM-specific arguments,
and <code class="docutils literal notranslate"><span class="pre">fnam</span></code> contains the filename.</p>
</dd>
</dl>
<p>If <code class="docutils literal notranslate"><span class="pre">LOAD</span></code> or <code class="docutils literal notranslate"><span class="pre">DUMP</span></code> is not implemented,
<code class="docutils literal notranslate"><span class="pre">sim_load</span></code> should simply return <code class="docutils literal notranslate"><span class="pre">SCPE_ARG</span></code>.
The <code class="docutils literal notranslate"><span class="pre">LOAD</span></code> and <code class="docutils literal notranslate"><span class="pre">DUMP</span></code> commands open the specified file before calling <code class="docutils literal notranslate"><span class="pre">sim_load</span></code>,
and close it on return.</p>
<p><code class="docutils literal notranslate"><span class="pre">sim_load</span></code> may optionally load or dump data in different formats based on flag options specified in the <code class="docutils literal notranslate"><span class="pre">sim_switches</span></code> variable.
If or how this is done or what any switches mean are completely up to the simulator’s implementation in the <code class="docutils literal notranslate"><span class="pre">sim_load</span></code> function.</p>
</section>
<section id="symbolic-examination-and-deposit">
<h3><span class="sectnum">1.5.3. </span>Symbolic examination and deposit<a class="headerlink" href="#symbolic-examination-and-deposit" title="Permalink to this heading">¶</a></h3>
<p>If the VM provides symbolic examination and deposit of data,
it must provide two routines,
<code class="docutils literal notranslate"><span class="pre">fprint_sym</span></code> for output and <code class="docutils literal notranslate"><span class="pre">parse_sym</span></code> for input.
Their calling sequences are:</p>
<dl class="simple" id="fprint-sym">
<dt><code class="code highlight c docutils literal highlight-c"><span class="n">t_stat</span><span class="w"> </span><span class="n">fprint_sym</span><span class="w"> </span><span class="p">(</span><span class="kt">FILE</span><span class="w"> </span><span class="o">*</span><span class="n">ofile</span><span class="p">,</span><span class="w"> </span><span class="n">t_addr</span><span class="w"> </span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="n">t_value</span><span class="w"> </span><span class="o">*</span><span class="n">val</span><span class="p">,</span><span class="w"> </span><span class="n">UNIT</span><span class="w"> </span><span class="o">*</span><span class="n">uptr</span><span class="p">,</span><span class="w"> </span><span class="n">int32</span><span class="w"> </span><span class="k">switch</span><span class="p">)</span></code></dt><dd><p>Based on the <code class="docutils literal notranslate"><span class="pre">switch</span></code> variable,
symbolically output to stream <code class="docutils literal notranslate"><span class="pre">ofile</span></code> the data in array <code class="docutils literal notranslate"><span class="pre">val</span></code> at the specified <code class="docutils literal notranslate"><span class="pre">addr</span></code> in unit <code class="docutils literal notranslate"><span class="pre">uptr</span></code>.</p>
</dd>
</dl>
<span id="fparse-sym"></span><dl class="simple" id="parse-sym">
<dt><code class="code highlight c docutils literal highlight-c"><span class="n">t_stat</span><span class="w"> </span><span class="n">parse_sym</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">cptr</span><span class="p">,</span><span class="w"> </span><span class="n">t_addr</span><span class="w"> </span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="n">UNIT</span><span class="w"> </span><span class="o">*</span><span class="n">uptr</span><span class="p">,</span><span class="w"> </span><span class="n">t_value</span><span class="w"> </span><span class="o">*</span><span class="n">val</span><span class="p">,</span><span class="w"> </span><span class="n">int32</span><span class="w"> </span><span class="k">switch</span><span class="p">)</span></code></dt><dd><p>Based on the <code class="docutils literal notranslate"><span class="pre">switch</span></code> variable,
parse character string <code class="docutils literal notranslate"><span class="pre">cptr</span></code> for a symbolic value <code class="docutils literal notranslate"><span class="pre">val</span></code> at the specified <code class="docutils literal notranslate"><span class="pre">addr</span></code> in unit <code class="docutils literal notranslate"><span class="pre">uptr</span></code>.</p>
</dd>
</dl>
<p>If symbolic processing is not implemented,
or the output value or input string cannot be parsed,
these routines should return <code class="docutils literal notranslate"><span class="pre">SCPE_ARG</span></code>.
If the processing was successful and consumed more than a single word,
then these routines should return extra number of addressing units consumed as a <strong>negative</strong> number.
If the processing was successful and consumed a single addressing unit,
then these routines should return <code class="docutils literal notranslate"><span class="pre">SCPE_OK</span></code>.
For example, PDP-11 <code class="docutils literal notranslate"><span class="pre">parse_sym</span></code> would respond as follows to various inputs:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Input</p></th>
<th class="head"><p>Return value</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">XYZGH</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">SCPE_ARG</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">MOV</span> <span class="pre">R0,R1</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">-1</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">MOV</span> <span class="pre">#4,R5</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">-3</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">MOV</span> <span class="pre">1234,5670</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">-5</span></code></p></td>
</tr>
</tbody>
</table>
<p>There is an implicit relationship between the <code class="docutils literal notranslate"><span class="pre">addr</span></code> and <code class="docutils literal notranslate"><span class="pre">val</span></code> arguments and the device’s <a class="reference internal" href="#device-aincr"><code class="docutils literal notranslate"><span class="pre">aincr</span></code></a> fields.
Each entry in <code class="docutils literal notranslate"><span class="pre">val</span></code> is assumed to represent <a class="reference internal" href="#device-aincr"><code class="docutils literal notranslate"><span class="pre">aincr</span></code></a> addressing units,
starting at <code class="docutils literal notranslate"><span class="pre">addr</span></code>:</p>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p><code class="code highlight c docutils literal highlight-c"><span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></code></p></td>
<td><p><code class="code highlight c docutils literal highlight-c"><span class="n">addr</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">0</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="code highlight c docutils literal highlight-c"><span class="n">val</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span></code></p></td>
<td><p><code class="code highlight c docutils literal highlight-c"><span class="n">addr</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">aincr</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="code highlight c docutils literal highlight-c"><span class="n">val</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span></code></p></td>
<td><p><code class="code highlight c docutils literal highlight-c"><span class="n">addr</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">aincr</span><span class="p">)</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="code highlight c docutils literal highlight-c"><span class="n">val</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span></code></p></td>
<td><p><code class="code highlight c docutils literal highlight-c"><span class="n">addr</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="mi">3</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">aincr</span><span class="p">)</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>⋮</p></td>
<td><p>⋮</p></td>
</tr>
</tbody>
</table>
<p>Because <code class="docutils literal notranslate"><span class="pre">val</span></code> is typically filled-in and stored by calls on the device’s examine and deposit routines,
respectively,
the examine and deposit routines and <code class="docutils literal notranslate"><span class="pre">fprint_sym</span></code> and <code class="docutils literal notranslate"><span class="pre">fparse_sym</span></code> must agree on the expected width of items in <code class="docutils literal notranslate"><span class="pre">val</span></code>,
and on the alignment of <code class="docutils literal notranslate"><span class="pre">addr</span></code>.
Further, if <code class="docutils literal notranslate"><span class="pre">fparse_sym</span></code> wants to modify a storage unit narrower than <code class="docutils literal notranslate"><span class="pre">awidth</span></code>,
it must insert the new data into the appropriate entry in <code class="docutils literal notranslate"><span class="pre">val</span></code> without destroying surrounding fields.
The number of words in the <code class="docutils literal notranslate"><span class="pre">val</span></code> array is given by the global variable <a class="reference internal" href="#sim-emax"><code class="docutils literal notranslate"><span class="pre">sim_emax</span></code></a>.</p>
<p>The interpretation of switch values is arbitrary (except in the cases noted below),
but the following are provided by existing VMs in their <code class="docutils literal notranslate"><span class="pre">fprint_sym</span></code> implementations:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Switch</p></th>
<th class="head"><p>Interpretation</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">-a</span></code></p></td>
<td><p>Single character</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">-c</span></code></p></td>
<td><p>Character string</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">-m</span></code></p></td>
<td><p>Instruction mnemonic</p></td>
</tr>
</tbody>
</table>
<p>In addition,
on input,
a leading <code class="docutils literal notranslate"><span class="pre">'</span></code> (apostrophe) is interpreted to mean a single character,
and a leading <code class="docutils literal notranslate"><span class="pre">&quot;</span></code> (double-quote) is interpreted to mean a character string.</p>
<p><code class="docutils literal notranslate"><span class="pre">fprint_sym</span></code> is called to print the instruction at the program counter value for the simulation stop message,
for registers containing user-defined or <code class="docutils literal notranslate"><span class="pre">REG_VMIO</span></code> flags in their <a class="reference internal" href="#reg-flags"><code class="docutils literal notranslate"><span class="pre">flags</span></code></a> fields and memory values printed by the <code class="docutils literal notranslate"><span class="pre">EXAMINE</span></code> command,
and for printing the values printed by the <code class="docutils literal notranslate"><span class="pre">EVAL</span></code> command.
These cases are differentiated by the presence of special flags in the <code class="docutils literal notranslate"><span class="pre">switch</span></code> parameter.
For a simulation stop, the “M” switch and the <code class="docutils literal notranslate"><span class="pre">SIM_SW_STOP</span></code> switch are passed.
For examining registers, the <code class="docutils literal notranslate"><span class="pre">SIM_SW_REG</span></code> switch is passed.
In addition, the user-defined flags and register radix are passed in the <code class="docutils literal notranslate"><span class="pre">addr</span></code> parameter.
Register radix is taken from the radix specified in the register definition,
or overridden by <code class="docutils literal notranslate"><span class="pre">-d</span></code>, <code class="docutils literal notranslate"><span class="pre">-o</span></code>, or <code class="docutils literal notranslate"><span class="pre">-x</span></code> switches in the command.
For examining memory and the <code class="docutils literal notranslate"><span class="pre">EVAL</span></code> command,
no special switch flags are passed.</p>
<p><code class="docutils literal notranslate"><span class="pre">parse_sym</span></code> is called to parse memory,
register,
and the logical and relational search specifier values for the <code class="docutils literal notranslate"><span class="pre">DEPOSIT</span></code> command and the symbolic expression for the <code class="docutils literal notranslate"><span class="pre">EVAL</span></code> command.
As with <code class="docutils literal notranslate"><span class="pre">fprint_sym</span></code>,
these cases are differentiated by the presence of special flags in the <code class="docutils literal notranslate"><span class="pre">switch</span></code> parameter.
For registers, the <code class="docutils literal notranslate"><span class="pre">SIM_SW_REG</span></code> switch is passed.
For all other cases, no special switch flags are passed.</p>
</section>
<section id="optional-interfaces">
<h3><span class="sectnum">1.5.4. </span>Optional interfaces<a class="headerlink" href="#optional-interfaces" title="Permalink to this heading">¶</a></h3>
<p>For greater flexibility,
SCP provides some optional interfaces that can be used to extend its command input,
command processing,
and command post-processing capabilities.
These interfaces are strictly optional and are off by default.
Using them requires intimate knowledge of how SCP functions internally and is not recommended to the novice VM writer.</p>
<section id="once-only-initialization-routine">
<h4><span class="sectnum">1.5.4.1. </span>Once only initialization routine<a class="headerlink" href="#once-only-initialization-routine" title="Permalink to this heading">¶</a></h4>
<p>SCP previously defined a pointer <code class="code highlight c docutils literal highlight-c"><span class="p">(</span><span class="o">*</span><span class="n">sim_vm_init</span><span class="p">)(</span><span class="kt">void</span><span class="p">)</span></code>.
This was a “weak global”;
the intention of this routine was that if no other module defines this value,
it will default to <code class="code highlight c docutils literal highlight-c"><span class="nb">NULL</span></code>.
A VM requiring special initialization would fill in this pointer with the address of its special initialization routine:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">WEAK</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">sim_special_init</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="n">WEAK</span><span class="w"> </span><span class="nf">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">sim_vm_init</span><span class="p">)(</span><span class="kt">void</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">sim_special_init</span><span class="p">;</span>
</pre></div>
</div>
<p>The special initialization routine could perform any actions required by the VM.
If the other optional interfaces are to be used,
the initialization routine could also fill in the appropriate pointers.</p>
<p>Due to the lack of reliable functionality across all different supported host platforms,
this “weak global” paradigm has been removed.
These activities must now be done in the CPU reset routine
(since that is called during SCP initialization,
as well as when a <code class="docutils literal notranslate"><span class="pre">RESET</span></code> command is issued later on).
When these are done in the CPU reset routine,
care should be taken to only perform them once if they have any side-effects
(like clearing all memory).</p>
</section>
<section id="address-input-and-display">
<h4><span class="sectnum">1.5.4.2. </span>Address input and display<a class="headerlink" href="#address-input-and-display" title="Permalink to this heading">¶</a></h4>
<p id="sim-vm-parse-addr">SCP defines a pointer <code class="code highlight c docutils literal highlight-c"><span class="n">t_addr</span><span class="w"> </span><span class="o">*</span><span class="p">(</span><span class="n">sim_vm_parse_addr</span><span class="p">)(</span><span class="n">DEVICE</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">**</span><span class="p">)</span></code>.  This is initialized to <code class="code highlight c docutils literal highlight-c"><span class="nb">NULL</span></code>.
If it is filled in by the VM,
SCP will use the specified routine to parse addresses in place of its standard numerical input routine.
The current command switches,
if needed,
may be read from the global variable <code class="docutils literal notranslate"><span class="pre">sim_switches</span></code>.
The calling sequence for the <code class="docutils literal notranslate"><span class="pre">sim_vm_parse_addr</span></code> routine is:</p>
<dl class="simple">
<dt><code class="code highlight c docutils literal highlight-c"><span class="n">t_addr</span><span class="w"> </span><span class="n">sim_vm_parse_addr</span><span class="w"> </span><span class="p">(</span><span class="n">DEVICE</span><span class="w"> </span><span class="o">*</span><span class="n">dptr</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">cptr</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">**</span><span class="n">optr</span><span class="p">)</span></code></dt><dd><p>Parse the string pointed to by <code class="docutils literal notranslate"><span class="pre">cptr</span></code> as an address for the device pointed to by <code class="docutils literal notranslate"><span class="pre">dptr</span></code>.
<code class="docutils literal notranslate"><span class="pre">optr</span></code> points to the first character not successfully parsed.
If <code class="docutils literal notranslate"><span class="pre">cptr</span> <span class="pre">==</span> <span class="pre">optr</span></code>,
parsing failed.</p>
</dd>
</dl>
<p id="sim-vm-fprint-addr">SCP defines a pointer <code class="code highlight c docutils literal highlight-c"><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="p">(</span><span class="n">sim_vm_fprint_addr</span><span class="p">)(</span><span class="kt">FILE</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="n">DEVICE</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="n">t_addr</span><span class="p">)</span></code>.
This is initialized to <code class="code highlight c docutils literal highlight-c"><span class="nb">NULL</span></code>.
If it is filled in by the VM,
SCP will use the specified routine to print addresses in place of its standard numerical output routine.
The calling sequence for the <code class="docutils literal notranslate"><span class="pre">sim_vm_fprint_addr</span></code> routine is:</p>
<dl class="simple">
<dt><code class="code highlight c docutils literal highlight-c"><span class="n">t_addr</span><span class="w"> </span><span class="n">sim_vm_fprint_addr</span><span class="w"> </span><span class="p">(</span><span class="kt">FILE</span><span class="w"> </span><span class="o">*</span><span class="n">stream</span><span class="p">,</span><span class="w"> </span><span class="n">DEVICE</span><span class="w"> </span><span class="o">*</span><span class="n">dptr</span><span class="p">,</span><span class="w"> </span><span class="n">t_addr</span><span class="w"> </span><span class="n">addr</span><span class="p">)</span></code></dt><dd><p>Output address <code class="docutils literal notranslate"><span class="pre">addr</span></code> to <code class="docutils literal notranslate"><span class="pre">stream</span></code> in the format required by the device pointed to by <code class="docutils literal notranslate"><span class="pre">dptr</span></code>.</p>
</dd>
</dl>
<p id="sim-vm-sprint-addr">SCP defines a pointer void <code class="code highlight c docutils literal highlight-c"><span class="o">*</span><span class="p">(</span><span class="n">sim_vm_sprint_addr</span><span class="p">)(</span><span class="kt">FILE</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="n">DEVICE</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="n">t_addr</span><span class="p">)</span></code>.
This is initialized to <code class="code highlight c docutils literal highlight-c"><span class="nb">NULL</span></code>.
If it is filled in by the VM,
SCP will use the specified routine to print addresses in place of its standard numerical output routine.
The calling sequence for the <code class="docutils literal notranslate"><span class="pre">sim_vm_sprint_addr</span></code> routine is:</p>
<dl class="simple">
<dt><code class="code highlight c docutils literal highlight-c"><span class="n">t_addr</span><span class="w"> </span><span class="n">sim_vm_sprint_addr</span><span class="w"> </span><span class="p">(</span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="n">DEVICE</span><span class="w"> </span><span class="o">*</span><span class="n">dptr</span><span class="p">,</span><span class="w"> </span><span class="n">t_addr</span><span class="w"> </span><span class="n">addr</span><span class="p">)</span></code></dt><dd><p>Output address <code class="docutils literal notranslate"><span class="pre">addr</span></code> to <code class="docutils literal notranslate"><span class="pre">buf</span></code> in the format required by the device pointed to by <code class="docutils literal notranslate"><span class="pre">dptr</span></code>.</p>
</dd>
</dl>
</section>
<section id="command-input-and-post-processing">
<h4><span class="sectnum">1.5.4.3. </span>Command input and post-processing<a class="headerlink" href="#command-input-and-post-processing" title="Permalink to this heading">¶</a></h4>
<p id="sim-vm-read">SCP defines a pointer <code class="code highlight c docutils literal highlight-c"><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">sim_vm_read</span><span class="p">)(</span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="n">int32</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">FILE</span><span class="w"> </span><span class="o">*</span><span class="p">)</span></code>.
This is initialized to <code class="code highlight c docutils literal highlight-c"><span class="nb">NULL</span></code>.
If it is filled in by the VM,
SCP will use the specified routine to obtain command input in place of its standard routine, <code class="code highlight c docutils literal highlight-c"><span class="n">read_line</span></code>.
The calling sequence for the <code class="docutils literal notranslate"><span class="pre">sim_vm_read</span></code> routine is:</p>
<dl class="simple">
<dt><code class="code highlight c docutils literal highlight-c"><span class="kt">char</span><span class="w"> </span><span class="n">sim_vm_input</span><span class="w"> </span><span class="p">(</span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="n">int32</span><span class="w"> </span><span class="o">*</span><span class="n">max</span><span class="p">,</span><span class="w"> </span><span class="kt">FILE</span><span class="w"> </span><span class="o">*</span><span class="n">stream</span><span class="p">)</span></code></dt><dd><p>Read the next command line from <code class="docutils literal notranslate"><span class="pre">stream</span></code> and store it in <code class="docutils literal notranslate"><span class="pre">buf</span></code>,
up to a maximum of <code class="docutils literal notranslate"><span class="pre">max</span></code> characters.</p>
</dd>
</dl>
<p>The routine is expected to strip off leading whitespace characters and to return <code class="code highlight c docutils literal highlight-c"><span class="nb">NULL</span></code> on end-of-file.</p>
<p id="vm-post">SCP defines a pointer <code class="code highlight c docutils literal highlight-c"><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="p">(</span><span class="n">sim_vm_post</span><span class="p">)(</span><span class="n">t_bool</span><span class="w"> </span><span class="n">from_scp</span><span class="p">)</span></code>.
This is initialized to <code class="code highlight c docutils literal highlight-c"><span class="nb">NULL</span></code>.
If filled in by the VM,
SCP will call the specified routine at the end of every command.
This allows the VM to update any local state,
such as a GUI console display.
The calling sequence for the <code class="docutils literal notranslate"><span class="pre">vm_post</span></code> routine is:</p>
<p><code class="code highlight c docutils literal highlight-c"><span class="kt">void</span><span class="w"> </span><span class="n">sim_vm_postupdate</span><span class="w"> </span><span class="p">(</span><span class="n">t_bool</span><span class="w"> </span><span class="n">from_scp</span><span class="p">)</span></code>
If called from SCP,
the argument <code class="docutils literal notranslate"><span class="pre">from_scp</span></code> is <code class="code highlight c docutils literal highlight-c"><span class="n">TRUE</span></code>;
otherwise, it is <code class="code highlight c docutils literal highlight-c"><span class="n">FALSE</span></code>.</p>
</section>
<section id="simulator-stop-message-formatting">
<h4><span class="sectnum">1.5.4.4. </span>Simulator stop message formatting<a class="headerlink" href="#simulator-stop-message-formatting" title="Permalink to this heading">¶</a></h4>
<p id="vm-fprint-stopped"><span id="sim-vm-fprint-stopped"></span>SCP defines a pointer,
<code class="code highlight c docutils literal highlight-c"><span class="n">sim_vm_fprint_stopped</span></code>,
to a function taking parameters of type <code class="code highlight c docutils literal highlight-c"><span class="kt">FILE</span><span class="w"> </span><span class="o">*</span></code> and <code class="code highlight c docutils literal highlight-c"><span class="n">t_stat</span></code> and returning a value of type <code class="code highlight c docutils literal highlight-c"><span class="n">t_bool</span></code>.
It is initialized to <code class="code highlight c docutils literal highlight-c"><span class="nb">NULL</span></code> but may be reset by the VM to point at a routine that will be called when a simulator stop occurs.
The calling sequence is:</p>
<dl class="simple">
<dt><code class="code highlight c docutils literal highlight-c"><span class="n">t_bool</span><span class="w"> </span><span class="n">vm_fprint_stopped</span><span class="w"> </span><span class="p">(</span><span class="kt">FILE</span><span class="w"> </span><span class="o">*</span><span class="n">stream</span><span class="p">,</span><span class="w"> </span><span class="n">t_stat</span><span class="w"> </span><span class="n">reason</span><span class="p">)</span></code></dt><dd><p>Write a simulator stop message to <code class="docutils literal notranslate"><span class="pre">stream</span></code> for the <code class="docutils literal notranslate"><span class="pre">reason</span></code> specified,
and return <code class="code highlight c docutils literal highlight-c"><span class="n">TRUE</span></code> if SCP should append the program counter value or <code class="code highlight c docutils literal highlight-c"><span class="n">FALSE</span></code> if SCP should not.</p>
</dd>
</dl>
<p>When the instruction loop is exited,
SCP regains control and prints a simulator stop message.
By default, the message is printed with this format:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">reason</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">program</span> <span class="n">counter</span> <span class="n">label</span><span class="o">&gt;</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">address</span><span class="o">&gt;</span> <span class="p">(</span><span class="o">&lt;</span><span class="n">instruction</span> <span class="n">mnemonic</span><span class="o">&gt;</span><span class="p">)</span>
</pre></div>
</div>
<p>For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">SCPE_STOP</span> <span class="n">prints</span> <span class="s2">&quot;Simulation stopped, P: 24713 (LOAD 1)&quot;</span>
<span class="n">SCPE_STEP</span> <span class="n">prints</span> <span class="s2">&quot;Step expired, P: 24713 (LOAD 1)&quot;</span>
</pre></div>
</div>
<p>For VM stops,
this routine is called after the reason has been printed and before the comma,
program counter label,
address,
and instruction mnemonic are printed.
Depending on the reason for the stop,
the routine may insert additional information,
and it may request omission of the PC value by returning <code class="code highlight c docutils literal highlight-c"><span class="n">FALSE</span></code> instead of <code class="code highlight c docutils literal highlight-c"><span class="n">TRUE</span></code>.
For example, a VM may define these stops and their associated formats:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">STOP_SYSHALT</span>   <span class="n">prints</span> <span class="s2">&quot;System halt 3, P: 24713 (LOAD 1)&quot;</span>
<span class="n">STOP_HALT</span>      <span class="n">prints</span> <span class="s2">&quot;Programmed halt, CIR: 030365 (HALT 5), P: 24713 (LOAD 1)&quot;</span>
<span class="n">STOP_CDUMP</span>     <span class="n">prints</span> <span class="s2">&quot;Cold dump complete, CIR: 000020&quot;</span>
</pre></div>
</div>
<p>For these examples,
the VM’s <code class="docutils literal notranslate"><span class="pre">vm_fprint_stopped</span></code> routine prints <code class="docutils literal notranslate"><span class="pre">&quot;</span> <span class="pre">3&quot;</span></code> and returns <code class="code highlight c docutils literal highlight-c"><span class="n">TRUE</span></code> for <code class="docutils literal notranslate"><span class="pre">STOP_SYSHALT</span></code>,
prints <code class="docutils literal notranslate"><span class="pre">&quot;,</span> <span class="pre">CIR:</span> <span class="pre">030365</span> <span class="pre">(HALT</span> <span class="pre">5)&quot;</span></code> and returns <code class="code highlight c docutils literal highlight-c"><span class="n">TRUE</span></code> for <code class="docutils literal notranslate"><span class="pre">STOP_HALT</span></code>,
prints <code class="docutils literal notranslate"><span class="pre">&quot;,</span> <span class="pre">CIR:</span> <span class="pre">000020&quot;</span></code> and returns <code class="code highlight c docutils literal highlight-c"><span class="n">FALSE</span></code> for <code class="docutils literal notranslate"><span class="pre">STOP_CDUMP</span></code>,
and prints nothing and returns <code class="code highlight c docutils literal highlight-c"><span class="n">TRUE</span></code> for all other VM stops.</p>
</section>
<section id="vm-specific-commands">
<h4><span class="sectnum">1.5.4.5. </span>VM-specific commands<a class="headerlink" href="#vm-specific-commands" title="Permalink to this heading">¶</a></h4>
<p id="sim-vm-cmd">SCP defines a pointer <code class="code highlight c docutils literal highlight-c"><span class="n">CTAB</span><span class="w"> </span><span class="o">*</span><span class="n">sim_vm_cmd</span></code>.
This is initialized to <code class="code highlight c docutils literal highlight-c"><span class="nb">NULL</span></code>.
If filled in by the VM,
SCP interprets it as a pointer to SCP command table.
This command table is checked before user input is looked up in the standard command table.
It may be used to override or otherwise arbitrarily extend the functionality of a normal SCP command.</p>
<p id="ctab"><span id="sim-ctab"></span>A command table is allocated as a contiguous array.
Each entry is defined with a <code class="docutils literal notranslate"><span class="pre">sim_ctab</span></code> structure (<code class="code highlight c docutils literal highlight-c"><span class="k">typedef</span><span class="w"> </span><span class="n">CTAB</span></code>):</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">sim_ctab</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w">  </span><span class="o">*</span><span class="n">name</span><span class="p">;</span><span class="w">       </span><span class="cm">/* Name */</span>
<span class="w">    </span><span class="n">t_stat</span><span class="w">     </span><span class="p">(</span><span class="o">*</span><span class="n">action</span><span class="p">)();</span><span class="w">  </span><span class="cm">/* Action routine */</span>
<span class="w">    </span><span class="n">int32</span><span class="w">        </span><span class="n">arg</span><span class="p">;</span><span class="w">        </span><span class="cm">/* Argument */</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w">  </span><span class="o">*</span><span class="n">help</span><span class="p">;</span><span class="w">       </span><span class="cm">/* Help string */</span>
<span class="p">};</span>
</pre></div>
</div>
<p>If the first word of a command line matches <code class="docutils literal notranslate"><span class="pre">ctab.name</span></code>,
then the action routine is called with the following arguments:</p>
<dl class="simple">
<dt><code class="code highlight c docutils literal highlight-c"><span class="n">t_stat</span><span class="w"> </span><span class="n">action_routine</span><span class="w"> </span><span class="p">(</span><span class="n">int32</span><span class="w"> </span><span class="n">arg</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">buf</span><span class="p">)</span></code></dt><dd><p>Process input string <code class="docutils literal notranslate"><span class="pre">buf</span></code> based on optional argument <code class="docutils literal notranslate"><span class="pre">arg</span></code>.</p>
</dd>
</dl>
<p>The string passed to the action routine starts at the first non-blank character past the command name.</p>
<p>When looking for a matching command,
SCP scans the command table from first to last entry,
looking for a command name that begins with the command supplied by the user.
The first one found is considered the matching command.
If no match is found,
the SCP standard command table is scanned next,
using the same “first match” rule.
You may need to adjust command names for VM-specific commands to avoid conflicting with commonly used standard commands.
For example, if a VM defined the single VM-specific command <code class="docutils literal notranslate"><span class="pre">NORMAL_START</span></code>,
SCP would accept <code class="docutils literal notranslate"><span class="pre">N</span></code> as an abbreviation for this command.
This might confuse users who expect <code class="docutils literal notranslate"><span class="pre">N</span></code> to be an abbreviation of the <code class="docutils literal notranslate"><span class="pre">NEXT</span></code> command.
The “first match is used” rule is useful when a VM needs to redefine a standard SCP command with a different syntax.
For example, the VAX simulators do this in several different ways to redefine the <code class="docutils literal notranslate"><span class="pre">BOOT</span></code> command.</p>
</section>
<section id="vm-support-for-stepping-over-subroutine-calls">
<h4><span class="sectnum">1.5.4.6. </span>VM-support for stepping over subroutine calls<a class="headerlink" href="#vm-support-for-stepping-over-subroutine-calls" title="Permalink to this heading">¶</a></h4>
<p>SCP can provide the ability to step over subroutine calls with the <code class="docutils literal notranslate"><span class="pre">NEXT</span></code> command.
In order for the <code class="docutils literal notranslate"><span class="pre">NEXT</span></code> command to work,
the simulator must provide a VM-specific routine which will identify whether the next instruction to be executed is a subroutine call and, if so,
to identify where to dynamically insert breakpoint(s) to stop instruction execution when the subroutine returns.</p>
<p id="sim-vm-is-subroutine-call">SCP defines a pointer <code class="code highlight c docutils literal highlight-c"><span class="n">t_bool</span><span class="w"> </span><span class="o">*</span><span class="p">(</span><span class="n">sim_vm_is_subroutine_call</span><span class="p">)(</span><span class="n">t_addr</span><span class="w"> </span><span class="o">**</span><span class="n">ret_addrs</span><span class="p">)</span></code>.
This is initialized to <code class="code highlight c docutils literal highlight-c"><span class="nb">NULL</span></code>.
If filled in by the VM,
SCP will call the specified routine to determine where to dynamically place breakpoints to support the <code class="docutils literal notranslate"><span class="pre">NEXT</span></code> command.
The function return value is <code class="code highlight c docutils literal highlight-c"><span class="n">TRUE</span></code> if the next instruction is a subroutine call,
and argument <code class="docutils literal notranslate"><span class="pre">ret_addrs</span></code> is used to return the address of a zero-terminated array of addresses where breakpoints are to be set
(i.e., the possible return addresses for the subroutine being called).
The function return value is <code class="code highlight c docutils literal highlight-c"><span class="n">FALSE</span></code> and <code class="docutils literal notranslate"><span class="pre">ret_addrs</span></code> is unused if the next instruction is not a subroutine call.</p>
</section>
<section id="displaying-the-simulator-pc-value-in-debug-output">
<h4><span class="sectnum">1.5.4.7. </span>Displaying the simulator PC value in debug output<a class="headerlink" href="#displaying-the-simulator-pc-value-in-debug-output" title="Permalink to this heading">¶</a></h4>
<p>Some simulators expose the PC as a register,
some don’t expose it or expose a register which is not a variable that is updated during instruction execution
(i.e., only upon exit of <a class="reference internal" href="#sim-instr"><code class="docutils literal notranslate"><span class="pre">sim_instr()</span></code></a>).
For the <code class="docutils literal notranslate"><span class="pre">-P</span></code> debug option to be effective,
such a simulator should provide a routine which returns the value of the current PC and set the <code class="docutils literal notranslate"><span class="pre">sim_vm_pc_value</span></code> routine pointer to that routine.</p>
<p id="sim-vm-pc-value">SCP defines a pointer <code class="code highlight c docutils literal highlight-c"><span class="n">t_value</span><span class="w"> </span><span class="o">*</span><span class="p">(</span><span class="n">sim_vm_pc_value</span><span class="p">)(</span><span class="kt">void</span><span class="p">)</span></code>.
This is initialized to <code class="code highlight c docutils literal highlight-c"><span class="nb">NULL</span></code>.
If filled in by the VM,
SCP will call the specified routine to determine active PC value when generating debug output containing the execution PC
(if debug is enabled with the <code class="docutils literal notranslate"><span class="pre">-P</span></code> flag).</p>
</section>
</section>
</section>
<section id="other-scp-facilities">
<h2><span class="sectnum">1.6. </span>Other SCP facilities<a class="headerlink" href="#other-scp-facilities" title="Permalink to this heading">¶</a></h2>
<section id="terminal-input-output-formatting-library">
<h3><span class="sectnum">1.6.1. </span>Terminal input/output formatting library<a class="headerlink" href="#terminal-input-output-formatting-library" title="Permalink to this heading">¶</a></h3>
<p>SIMH provides routines to convert ASCII input characters to the format expected VM,
and to convert VM-supplied ASCII characters to C-standard format.
The routines are</p>
<dl class="simple" id="sim-tt-inpcvt">
<dt><code class="code highlight c docutils literal highlight-c"><span class="n">int32</span><span class="w"> </span><span class="n">sim_tt_inpcvt</span><span class="w"> </span><span class="p">(</span><span class="n">int32</span><span class="w"> </span><span class="n">c</span><span class="p">,</span><span class="w"> </span><span class="n">uint32</span><span class="w"> </span><span class="n">mode</span><span class="p">)</span></code></dt><dd><p>Convert input character <code class="docutils literal notranslate"><span class="pre">c</span></code> according to the <code class="docutils literal notranslate"><span class="pre">mode</span></code> specification and return the converted result
(<code class="docutils literal notranslate"><span class="pre">-1</span></code> if the character is not valid in the specified mode).</p>
</dd>
</dl>
<dl class="simple" id="sim-tt-outcvt">
<dt><code class="code highlight c docutils literal highlight-c"><span class="n">int32</span><span class="w"> </span><span class="n">sim_tt_outcvt</span><span class="w"> </span><span class="p">(</span><span class="n">int32</span><span class="w"> </span><span class="n">c</span><span class="p">,</span><span class="w"> </span><span class="n">uint32</span><span class="w"> </span><span class="n">mode</span><span class="p">)</span></code></dt><dd><p>Convert output character <code class="docutils literal notranslate"><span class="pre">c</span></code> according to the <code class="docutils literal notranslate"><span class="pre">mode</span></code> specification and return the converted result
(<code class="docutils literal notranslate"><span class="pre">-1</span></code> if the character is not valid in the specified mode).</p>
</dd>
</dl>
<p>The supported modes are:</p>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">TTUF_MODE_8B</span></code></p></td>
<td><p>8b mode; no conversion</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">TTUF_MODE_7B</span></code></p></td>
<td><p>7b mode; the high-order bit is masked off</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">TTUF_MODE_7P</span></code></p></td>
<td><p>7b printable mode; the high-order bit is masked off.
In addition, on output, if the character is not printable,
-1 is returned.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">TTUF_MODE_UC</span></code></p></td>
<td><p>7b upper case mode; the high-order bit is masked off.
In addition, lowercase is converted to uppercase
If the character is not printable, -1 is returned.</p></td>
</tr>
</tbody>
</table>
<p>On input, <code class="docutils literal notranslate"><span class="pre">TTUF_MODE_UC</span></code> has an additional modifier, <code class="docutils literal notranslate"><span class="pre">TTUF_MODE_KSR</span></code>,
which forces the high-order bit to be set rather than cleared.</p>
<p id="sim-tt-pchar">The set of printable control characters is contained in the global bit-vector variable <code class="docutils literal notranslate"><span class="pre">sim_tt_pchar</span></code>.
Each bit represents the character corresponding to the bit number
(e.g., bit <code class="docutils literal notranslate"><span class="pre">0</span></code> represents <code class="docutils literal notranslate"><span class="pre">NUL</span></code>, bit <code class="docutils literal notranslate"><span class="pre">1</span></code> represents <code class="docutils literal notranslate"><span class="pre">SOH</span></code>, etc).
If a bit is set, the corresponding control character is considered printable.
It initially contains the following characters: <code class="docutils literal notranslate"><span class="pre">BEL</span></code>, <code class="docutils literal notranslate"><span class="pre">BS</span></code>, <code class="docutils literal notranslate"><span class="pre">HT</span></code>, <code class="docutils literal notranslate"><span class="pre">LF</span></code>, and <code class="docutils literal notranslate"><span class="pre">CR</span></code>.
The set may be manipulated with these routines:</p>
<dl class="simple" id="sim-set-pchar">
<dt><code class="code highlight c docutils literal highlight-c"><span class="n">t_stat</span><span class="w"> </span><span class="n">sim_set_pchar</span><span class="w"> </span><span class="p">(</span><span class="n">int32</span><span class="w"> </span><span class="n">flag</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">cptr</span><span class="p">)</span></code></dt><dd><p>Set <code class="docutils literal notranslate"><span class="pre">sim_tt_pchar</span></code> to the value pointed to by <code class="docutils literal notranslate"><span class="pre">cptr</span></code>;
return <code class="docutils literal notranslate"><span class="pre">SCPE_2FARG</span></code> if <code class="docutils literal notranslate"><span class="pre">cptr</span></code> is null or points to a null string,
or <code class="docutils literal notranslate"><span class="pre">SCPE_ARG</span></code> if the value cannot be converted or does not contain at least <code class="docutils literal notranslate"><span class="pre">CR</span></code> and <code class="docutils literal notranslate"><span class="pre">LF</span></code>.
The string argument must be in the default radix of the current simulator.</p>
</dd>
</dl>
<dl class="simple" id="sim-show-pchar">
<dt><code class="code highlight c docutils literal highlight-c"><span class="n">t_stat</span><span class="w"> </span><span class="n">sim_show_pchar</span><span class="w"> </span><span class="p">(</span><span class="kt">FILE</span><span class="w"> </span><span class="o">*</span><span class="n">st</span><span class="p">,</span><span class="w"> </span><span class="n">DEVICE</span><span class="w"> </span><span class="o">*</span><span class="n">dptr</span><span class="p">,</span><span class="w"> </span><span class="n">UNIT</span><span class="w"> </span><span class="o">*</span><span class="n">uptr</span><span class="p">,</span><span class="w"> </span><span class="n">int32</span><span class="w"> </span><span class="n">flag</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">cptr</span><span class="p">)</span></code></dt><dd><p>Output the <code class="docutils literal notranslate"><span class="pre">sim_tt_pchar</span></code> value to the stream <code class="docutils literal notranslate"><span class="pre">st</span></code>.
The <code class="docutils literal notranslate"><span class="pre">sim_tt_pchar</span></code> value will be displayed in the default radix of the current simulator and character mnemonics for each set bit will also be displayed,</p>
</dd>
</dl>
<p>Note that the <code class="docutils literal notranslate"><span class="pre">DEL</span></code> character is always considered non-printable and will be suppressed in the <code class="docutils literal notranslate"><span class="pre">UC</span></code> and <code class="docutils literal notranslate"><span class="pre">7P</span></code> modes.</p>
<p>A simulator which will always want a specific set of printable characters defined should explicitly call <code class="docutils literal notranslate"><span class="pre">sim_set_pchar</span></code> the first time the simulator’s <code class="docutils literal notranslate"><span class="pre">cpu_reset</span></code> routine is called.</p>
<section id="terminal-multiplexer-emulation-library">
<h4><span class="sectnum">1.6.1.1. </span>Terminal multiplexer emulation library<a class="headerlink" href="#terminal-multiplexer-emulation-library" title="Permalink to this heading">¶</a></h4>
<p id="sim-sock-c"><span id="sim-serial-c"></span>SIMH supports the use of multiple terminals.
All terminals except the console are accessed via Telnet or serial ports on the host machine.
SIMH provides three supporting libraries for implementing multiple terminals:
<a class="reference internal" href="#sim-tmxr-c"><code class="docutils literal notranslate"><span class="pre">sim_tmxr.c</span></code></a> (and its header file, <code class="docutils literal notranslate"><span class="pre">sim_tmxr.h</span></code>),
which provide OS-independent support routines for terminal multiplexers;
<code class="docutils literal notranslate"><span class="pre">sim_serial.c</span></code> (and its header file <code class="docutils literal notranslate"><span class="pre">sim_serial.h</span></code>),
which provide OS-dependent serial I/O routines;
and <code class="docutils literal notranslate"><span class="pre">sim_sock.c</span></code> (and its header file, <code class="docutils literal notranslate"><span class="pre">sim_sock.h</span></code>),
which provide OS-dependent socket routines.
<code class="docutils literal notranslate"><span class="pre">sim_sock.c</span></code> and <code class="docutils literal notranslate"><span class="pre">sim_serial.c</span></code> are implemented under Windows, VMS, Unix, and macOS.</p>
<p id="tmln">Two basic data structures define the multiple terminals.
Individual lines are defined by an array of <code class="docutils literal notranslate"><span class="pre">tmln</span></code> structures (<code class="code highlight c docutils literal highlight-c"><span class="k">typedef</span><span class="w"> </span><span class="n">TMLN</span></code>):</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">tmln</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w">         </span><span class="n">conn</span><span class="p">;</span><span class="w">                </span><span class="cm">/* Line connected flag */</span>
<span class="w">    </span><span class="n">SOCKET</span><span class="w">      </span><span class="n">sock</span><span class="p">;</span><span class="w">                </span><span class="cm">/* Connection socket */</span>
<span class="w">    </span><span class="kt">char</span><span class="w">       </span><span class="o">*</span><span class="n">ipad</span><span class="p">;</span><span class="w">                </span><span class="cm">/* IP address */</span>
<span class="w">    </span><span class="n">SOCKET</span><span class="w">      </span><span class="n">master</span><span class="p">;</span><span class="w">              </span><span class="cm">/* Line specific master socket */</span>
<span class="w">    </span><span class="kt">char</span><span class="w">       </span><span class="o">*</span><span class="n">port</span><span class="p">;</span><span class="w">                </span><span class="cm">/* Line specific listening port */</span>
<span class="w">    </span><span class="n">int32</span><span class="w">       </span><span class="n">sessions</span><span class="p">;</span><span class="w">            </span><span class="cm">/* Count of TCP connections received */</span>
<span class="w">    </span><span class="n">uint32</span><span class="w">      </span><span class="n">cnms</span><span class="p">;</span><span class="w">                </span><span class="cm">/* Connect time ms */</span>
<span class="w">    </span><span class="n">int32</span><span class="w">       </span><span class="n">tsta</span><span class="p">;</span><span class="w">                </span><span class="cm">/* Telnet state */</span>
<span class="w">    </span><span class="n">int32</span><span class="w">       </span><span class="n">rcve</span><span class="p">;</span><span class="w">                </span><span class="cm">/* rcv enable */</span>
<span class="w">    </span><span class="n">int32</span><span class="w">       </span><span class="n">xmte</span><span class="p">;</span><span class="w">                </span><span class="cm">/* xmt enable */</span>
<span class="w">    </span><span class="n">int32</span><span class="w">       </span><span class="n">dstb</span><span class="p">;</span><span class="w">                </span><span class="cm">/* Disable Tlnt bin */</span>
<span class="w">    </span><span class="n">int32</span><span class="w">       </span><span class="n">notelnet</span><span class="p">;</span><span class="w">            </span><span class="cm">/* Raw binary data (no Telnet interpret) */</span>
<span class="w">    </span><span class="n">int32</span><span class="w">       </span><span class="n">rxbpr</span><span class="p">;</span><span class="w">               </span><span class="cm">/* rcv buf remove */</span>
<span class="w">    </span><span class="n">int32</span><span class="w">       </span><span class="n">rxbpi</span><span class="p">;</span><span class="w">               </span><span class="cm">/* rcv buf insert */</span>
<span class="w">    </span><span class="n">int32</span><span class="w">       </span><span class="n">rxcnt</span><span class="p">;</span><span class="w">               </span><span class="cm">/* rcv count */</span>
<span class="w">    </span><span class="n">int32</span><span class="w">       </span><span class="n">txbpr</span><span class="p">;</span><span class="w">               </span><span class="cm">/* xmt buf remove */</span>
<span class="w">    </span><span class="n">int32</span><span class="w">       </span><span class="n">txbpi</span><span class="p">;</span><span class="w">               </span><span class="cm">/* xmt buf insert */</span>
<span class="w">    </span><span class="n">int32</span><span class="w">       </span><span class="n">txcnt</span><span class="p">;</span><span class="w">               </span><span class="cm">/* xmt count */</span>
<span class="w">    </span><span class="n">int32</span><span class="w">       </span><span class="n">txdrp</span><span class="p">;</span><span class="w">               </span><span class="cm">/* xmt drop count */</span>
<span class="w">    </span><span class="n">int32</span><span class="w">       </span><span class="n">txbsz</span><span class="p">;</span><span class="w">               </span><span class="cm">/* xmt buffer size */</span>
<span class="w">    </span><span class="n">int32</span><span class="w">       </span><span class="n">txbfd</span><span class="p">;</span><span class="w">               </span><span class="cm">/* xmt buffered flag */</span>
<span class="w">    </span><span class="n">t_bool</span><span class="w">      </span><span class="n">modem_control</span><span class="p">;</span><span class="w">       </span><span class="cm">/* Line modem control support */</span>
<span class="w">    </span><span class="n">t_bool</span><span class="w">      </span><span class="n">port_speed_control</span><span class="p">;</span><span class="w">  </span><span class="cm">/* Line programmatically sets port speed */</span>
<span class="w">    </span><span class="n">int32</span><span class="w">       </span><span class="n">modembits</span><span class="p">;</span><span class="w">           </span><span class="cm">/* Modem bits which are set */</span>
<span class="w">    </span><span class="kt">FILE</span><span class="w">       </span><span class="o">*</span><span class="n">txlog</span><span class="p">;</span><span class="w">               </span><span class="cm">/* xmt log file */</span>
<span class="w">    </span><span class="n">FILEREF</span><span class="w">    </span><span class="o">*</span><span class="n">txlogref</span><span class="p">;</span><span class="w">            </span><span class="cm">/* xmt log file reference */</span>
<span class="w">    </span><span class="kt">char</span><span class="w">       </span><span class="o">*</span><span class="n">txlogname</span><span class="p">;</span><span class="w">           </span><span class="cm">/* xmt log filename */</span>
<span class="w">    </span><span class="kt">char</span><span class="w">        </span><span class="n">rxb</span><span class="p">[</span><span class="n">TMXR_MAXBUF</span><span class="p">];</span><span class="w">    </span><span class="cm">/* rcv buffer */</span>
<span class="w">    </span><span class="kt">char</span><span class="w">        </span><span class="n">rbr</span><span class="p">[</span><span class="n">TMXR_MAXBUF</span><span class="p">];</span><span class="w">    </span><span class="cm">/* rcv break */</span>
<span class="w">    </span><span class="kt">char</span><span class="w">       </span><span class="o">*</span><span class="n">txb</span><span class="p">;</span><span class="w">                 </span><span class="cm">/* xmt buffer */</span>
<span class="w">    </span><span class="n">TMXR</span><span class="w">       </span><span class="o">*</span><span class="n">mp</span><span class="p">;</span><span class="w">                  </span><span class="cm">/* Back pointer to mux */</span>
<span class="w">    </span><span class="kt">char</span><span class="w">       </span><span class="o">*</span><span class="n">serconfig</span><span class="p">;</span><span class="w">           </span><span class="cm">/* Line config */</span>
<span class="w">    </span><span class="n">SERHANDLE</span><span class="w">   </span><span class="n">serport</span><span class="p">;</span><span class="w">             </span><span class="cm">/* Serial port handle */</span>
<span class="w">    </span><span class="n">t_bool</span><span class="w">      </span><span class="n">ser_connect_pending</span><span class="p">;</span><span class="w"> </span><span class="cm">/* Serial connection notice pending */</span>
<span class="w">    </span><span class="n">SOCKET</span><span class="w">      </span><span class="n">connecting</span><span class="p">;</span><span class="w">          </span><span class="cm">/* Outgoing socket while connecting */</span>
<span class="w">    </span><span class="kt">char</span><span class="w">       </span><span class="o">*</span><span class="n">destination</span><span class="p">;</span><span class="w">         </span><span class="cm">/* Outgoing destination address:port */</span>
<span class="w">    </span><span class="n">UNIT</span><span class="w">       </span><span class="o">*</span><span class="n">uptr</span><span class="p">;</span><span class="w">                </span><span class="cm">/* Input polling unit -default to mp-&gt;uptr */</span>
<span class="w">    </span><span class="n">UNIT</span><span class="w">       </span><span class="o">*</span><span class="n">o_uptr</span><span class="p">;</span><span class="w">              </span><span class="cm">/* Output polling unit -default to lp-&gt;uptr */</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The fields are the following:</p>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">conn</span></code></p></td>
<td><p>Connection flag (<span class="math notranslate nohighlight">\(0 = \ \)</span>disconnected)</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">sock</span></code></p></td>
<td><p>Connection socket</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">ipad</span></code></p></td>
<td><p>IP address of remote end of connection</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">master</span></code></p></td>
<td><p>Optional line specific listening socket</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">port</span></code></p></td>
<td><p>Optional line specific listening port</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">sessions</span></code></p></td>
<td><p>Count of tcp connections received</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">cnms</span></code></p></td>
<td><p>Connect time</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">tsta</span></code></p></td>
<td><p>Telnet state</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">rcve</span></code></p></td>
<td><p>Receive enable flag (<span class="math notranslate nohighlight">\(0 = \ \)</span>disabled)</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">xmte</span></code></p></td>
<td><p>Transmit flow control flag (<span class="math notranslate nohighlight">\(0 = \ \)</span>transmit disabled)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">dstb</span></code></p></td>
<td><p>Telnet bin mode disabled</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">rxbpr</span></code></p></td>
<td><p>Receive buffer remove pointer</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">rxbpi</span></code></p></td>
<td><p>Receive buffer insert pointer</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">rxcnt</span></code></p></td>
<td><p>Receive count</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">txbpr</span></code></p></td>
<td><p>Transmit buffer remove pointer</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">txbpi</span></code></p></td>
<td><p>Transmit buffer insert pointer</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">txcnt</span></code></p></td>
<td><p>Transmit count</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">txlog</span></code></p></td>
<td><p>Pointer to log file descriptor</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">txlogname</span></code></p></td>
<td><p>Pointer to log filename</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">rxb</span></code></p></td>
<td><p>Receive buffer</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">rbr</span></code></p></td>
<td><p>Receive buffer break flags</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">txb</span></code></p></td>
<td><p>Transmit buffer</p></td>
</tr>
</tbody>
</table>
<p id="tmxr">The overall set of extra terminals is defined by the <code class="docutils literal notranslate"><span class="pre">tmxr</span></code> structure (<code class="code highlight c docutils literal highlight-c"><span class="k">typedef</span><span class="w"> </span><span class="n">TMXR</span></code>):</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">tmxr</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">int32</span><span class="w">    </span><span class="n">lines</span><span class="p">;</span><span class="w">                    </span><span class="cm">/* Number of lines */</span>
<span class="w">    </span><span class="kt">char</span><span class="w">    </span><span class="o">*</span><span class="n">port</span><span class="p">;</span><span class="w">                     </span><span class="cm">/* Listening port */</span>
<span class="w">    </span><span class="n">SOCKET</span><span class="w">   </span><span class="n">master</span><span class="p">;</span><span class="w">                   </span><span class="cm">/* Master socket */</span>
<span class="w">    </span><span class="n">TMLN</span><span class="w">    </span><span class="o">*</span><span class="n">ldsc</span><span class="p">;</span><span class="w">                     </span><span class="cm">/* Pointer to line descriptors */</span>
<span class="w">    </span><span class="n">int32</span><span class="w">   </span><span class="o">*</span><span class="n">lnorder</span><span class="p">;</span><span class="w">                  </span><span class="cm">/* Line connection order */</span>
<span class="w">    </span><span class="n">DEVICE</span><span class="w">  </span><span class="o">*</span><span class="n">dptr</span><span class="p">;</span><span class="w">                     </span><span class="cm">/* Multiplexer device */</span>
<span class="w">    </span><span class="n">UNIT</span><span class="w">    </span><span class="o">*</span><span class="n">uptr</span><span class="p">;</span><span class="w">                     </span><span class="cm">/* Polling unit (connection) */</span>
<span class="w">    </span><span class="kt">char</span><span class="w">     </span><span class="n">logfiletmpl</span><span class="p">[</span><span class="n">FILENAMEMAX</span><span class="p">];</span><span class="w"> </span><span class="cm">/* Template logfile name */</span>
<span class="w">    </span><span class="n">int23</span><span class="w">    </span><span class="n">buffered</span><span class="p">;</span><span class="w">                 </span><span class="cm">/* Buffered line behavior and buffer size*/</span>
<span class="w">    </span><span class="n">int32</span><span class="w">    </span><span class="n">sessions</span><span class="p">;</span><span class="w">                 </span><span class="cm">/* Count of TCP connections received */</span>
<span class="w">    </span><span class="n">uint32</span><span class="w">   </span><span class="n">last_poll_time</span><span class="p">;</span><span class="w">           </span><span class="cm">/* Time of last connection poll */</span>
<span class="w">    </span><span class="n">t_bool</span><span class="w">   </span><span class="n">notelnet</span><span class="p">;</span><span class="w">                 </span><span class="cm">/* Default Telnet capability for incoming connections */</span>
<span class="w">    </span><span class="n">t_bool</span><span class="w">   </span><span class="n">modem_control</span><span class="p">;</span><span class="w">            </span><span class="cm">/* Multiplexer supports modem control behaviors */</span>
<span class="w">    </span><span class="n">t_bool</span><span class="w">   </span><span class="n">port_speed_control</span><span class="p">;</span><span class="w">       </span><span class="cm">/* Multiplexer programmatically sets port speed */</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The fields are the following:</p>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">lines</span></code></p></td>
<td><p>Number of lines (constant)</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">port</span></code></p></td>
<td><p>Master listening port (specified by <code class="docutils literal notranslate"><span class="pre">ATTACH</span></code> command)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">master</span></code></p></td>
<td><p>Master listening socket (filled in by <code class="docutils literal notranslate"><span class="pre">ATTACH</span></code> command)</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">ldsc</span></code></p></td>
<td><p>Array of line descriptors</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">lnorder</span></code></p></td>
<td><p>Array of line numbers in order of connection sequence,
or <code class="code highlight c docutils literal highlight-c"><span class="nb">NULL</span></code> if user-defined connection order is not required</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">dptr</span></code></p></td>
<td><p>Pointer to the multiplexer’s <a class="reference internal" href="#device"><code class="docutils literal notranslate"><span class="pre">DEVICE</span></code></a> structure,
or <code class="code highlight c docutils literal highlight-c"><span class="nb">NULL</span></code> if the device is to be derived from the <a class="reference internal" href="#unit"><code class="docutils literal notranslate"><span class="pre">UNIT</span></code></a> passed to the attach call.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">uptr</span></code></p></td>
<td><p>The <a class="reference internal" href="#unit"><code class="docutils literal notranslate"><span class="pre">UNIT</span></code></a> passed to the attach call.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">logfiletmpl</span></code></p></td>
<td><p>Template logfile name used to create names for per-line log files.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">buffered</span></code></p></td>
<td><p>Buffered line behaviors enabled flag and the size of the line buffer.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">sessions</span></code></p></td>
<td><p>Count of TCP connections received on the master socket.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">last_poll_time</span></code></p></td>
<td><p>Time of last connection poll.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">notelnet</span></code></p></td>
<td><p>Default Telnet capability for TCP connections.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">modem_control</span></code></p></td>
<td><p>Flag indicating that multiplexer supports full modem control behaviors.</p></td>
</tr>
</tbody>
</table>
<p>The number of elements in the <code class="docutils literal notranslate"><span class="pre">ldsc</span></code> and <code class="docutils literal notranslate"><span class="pre">lnorder</span></code> arrays must equal the value of the <code class="docutils literal notranslate"><span class="pre">lines</span></code> field.
Set <code class="docutils literal notranslate"><span class="pre">lnorder</span></code> to <code class="code highlight c docutils literal highlight-c"><span class="nb">NULL</span></code> if the connection order feature is not needed.
If the first element of the <code class="docutils literal notranslate"><span class="pre">lnorder</span></code> array is -1,
then the default ascending sequential connection order is used.
Set <code class="docutils literal notranslate"><span class="pre">dptr</span></code> to <code class="code highlight c docutils literal highlight-c"><span class="nb">NULL</span></code> if the device should be derived from the unit passed to the <a class="reference internal" href="#tmxr-attach"><code class="docutils literal notranslate"><span class="pre">tmxr_attach</span></code></a> call.</p>
<p id="sim-tmxr"><span id="sim-tmxr-c"></span>Library <code class="docutils literal notranslate"><span class="pre">sim_tmxr.c</span></code> provides the following routines to support Telnet and serial port-based terminals:</p>
<dl class="simple" id="tmxr-poll-conn">
<dt><code class="code highlight c docutils literal highlight-c"><span class="n">int32</span><span class="w"> </span><span class="n">tmxr_poll_conn</span><span class="w"> </span><span class="p">(</span><span class="n">TMXR</span><span class="w"> </span><span class="o">*</span><span class="n">mp</span><span class="p">)</span></code></dt><dd><p>Poll for a new connection to the terminals described by <code class="docutils literal notranslate"><span class="pre">mp</span></code>.
If there is a new connection,
the routine resets all the line descriptor state
(including receive enable)
and returns the line number
(index to line descriptor)
for the new connection.
If there isn’t a new connection,
the routine returns -1.</p>
</dd>
</dl>
<dl class="simple" id="tmxr-reset-ln">
<dt><code class="code highlight c docutils literal highlight-c"><span class="kt">void</span><span class="w"> </span><span class="n">tmxr_reset_ln</span><span class="w"> </span><span class="p">(</span><span class="n">TMLN</span><span class="w"> </span><span class="o">*</span><span class="n">lp</span><span class="p">)</span></code></dt><dd><p>Reset the line described by <code class="docutils literal notranslate"><span class="pre">lp</span></code>.
The connection is closed and all line descriptor state is reset.</p>
</dd>
</dl>
<dl id="tmxr-getc-ln">
<dt><code class="code highlight c docutils literal highlight-c"><span class="n">int32</span><span class="w"> </span><span class="n">tmxr_getc_ln</span><span class="w"> </span><span class="p">(</span><span class="n">TMLN</span><span class="w"> </span><span class="o">*</span><span class="n">lp</span><span class="p">)</span></code></dt><dd><p>Return the next available character from the line described by <code class="docutils literal notranslate"><span class="pre">lp</span></code>.
If a character is available, the return value is:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">TMXR_V_VALID</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">character</span>
</pre></div>
</div>
<p>If a <code class="docutils literal notranslate"><span class="pre">BREAK</span></code> occurred on the line,
<code class="docutils literal notranslate"><span class="pre">SCPE_BREAK</span></code> will be OR’ed into the return variable.
If no character is available,
the return value is 0.</p>
</dd>
</dl>
<dl class="simple" id="tmxr-poll-rx">
<dt><code class="code highlight c docutils literal highlight-c"><span class="kt">void</span><span class="w"> </span><span class="n">tmxr_poll_rx</span><span class="w"> </span><span class="p">(</span><span class="n">TMXR</span><span class="w"> </span><span class="o">*</span><span class="n">mp</span><span class="p">)</span></code></dt><dd><p>Poll for input available on the terminals described by <code class="docutils literal notranslate"><span class="pre">mp</span></code>.</p>
</dd>
</dl>
<dl class="simple" id="tmxr-rqln">
<dt><code class="code highlight c docutils literal highlight-c"><span class="n">int32</span><span class="w"> </span><span class="n">tmxr_rqln</span><span class="w"> </span><span class="p">(</span><span class="n">TMLN</span><span class="w"> </span><span class="o">*</span><span class="n">lp</span><span class="p">)</span></code></dt><dd><p>Return the number of characters in the receive queue of the line described by <code class="docutils literal notranslate"><span class="pre">lp</span></code> which are ready to be read now.</p>
</dd>
</dl>
<dl class="simple" id="tmxr-putc-ln">
<dt><code class="code highlight c docutils literal highlight-c"><span class="n">t_stat</span><span class="w"> </span><span class="n">tmxr_putc_ln</span><span class="w"> </span><span class="p">(</span><span class="n">TMLN</span><span class="w"> </span><span class="o">*</span><span class="n">lp</span><span class="p">,</span><span class="w"> </span><span class="n">int32</span><span class="w"> </span><span class="n">chr</span><span class="p">)</span></code></dt><dd><p>Output character <code class="docutils literal notranslate"><span class="pre">chr</span></code> to the line described by <code class="docutils literal notranslate"><span class="pre">lp</span></code>.
Possible errors are <code class="docutils literal notranslate"><span class="pre">SCPE_LOST</span></code> (connection lost) and <code class="docutils literal notranslate"><span class="pre">SCPE_STALL</span></code> (connection backlogged).
If executed directly in instruction simulation code
(as opposed to during event processing)
and line output rate limiting is in effect,
then inter-character delays will occur before this routine returns.</p>
</dd>
</dl>
<dl class="simple" id="tmxr-poll-tx">
<dt><code class="code highlight c docutils literal highlight-c"><span class="kt">void</span><span class="w"> </span><span class="n">tmxr_poll_tx</span><span class="w"> </span><span class="p">(</span><span class="n">TMXR</span><span class="w"> </span><span class="o">*</span><span class="n">mp</span><span class="p">)</span></code></dt><dd><p>Poll for output complete on the terminals described by <code class="docutils literal notranslate"><span class="pre">mp</span></code>.</p>
</dd>
</dl>
<dl class="simple" id="tmxr-tqln">
<dt><code class="code highlight c docutils literal highlight-c"><span class="n">int32</span><span class="w"> </span><span class="n">tmxr_tqln</span><span class="w"> </span><span class="p">(</span><span class="n">TMLN</span><span class="w"> </span><span class="o">*</span><span class="n">lp</span><span class="p">)</span></code></dt><dd><p>Return the number of characters in the transmit queue of the line described by <code class="docutils literal notranslate"><span class="pre">lp</span></code>.</p>
</dd>
</dl>
<dl id="tmxr-txdone-ln">
<dt><code class="code highlight c docutils literal highlight-c"><span class="n">int32</span><span class="w"> </span><span class="n">tmxr_txdone_ln</span><span class="w"> </span><span class="p">(</span><span class="n">TMLN</span><span class="w"> </span><span class="o">*</span><span class="n">lp</span><span class="p">)</span></code></dt><dd><p>Return the transmit complete indicator for the the line described by <code class="docutils literal notranslate"><span class="pre">lp</span></code>:</p>
<table class="docutils align-left">
<tbody>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">0</span></code></p></td>
<td><p>Not done</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">1</span></code></p></td>
<td><p>Just now done</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">-1</span></code></p></td>
<td><p>Previously done</p></td>
</tr>
</tbody>
</table>
<p>When the <code class="docutils literal notranslate"><span class="pre">1</span></code> return value is returned would be a good time to pass an interrupt or other status information into the system being simulated.</p>
</dd>
</dl>
<dl class="simple" id="tmxr-send-buffered-data">
<dt><code class="code highlight c docutils literal highlight-c"><span class="kt">void</span><span class="w"> </span><span class="n">tmxr_send_buffered_data</span><span class="w"> </span><span class="p">(</span><span class="n">TMLN</span><span class="w"> </span><span class="o">*</span><span class="n">lp</span><span class="p">)</span></code></dt><dd><p>Flush any buffered data for the line described by <code class="docutils literal notranslate"><span class="pre">lp</span></code>.</p>
</dd>
</dl>
<dl class="simple" id="tmxr-attach">
<dt><code class="code highlight c docutils literal highlight-c"><span class="n">t_stat</span><span class="w"> </span><span class="n">tmxr_attach</span><span class="w"> </span><span class="p">(</span><span class="n">TMXR</span><span class="w"> </span><span class="o">*</span><span class="n">mp</span><span class="p">,</span><span class="w"> </span><span class="n">UNIT</span><span class="w"> </span><span class="o">*</span><span class="n">uptr</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">cptr</span><span class="p">)</span></code></dt><dd><p>Attach the port contained in character string <code class="docutils literal notranslate"><span class="pre">cptr</span></code> to the terminals described by <code class="docutils literal notranslate"><span class="pre">mp</span></code> and unit <code class="docutils literal notranslate"><span class="pre">uptr</span></code>.</p>
</dd>
</dl>
<dl class="simple" id="tmxr-open-master">
<dt><code class="code highlight c docutils literal highlight-c"><span class="n">t_stat</span><span class="w"> </span><span class="n">tmxr_open_master</span><span class="w"> </span><span class="p">(</span><span class="n">TMXR</span><span class="w"> </span><span class="o">*</span><span class="n">mp</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">cptr</span><span class="p">)</span></code></dt><dd><p>Associate the port contained in character string <code class="docutils literal notranslate"><span class="pre">cptr</span></code> to the terminals described by <code class="docutils literal notranslate"><span class="pre">mp</span></code>.
This routine is a subset of <code class="docutils literal notranslate"><span class="pre">tmxr_attach</span></code>.</p>
</dd>
</dl>
<dl class="simple" id="tmxr-detach">
<dt><code class="code highlight c docutils literal highlight-c"><span class="n">t_stat</span><span class="w"> </span><span class="n">tmxr_detach</span><span class="w"> </span><span class="p">(</span><span class="n">TMXR</span><span class="w"> </span><span class="o">*</span><span class="n">mp</span><span class="p">,</span><span class="w"> </span><span class="n">UNIT</span><span class="w"> </span><span class="o">*</span><span class="n">uptr</span><span class="p">)</span></code></dt><dd><p>Detach all connections for the terminals described by <code class="docutils literal notranslate"><span class="pre">mp</span></code> and unit <code class="docutils literal notranslate"><span class="pre">uptr</span></code>.</p>
</dd>
</dl>
<dl class="simple" id="tmxr-close-master">
<dt><code class="code highlight c docutils literal highlight-c"><span class="n">t_stat</span><span class="w"> </span><span class="n">tmxr_close_master</span><span class="w"> </span><span class="p">(</span><span class="n">TMXR</span><span class="w"> </span><span class="o">*</span><span class="n">mp</span><span class="p">)</span></code></dt><dd><p>Close the master port for the terminals described by <code class="docutils literal notranslate"><span class="pre">mp</span></code>.
This routine is a subset of <code class="docutils literal notranslate"><span class="pre">tmxr_detach</span></code>.</p>
</dd>
</dl>
<dl class="simple" id="tmxr-ex">
<dt><code class="code highlight c docutils literal highlight-c"><span class="n">t_stat</span><span class="w"> </span><span class="n">tmxr_ex</span><span class="w"> </span><span class="p">(</span><span class="n">t_value</span><span class="w"> </span><span class="o">*</span><span class="n">vptr</span><span class="p">,</span><span class="w"> </span><span class="n">t_addr</span><span class="w"> </span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="n">UNIT</span><span class="w"> </span><span class="o">*</span><span class="n">uptr</span><span class="p">,</span><span class="w"> </span><span class="n">int32</span><span class="w"> </span><span class="n">sw</span><span class="p">)</span></code></dt><dd><p>Stub examine routine,
needed because the extra terminals are marked as attached;
always returns an error.</p>
</dd>
</dl>
<dl class="simple" id="tmxr-dep">
<dt><code class="code highlight c docutils literal highlight-c"><span class="n">t_stat</span><span class="w"> </span><span class="n">tmxr_dep</span><span class="w"> </span><span class="p">(</span><span class="n">t_value</span><span class="w"> </span><span class="n">val</span><span class="p">,</span><span class="w"> </span><span class="n">t_addr</span><span class="w"> </span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="n">UNIT</span><span class="w"> </span><span class="o">*</span><span class="n">uptr</span><span class="p">,</span><span class="w"> </span><span class="n">int32</span><span class="w"> </span><span class="n">sw</span><span class="p">)</span></code></dt><dd><p>Stub deposit routine,
needed because the extra terminals are marked as detached;
always returns an error.</p>
</dd>
</dl>
<dl class="simple" id="tmxr-msg">
<dt><code class="code highlight c docutils literal highlight-c"><span class="kt">void</span><span class="w"> </span><span class="n">tmxr_msg</span><span class="w"> </span><span class="p">(</span><span class="n">SOCKET</span><span class="w"> </span><span class="n">sock</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">msg</span><span class="p">)</span></code></dt><dd><p>Output character string <code class="docutils literal notranslate"><span class="pre">msg</span></code> to socket <code class="docutils literal notranslate"><span class="pre">sock</span></code>.</p>
</dd>
</dl>
<dl class="simple" id="tmxr-linemsg">
<dt><code class="code highlight c docutils literal highlight-c"><span class="kt">void</span><span class="w"> </span><span class="n">tmxr_linemsg</span><span class="w"> </span><span class="p">(</span><span class="n">TMLN</span><span class="w"> </span><span class="o">*</span><span class="n">lp</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">msg</span><span class="p">)</span></code></dt><dd><p>Output character string <code class="docutils literal notranslate"><span class="pre">msg</span></code> to line <code class="docutils literal notranslate"><span class="pre">lp</span></code>.</p>
</dd>
</dl>
<dl class="simple" id="tmxr-linemsgf">
<dt><code class="code highlight c docutils literal highlight-c"><span class="kt">void</span><span class="w"> </span><span class="n">tmxr_linemsgf</span><span class="w"> </span><span class="p">(</span><span class="n">TMLN</span><span class="w"> </span><span class="o">*</span><span class="n">lp</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">fmt</span><span class="p">,</span><span class="w"> </span><span class="p">...)</span></code></dt><dd><p>Output formatted <code class="docutils literal notranslate"><span class="pre">msg</span></code> to line <code class="docutils literal notranslate"><span class="pre">lp</span></code>.</p>
</dd>
</dl>
<dl class="simple" id="tmxr-fconns">
<dt><code class="code highlight c docutils literal highlight-c"><span class="kt">void</span><span class="w"> </span><span class="n">tmxr_fconns</span><span class="w"> </span><span class="p">(</span><span class="kt">FILE</span><span class="w"> </span><span class="o">*</span><span class="n">st</span><span class="p">,</span><span class="w"> </span><span class="n">TMLN</span><span class="w"> </span><span class="o">*</span><span class="n">lp</span><span class="p">,</span><span class="w"> </span><span class="n">int32</span><span class="w"> </span><span class="n">ln</span><span class="p">)</span></code></dt><dd><p>Output connection status to stream <code class="docutils literal notranslate"><span class="pre">st</span></code> for the line described by <code class="docutils literal notranslate"><span class="pre">lp</span></code>.
If <code class="docutils literal notranslate"><span class="pre">ln</span></code> is <span class="math notranslate nohighlight">\(&gt;= 0\)</span>,
preface the output with the specified line number.</p>
</dd>
</dl>
<dl class="simple" id="tmxr-fstats">
<dt><code class="code highlight c docutils literal highlight-c"><span class="kt">void</span><span class="w"> </span><span class="n">tmxr_fstats</span><span class="w"> </span><span class="p">(</span><span class="kt">FILE</span><span class="w"> </span><span class="o">*</span><span class="n">st</span><span class="p">,</span><span class="w"> </span><span class="n">TMLN</span><span class="w"> </span><span class="o">*</span><span class="n">lp</span><span class="p">,</span><span class="w"> </span><span class="n">int32</span><span class="w"> </span><span class="n">ln</span><span class="p">)</span></code></dt><dd><p>Output connection statistics to stream <code class="docutils literal notranslate"><span class="pre">st</span></code> for the line described by <code class="docutils literal notranslate"><span class="pre">lp</span></code>.
If <code class="docutils literal notranslate"><span class="pre">ln</span></code> is <span class="math notranslate nohighlight">\(&gt;= 0\)</span>,
preface the output with the specified line number.</p>
</dd>
</dl>
<dl class="simple" id="tmxr-set-log">
<dt><code class="code highlight c docutils literal highlight-c"><span class="n">tstat</span><span class="w"> </span><span class="n">tmxr_set_log</span><span class="w"> </span><span class="p">(</span><span class="n">UNIT</span><span class="w"> </span><span class="o">*</span><span class="n">uptr</span><span class="p">,</span><span class="w"> </span><span class="n">int32</span><span class="w"> </span><span class="n">val</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">cptr</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">mp</span><span class="p">)</span></code></dt><dd><p>Enable logging of a line of the multipleser described by <code class="docutils literal notranslate"><span class="pre">mp</span></code> to the filename pointed to by <code class="docutils literal notranslate"><span class="pre">cptr</span></code>.
If <code class="docutils literal notranslate"><span class="pre">uptr</span></code> is <code class="code highlight c docutils literal highlight-c"><span class="nb">NULL</span></code>,
then <code class="docutils literal notranslate"><span class="pre">val</span></code> indicates the line number;
otherwise, the unit number within the associated device implies the line number.
This function may be used as an <a class="reference internal" href="#mtab"><code class="docutils literal notranslate"><span class="pre">MTAB</span></code></a> validation routine.</p>
</dd>
</dl>
<dl class="simple" id="tmxr-set-nolog">
<dt><code class="code highlight c docutils literal highlight-c"><span class="n">tstat</span><span class="w"> </span><span class="n">tmxr_set_nolog</span><span class="w"> </span><span class="p">(</span><span class="n">UNIT</span><span class="w"> </span><span class="o">*</span><span class="n">uptr</span><span class="p">,</span><span class="w"> </span><span class="n">int32</span><span class="w"> </span><span class="n">val</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">cptr</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">mp</span><span class="p">)</span></code></dt><dd><p>Disable logging of a line of the multipleser described by <code class="docutils literal notranslate"><span class="pre">mp</span></code> to the filename pointed to by <code class="docutils literal notranslate"><span class="pre">cptr</span></code>.
If <code class="docutils literal notranslate"><span class="pre">uptr</span></code> is <code class="code highlight c docutils literal highlight-c"><span class="nb">NULL</span></code>,
then <code class="docutils literal notranslate"><span class="pre">val</span></code> indicates the line number;
otherwise, the unit number within the associated device implies the line number.
This function may be used as an <a class="reference internal" href="#mtab"><code class="docutils literal notranslate"><span class="pre">MTAB</span></code></a> validation routine.</p>
</dd>
</dl>
<dl class="simple" id="tmxr-show-log">
<dt><code class="code highlight c docutils literal highlight-c"><span class="n">tstat</span><span class="w"> </span><span class="n">tmxr_show_log</span><span class="w"> </span><span class="p">(</span><span class="kt">FILE</span><span class="w"> </span><span class="o">*</span><span class="n">st</span><span class="p">,</span><span class="w"> </span><span class="n">UNIT</span><span class="w"> </span><span class="o">*</span><span class="n">uptr</span><span class="p">,</span><span class="w"> </span><span class="n">int32</span><span class="w"> </span><span class="n">val</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">mp</span><span class="p">)</span></code></dt><dd><p>Output the logging status of a line of the multiplexer described by <code class="docutils literal notranslate"><span class="pre">mp</span></code> to stream <code class="docutils literal notranslate"><span class="pre">st</span></code>.
If <code class="docutils literal notranslate"><span class="pre">uptr</span></code> is <code class="code highlight c docutils literal highlight-c"><span class="nb">NULL</span></code>,
then <code class="docutils literal notranslate"><span class="pre">val</span></code> indicates the line number;
otherwise, the unit number within the associated device implies the line number.
This function may be used as an <a class="reference internal" href="#mtab"><code class="docutils literal notranslate"><span class="pre">MTAB</span></code></a> display routine.</p>
</dd>
</dl>
<dl class="simple" id="tmxr-dscln">
<dt><code class="code highlight c docutils literal highlight-c"><span class="n">t_stat</span><span class="w"> </span><span class="n">tmxr_dscln</span><span class="w"> </span><span class="p">(</span><span class="n">UNIT</span><span class="w"> </span><span class="o">*</span><span class="n">uptr</span><span class="p">,</span><span class="w"> </span><span class="n">int32</span><span class="w"> </span><span class="n">val</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">cptr</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">mp</span><span class="p">)</span></code></dt><dd><p>Parse the string pointed to by <code class="docutils literal notranslate"><span class="pre">cptr</span></code> for a decimal line number.
If the line number is valid, disconnect the specified line in the terminal multiplexer described by <code class="docutils literal notranslate"><span class="pre">mp</span></code>.
The calling sequence allows <code class="docutils literal notranslate"><span class="pre">tmxr_dscln</span></code> to be used as an <a class="reference internal" href="#mtab"><code class="docutils literal notranslate"><span class="pre">MTAB</span></code></a> processing routine.
A line connected via a TCP session will be disconnected,
a line connected to a serial port will be closed if the <code class="docutils literal notranslate"><span class="pre">sim_switches</span></code> <code class="docutils literal notranslate"><span class="pre">-C</span></code> flag is enabled when the routine is called,
otherwise a serial port will have DTR dropped for 500ms and raised again.</p>
</dd>
</dl>
<dl id="tmxr-set-lnorder">
<dt><code class="code highlight c docutils literal highlight-c"><span class="n">t_stat</span><span class="w"> </span><span class="n">tmxr_set_lnorder</span><span class="w"> </span><span class="p">(</span><span class="n">UNIT</span><span class="w"> </span><span class="o">*</span><span class="n">uptr</span><span class="p">,</span><span class="w"> </span><span class="n">int32</span><span class="w"> </span><span class="n">val</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">cptr</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">desc</span><span class="p">)</span></code></dt><dd><p>Set the line connection order array associated with the <a class="reference internal" href="#tmxr"><code class="docutils literal notranslate"><span class="pre">TMXR</span></code></a> structure pointed to by <code class="docutils literal notranslate"><span class="pre">desc</span></code>.
The string pointed to by <code class="docutils literal notranslate"><span class="pre">cptr</span></code> is parsed for a semicolon-delimited list of ranges.  Ranges are of the form:</p>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">line1-line2</span></code></p></td>
<td><p>Ascending sequence from <code class="docutils literal notranslate"><span class="pre">line1</span></code> to <code class="docutils literal notranslate"><span class="pre">line2</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">line1/length</span></code></p></td>
<td><p>Ascending sequence from <code class="docutils literal notranslate"><span class="pre">line1</span></code> to <code class="docutils literal notranslate"><span class="pre">line1</span></code>+<code class="docutils literal notranslate"><span class="pre">length</span></code>-1</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">ALL</span></code></p></td>
<td><p>Ascending sequence of all lines defined by the multiplexer</p></td>
</tr>
</tbody>
</table>
<p>The line order array must provide an <code class="code highlight c docutils literal highlight-c"><span class="n">int32</span></code> element for each line.
The calling sequence allows <code class="docutils literal notranslate"><span class="pre">tmxr_set_lnorder</span></code> to be used as an <a class="reference internal" href="#mtab"><code class="docutils literal notranslate"><span class="pre">MTAB</span></code></a> processing routine.</p>
</dd>
</dl>
<dl class="simple" id="tmxr-show-lnorder">
<dt><code class="code highlight c docutils literal highlight-c"><span class="n">t_stat</span><span class="w"> </span><span class="n">tmxr_show_lnorder</span><span class="w"> </span><span class="p">(</span><span class="kt">FILE</span><span class="w"> </span><span class="o">*</span><span class="n">st</span><span class="p">,</span><span class="w"> </span><span class="n">UNIT</span><span class="w"> </span><span class="o">*</span><span class="n">uptr</span><span class="p">,</span><span class="w"> </span><span class="n">int32</span><span class="w"> </span><span class="n">val</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">desc</span><span class="p">)</span></code></dt><dd><p>Output the line connection order associated multiplexer <code class="code highlight c docutils literal highlight-c"><span class="p">(</span><span class="n">TMXR</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="n">desc</span></code> to stream <code class="docutils literal notranslate"><span class="pre">st</span></code>.
The order is rendered as a semicolon-delimited list of ranges.
The calling sequence allows <code class="docutils literal notranslate"><span class="pre">tmxr_show_lnorder</span></code> to be used as an <a class="reference internal" href="#mtab"><code class="docutils literal notranslate"><span class="pre">MTAB</span></code></a> processing routine.</p>
</dd>
</dl>
<dl class="simple" id="tmxr-show-summ">
<dt><code class="code highlight c docutils literal highlight-c"><span class="n">t_stat</span><span class="w"> </span><span class="n">tmxr_show_summ</span><span class="w"> </span><span class="p">(</span><span class="kt">FILE</span><span class="w"> </span><span class="o">*</span><span class="n">st</span><span class="p">,</span><span class="w"> </span><span class="n">UNIT</span><span class="w"> </span><span class="o">*</span><span class="n">uptr</span><span class="p">,</span><span class="w"> </span><span class="n">int32</span><span class="w"> </span><span class="n">val</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">desc</span><span class="p">)</span></code></dt><dd><p>Output the summary status of the multiplexer <code class="code highlight c docutils literal highlight-c"><span class="p">(</span><span class="n">TMXR</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="n">desc</span></code> to stream <code class="docutils literal notranslate"><span class="pre">st</span></code>.</p>
</dd>
</dl>
<dl class="simple" id="tmxr-show-cstat">
<dt><code class="code highlight c docutils literal highlight-c"><span class="n">t_stat</span><span class="w"> </span><span class="n">tmxr_show_cstat</span><span class="w"> </span><span class="p">(</span><span class="kt">FILE</span><span class="w"> </span><span class="o">*</span><span class="n">st</span><span class="p">,</span><span class="w"> </span><span class="n">UNIT</span><span class="w"> </span><span class="o">*</span><span class="n">uptr</span><span class="p">,</span><span class="w"> </span><span class="n">int32</span><span class="w"> </span><span class="n">val</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">desc</span><span class="p">)</span></code></dt><dd><p>Output either the connections (<code class="docutils literal notranslate"><span class="pre">val</span></code><span class="math notranslate nohighlight">\(\ = 1\)</span>)
or the statistics (<code class="docutils literal notranslate"><span class="pre">val</span></code><span class="math notranslate nohighlight">\(\ = 0\)</span>)
of the multiplexer <code class="code highlight c docutils literal highlight-c"><span class="p">(</span><span class="n">TMXR</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="n">desc</span></code> to stream <code class="docutils literal notranslate"><span class="pre">st</span></code>.
Also check for multiplexer not attached,
or all lines disconnected.</p>
</dd>
</dl>
<dl class="simple" id="tmxr-show-lines">
<dt><code class="code highlight c docutils literal highlight-c"><span class="n">t_stat</span><span class="w"> </span><span class="n">tmxr_show_lines</span><span class="w"> </span><span class="p">(</span><span class="kt">FILE</span><span class="w"> </span><span class="o">*</span><span class="n">st</span><span class="p">,</span><span class="w"> </span><span class="n">UNIT</span><span class="w"> </span><span class="o">*</span><span class="n">uptr</span><span class="p">,</span><span class="w"> </span><span class="n">int32</span><span class="w"> </span><span class="n">val</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">desc</span><span class="p">)</span></code></dt><dd><p>Output the number of lines in the terminal multiplexer <code class="code highlight c docutils literal highlight-c"><span class="p">(</span><span class="n">TMXR</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="n">I</span></code> to stream <code class="docutils literal notranslate"><span class="pre">I</span></code>.</p>
</dd>
</dl>
<dl class="simple" id="tmxr-set-modem-control-passthru">
<dt><code class="code highlight c docutils literal highlight-c"><span class="n">t_stat</span><span class="w"> </span><span class="n">tmxr_set_modem_control_passthru</span><span class="w"> </span><span class="p">(</span><span class="n">TMXR</span><span class="w"> </span><span class="o">*</span><span class="n">mp</span><span class="p">)</span></code></dt><dd><p>Enable modem control passthru behaviors,
and disable internal manipulation of DTR (&amp;RTS) by <code class="docutils literal notranslate"><span class="pre">tmxr</span></code> APIs.
Enable the <a class="reference internal" href="#tmxr-set-get-modem-bits"><code class="docutils literal notranslate"><span class="pre">tmxr_set_get_modem_bits</span></code></a> and <a class="reference internal" href="#tmxr-set-config-line"><code class="docutils literal notranslate"><span class="pre">tmxr_set_config_line</span></code></a> APIs.</p>
</dd>
</dl>
<dl class="simple" id="tmxr-clear-modem-control-passthru">
<dt><code class="code highlight c docutils literal highlight-c"><span class="n">t_stat</span><span class="w"> </span><span class="n">tmxr_clear_modem_control_passthru</span><span class="w"> </span><span class="p">(</span><span class="n">TMXR</span><span class="w"> </span><span class="o">*</span><span class="n">mp</span><span class="p">)</span></code></dt><dd><p>Disable modem control passthru behaviors,
and enable internal manipulation of DTR (&amp;RTS) by <code class="docutils literal notranslate"><span class="pre">tmxr</span></code> APIs.
Disable the <a class="reference internal" href="#tmxr-set-get-modem-bits"><code class="docutils literal notranslate"><span class="pre">tmxr_set_get_modem_bits</span></code></a> and <a class="reference internal" href="#tmxr-set-config-line"><code class="docutils literal notranslate"><span class="pre">tmxr_set_config_line</span></code></a> APIs.</p>
</dd>
</dl>
<dl class="simple" id="tmxr-set-port-speed-control">
<dt><code class="code highlight c docutils literal highlight-c"><span class="n">t_stat</span><span class="w"> </span><span class="n">tmxr_set_port_speed_control</span><span class="w"> </span><span class="p">(</span><span class="n">TMXR</span><span class="w"> </span><span class="o">*</span><span class="n">mp</span><span class="p">)</span></code></dt><dd><p>Declares that the device which interfaces the specified <a class="reference internal" href="#tmxr"><code class="docutils literal notranslate"><span class="pre">TMXR</span></code></a> uses the <a class="reference internal" href="#tmxr-set-config-line"><code class="docutils literal notranslate"><span class="pre">tmxr_set_config_line</span></code></a> API to set the port line speed.
This declaration should be made in the device reset routine and called before any line attachments are made.</p>
</dd>
</dl>
<dl class="simple" id="tmxr-clear-port-speed-control">
<dt><code class="code highlight c docutils literal highlight-c"><span class="n">t_stat</span><span class="w"> </span><span class="n">tmxr_clear_port_speed_control</span><span class="w"> </span><span class="p">(</span><span class="n">TMXR</span><span class="w"> </span><span class="o">*</span><span class="n">mp</span><span class="p">)</span></code></dt><dd><p>Declares that the device which interfaces the specified <a class="reference internal" href="#tmxr"><code class="docutils literal notranslate"><span class="pre">TMXR</span></code></a> does not use the <a class="reference internal" href="#tmxr-set-config-line"><code class="docutils literal notranslate"><span class="pre">tmxr_set_config_line</span></code></a> API to set the port line speed.
This declaration should only be necessary if <a class="reference internal" href="#tmxr-set-port-speed-control"><code class="docutils literal notranslate"><span class="pre">tmxr_set_port_speed_control</span></code></a> had been called previously.
It will fail if any line attachments are active.</p>
</dd>
</dl>
<dl class="simple" id="tmxr-set-line-port-speed-control">
<dt><code class="code highlight c docutils literal highlight-c"><span class="n">t_stat</span><span class="w"> </span><span class="n">tmxr_set_line_port_speed_control</span><span class="w"> </span><span class="p">(</span><span class="n">TMXR</span><span class="w"> </span><span class="o">*</span><span class="n">mp</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">line</span><span class="p">)</span></code></dt><dd><p>Declares that the device which interfaces the specified <a class="reference internal" href="#tmxr"><code class="docutils literal notranslate"><span class="pre">TMXR</span></code></a> uses the <a class="reference internal" href="#tmxr-set-config-line"><code class="docutils literal notranslate"><span class="pre">tmxr_set_config_line</span></code></a> API to set the port line speed for the specified line.
This declaration should be made in the device reset routine and called before any line attachments are made.</p>
</dd>
</dl>
<dl class="simple" id="tmxr-clear-line-port-speed-control">
<dt><code class="code highlight c docutils literal highlight-c"><span class="n">t_stat</span><span class="w"> </span><span class="n">tmxr_clear_line_port_speed_control</span><span class="w"> </span><span class="p">(</span><span class="n">TMXR</span><span class="w"> </span><span class="o">*</span><span class="n">mp</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">line</span><span class="p">)</span></code></dt><dd><p>Declares that the device which interfaces the specified <a class="reference internal" href="#tmxr"><code class="docutils literal notranslate"><span class="pre">TMXR</span></code></a> does not use the <a class="reference internal" href="#tmxr-set-config-line"><code class="docutils literal notranslate"><span class="pre">tmxr_set_config_line</span></code></a> API to set the port line speed for the specified line.
This declaration should only be necessary if <a class="reference internal" href="#tmxr-set-port-speed-control"><code class="docutils literal notranslate"><span class="pre">tmxr_set_port_speed_control</span></code></a> had been called previously.
It will fail if any line attachments are active.</p>
</dd>
</dl>
<dl class="simple" id="tmxr-set-get-modem-bits">
<dt><code class="code highlight c docutils literal highlight-c"><span class="n">t_stat</span><span class="w"> </span><span class="n">tmxr_set_get_modem_bits</span><span class="w"> </span><span class="p">(</span><span class="n">TMLN</span><span class="w"> </span><span class="o">*</span><span class="n">lp</span><span class="p">,</span><span class="w"> </span><span class="n">int32</span><span class="w"> </span><span class="n">bits_to_set</span><span class="p">,</span><span class="w"> </span><span class="n">int32</span><span class="w"> </span><span class="n">bits_to_clear</span><span class="p">,</span><span class="w"> </span><span class="n">int32</span><span class="w"> </span><span class="o">*</span><span class="n">incoming_bits</span><span class="p">)</span></code></dt><dd><p>For a line connected to a serial port on a <a class="reference internal" href="#tmxr"><code class="docutils literal notranslate"><span class="pre">TMXR</span></code></a> device with <code class="docutils literal notranslate"><span class="pre">modem_control_passthru</span></code> enabled,
then the <code class="docutils literal notranslate"><span class="pre">bits_to_set</span></code> and/or <code class="docutils literal notranslate"><span class="pre">bits_to_clear</span></code> (DTR and RTS) are changed and if <code class="docutils literal notranslate"><span class="pre">incoming_bits</span></code> is not <code class="code highlight c docutils literal highlight-c"><span class="nb">NULL</span></code>,
then the current modem bits are returned (DCD, RNG, CTS, DSR).</p>
</dd>
</dl>
<dl class="simple" id="tmxr-set-config-line">
<dt><code class="code highlight c docutils literal highlight-c"><span class="n">t_stat</span><span class="w"> </span><span class="n">tmxr_set_config_line</span><span class="w"> </span><span class="p">(</span><span class="n">TMLN</span><span class="w"> </span><span class="o">*</span><span class="n">lp</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">config</span><span class="p">)</span></code></dt><dd><p>Sets the line configuration (speed, parity, character size, stopbits) on a serial port.  Config is a string of the form: <code class="docutils literal notranslate"><span class="pre">9600-8N1</span></code>.</p>
</dd>
</dl>
<dl class="simple" id="tmxr-set-line-unit">
<dt><code class="code highlight c docutils literal highlight-c"><span class="n">t_stat</span><span class="w"> </span><span class="n">tmxr_set_line_unit</span><span class="w"> </span><span class="p">(</span><span class="n">TMXR</span><span class="w"> </span><span class="o">*</span><span class="n">mp</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">line</span><span class="p">,</span><span class="w"> </span><span class="n">UNIT</span><span class="w"> </span><span class="o">*</span><span class="n">uptr</span><span class="p">)</span></code></dt><dd><p>Declare which unit polls for input on a given line.
Only needed if the input polling unit is different than the unit provided when the multiplexer was attached.</p>
</dd>
</dl>
<dl class="simple" id="tmxr-set-line-output-unit">
<dt><code class="code highlight c docutils literal highlight-c"><span class="n">t_stat</span><span class="w"> </span><span class="n">tmxr_set_line_output_unit</span><span class="w"> </span><span class="p">(</span><span class="n">TMXR</span><span class="w"> </span><span class="o">*</span><span class="n">mp</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">line</span><span class="p">,</span><span class="w"> </span><span class="n">UNIT</span><span class="w"> </span><span class="o">*</span><span class="n">uptr</span><span class="p">)</span></code></dt><dd><p>Declare which unit polls for output on a given line.
Only needed if the output polling unit is different than the unit provided when the multiplexer was attached.</p>
</dd>
</dl>
<p>The OS dependent serial I/O and socket routines should not be accessed by the terminal simulators.
The routines provided by <a class="reference internal" href="#sim-sock-c"><code class="docutils literal notranslate"><span class="pre">sim_sock.c</span></code></a> and <a class="reference internal" href="#sim-serial-c"><code class="docutils literal notranslate"><span class="pre">sim_serial.c</span></code></a> are for internal use by the <code class="docutils literal notranslate"><span class="pre">TMXR</span></code> library only and should be not be used directly by any simulator.</p>
</section>
</section>
<section id="magnetic-tape-emulation-library">
<h3><span class="sectnum">1.6.2. </span>Magnetic tape emulation library<a class="headerlink" href="#magnetic-tape-emulation-library" title="Permalink to this heading">¶</a></h3>
<p>SIMH supports the use of emulated magnetic tapes.
Magnetic tapes are emulated as disk files containing both data records and metadata markers;
the format is fully described in the paper
<a class="reference external" href="simh_magtape.rst">SIMH Magtape Representation and Handling</a>.
SIMH provides a supporting library,
<a class="reference internal" href="#sim-tape-c"><code class="docutils literal notranslate"><span class="pre">sim_tape.c</span></code></a> (and its header file, <code class="docutils literal notranslate"><span class="pre">sim_tape.h</span></code>),
that abstracts handling of magnetic tapes.
This allows support for multiple tape formats,
without change to magnetic device simulators.</p>
<p>The magtape library does not require any special data structures.
However, it does define some additional unit flags:</p>
<blockquote>
<div><table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">MTUF_WLK</span></code></p></td>
<td><p>Unit is write-locked</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>If magtape simulators need to define private unit flags,
those flags should begin at bit number <code class="docutils literal notranslate"><span class="pre">MTUF_V_UF</span></code> instead of <code class="docutils literal notranslate"><span class="pre">UNIT_V_UF</span></code>.
The magtape library maintains the current magtape position in the <code class="docutils literal notranslate"><span class="pre">pos</span></code> field of the <a class="reference internal" href="#unit"><code class="docutils literal notranslate"><span class="pre">UNIT</span></code></a> structure.</p>
<p id="sim-tape"><span id="sim-tape-c"></span>Library <code class="docutils literal notranslate"><span class="pre">sim_tape.c</span></code> provides the following routines to support emulated magnetic tapes.
These are declared in header file <code class="docutils literal notranslate"><span class="pre">sim_tape.h</span></code>.</p>
<dl class="simple" id="sim-tape-attach">
<dt><code class="code highlight c docutils literal highlight-c"><span class="n">t_stat</span><span class="w"> </span><span class="n">sim_tape_attach</span><span class="w"> </span><span class="p">(</span><span class="n">UNIT</span><span class="w"> </span><span class="o">*</span><span class="n">uptr</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">cptr</span><span class="p">)</span></code></dt><dd><p>Attach tape unit <code class="docutils literal notranslate"><span class="pre">uptr</span></code> to file <code class="docutils literal notranslate"><span class="pre">cptr</span></code>.
Tape simulators must call this routine,
rather than the standard <code class="docutils literal notranslate"><span class="pre">attach_unit</span></code> routine.
This allows for future expansion of format support and proper functionality with all other tape APIs.</p>
</dd>
</dl>
<dl class="simple" id="sim-tape-detach">
<dt><code class="code highlight c docutils literal highlight-c"><span class="n">t_stat</span><span class="w"> </span><span class="n">sim_tape_detach</span><span class="w"> </span><span class="p">(</span><span class="n">UNIT</span><span class="w"> </span><span class="o">*</span><span class="n">uptr</span><span class="p">)</span></code></dt><dd><p>Detach tape unit <code class="docutils literal notranslate"><span class="pre">uptr</span></code> from its current file.</p>
</dd>
</dl>
<dl class="simple" id="sim-tape-set-fmt">
<dt><code class="code highlight c docutils literal highlight-c"><span class="n">t_stat</span><span class="w"> </span><span class="n">sim_tape_set_fmt</span><span class="w"> </span><span class="p">(</span><span class="n">UNIT</span><span class="w"> </span><span class="o">*</span><span class="n">uptr</span><span class="p">,</span><span class="w"> </span><span class="n">int32</span><span class="w"> </span><span class="n">val</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">cptr</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">desc</span><span class="p">)</span></code></dt><dd><p>Set the tape format for unit <code class="docutils literal notranslate"><span class="pre">uptr</span></code> to the format specified by string <code class="docutils literal notranslate"><span class="pre">cptr</span></code>.</p>
</dd>
</dl>
<dl class="simple" id="sim-tape-show-fmt">
<dt><code class="code highlight c docutils literal highlight-c"><span class="n">t_stat</span><span class="w"> </span><span class="n">sim_tape_show_fmt</span><span class="w"> </span><span class="p">(</span><span class="kt">FILE</span><span class="w"> </span><span class="o">*</span><span class="n">st</span><span class="p">,</span><span class="w"> </span><span class="n">UNIT</span><span class="w"> </span><span class="o">*</span><span class="n">uptr</span><span class="p">,</span><span class="w"> </span><span class="n">int32</span><span class="w"> </span><span class="n">val</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">desc</span><span class="p">)</span></code></dt><dd><p>Write the tape format for unit <code class="docutils literal notranslate"><span class="pre">uptr</span></code> to the file specified by descriptor <code class="docutils literal notranslate"><span class="pre">st</span></code>.</p>
</dd>
</dl>
<dl class="simple" id="sim-tape-set-capac">
<dt><code class="code highlight c docutils literal highlight-c"><span class="n">t_stat</span><span class="w"> </span><span class="n">sim_tape_set_capac</span><span class="w"> </span><span class="p">(</span><span class="n">UNIT</span><span class="w"> </span><span class="o">*</span><span class="n">uptr</span><span class="p">,</span><span class="w"> </span><span class="n">int32</span><span class="w"> </span><span class="n">val</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">cptr</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">desc</span><span class="p">)</span></code></dt><dd><p>Set the tape capacity for unit <code class="docutils literal notranslate"><span class="pre">uptr</span></code> to the capacity, in MB, specified by string <code class="docutils literal notranslate"><span class="pre">cptr</span></code>.</p>
</dd>
</dl>
<dl class="simple" id="sim-tape-show-capac">
<dt><code class="code highlight c docutils literal highlight-c"><span class="n">t_stat</span><span class="w"> </span><span class="n">sim_tape_show_capac</span><span class="w"> </span><span class="p">(</span><span class="kt">FILE</span><span class="w"> </span><span class="o">*</span><span class="n">st</span><span class="p">,</span><span class="w"> </span><span class="n">UNIT</span><span class="w"> </span><span class="o">*</span><span class="n">uptr</span><span class="p">,</span><span class="w"> </span><span class="n">int32</span><span class="w"> </span><span class="n">val</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">desc</span><span class="p">)</span></code></dt><dd><p>Write the capacity for unit <code class="docutils literal notranslate"><span class="pre">uptr</span></code> to the file specified by descriptor <code class="docutils literal notranslate"><span class="pre">st</span></code>.</p>
</dd>
</dl>
<dl class="simple" id="sim-tape-set-dens">
<dt><code class="code highlight c docutils literal highlight-c"><span class="n">t_stat</span><span class="w"> </span><span class="n">sim_tape_set_dens</span><span class="w"> </span><span class="p">(</span><span class="n">UNIT</span><span class="w"> </span><span class="o">*</span><span class="n">uptr</span><span class="p">,</span><span class="w"> </span><span class="n">int32</span><span class="w"> </span><span class="n">val</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">cptr</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">desc</span><span class="p">)</span></code></dt><dd><p>Set the tape density for unit <code class="docutils literal notranslate"><span class="pre">uptr</span></code> to the density,
in bits-per-inch,
specified by string <code class="docutils literal notranslate"><span class="pre">cptr</span></code>.
Only specific densities are supported;
<code class="docutils literal notranslate"><span class="pre">desc</span></code> must point at an <code class="code highlight c docutils literal highlight-c"><span class="n">int32</span></code> value consisting of one or more <code class="docutils literal notranslate"><span class="pre">MT_*_VALID</span></code> constants logically OR’ed together that specifies the densities allowed.
Alternately, <code class="docutils literal notranslate"><span class="pre">desc</span></code> may be set to <code class="code highlight c docutils literal highlight-c"><span class="nb">NULL</span></code> and <code class="docutils literal notranslate"><span class="pre">val</span></code> may specify one of the <code class="docutils literal notranslate"><span class="pre">MT_DENS_*</span></code> constants to set the density directly;
in this case, <code class="docutils literal notranslate"><span class="pre">cptr</span></code> is ignored.</p>
</dd>
</dl>
<dl class="simple" id="sim-tape-show-dens">
<dt><code class="code highlight c docutils literal highlight-c"><span class="n">t_stat</span><span class="w"> </span><span class="n">sim_tape_show_dens</span><span class="w"> </span><span class="p">(</span><span class="kt">FILE</span><span class="w"> </span><span class="o">*</span><span class="n">st</span><span class="p">,</span><span class="w"> </span><span class="n">UNIT</span><span class="w"> </span><span class="o">*</span><span class="n">uptr</span><span class="p">,</span><span class="w"> </span><span class="n">int32</span><span class="w"> </span><span class="n">val</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">desc</span><span class="p">)</span></code></dt><dd><p>Write the density for unit <code class="docutils literal notranslate"><span class="pre">uptr</span></code> to the file specified by descriptor <code class="docutils literal notranslate"><span class="pre">st</span></code>.</p>
</dd>
</dl>
<dl class="simple" id="sim-tape-rdrecf">
<dt><code class="code highlight c docutils literal highlight-c"><span class="n">t_stat</span><span class="w"> </span><span class="n">sim_tape_rdrecf</span><span class="w"> </span><span class="p">(</span><span class="n">UNIT</span><span class="w"> </span><span class="o">*</span><span class="n">uptr</span><span class="p">,</span><span class="w"> </span><span class="n">uint8</span><span class="w"> </span><span class="o">*</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="n">t_mtrlnt</span><span class="w"> </span><span class="o">*</span><span class="n">tbc</span><span class="p">,</span><span class="w"> </span><span class="n">t_mtrlnt</span><span class="w"> </span><span class="n">max</span><span class="p">)</span></code></dt><dd><p>Forward read the next record on unit <code class="docutils literal notranslate"><span class="pre">uptr</span></code> into buffer <code class="docutils literal notranslate"><span class="pre">buf</span></code> of size <code class="docutils literal notranslate"><span class="pre">max</span></code>.
Return the actual record size in <code class="docutils literal notranslate"><span class="pre">tbc</span></code>.</p>
</dd>
</dl>
<dl class="simple" id="sim-tape-rdrecf-a">
<dt><code class="code highlight c docutils literal highlight-c"><span class="n">t_stat</span><span class="w"> </span><span class="n">sim_tape_rdrecf_a</span><span class="w"> </span><span class="p">(</span><span class="n">UNIT</span><span class="w"> </span><span class="o">*</span><span class="n">uptr</span><span class="p">,</span><span class="w"> </span><span class="n">uint8</span><span class="w"> </span><span class="o">*</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="n">t_mtrlnt</span><span class="w"> </span><span class="o">*</span><span class="n">tbc</span><span class="p">,</span><span class="w"> </span><span class="n">t_mtrlnt</span><span class="w"> </span><span class="n">max</span><span class="p">,</span><span class="w"> </span><span class="n">TAPE_PCALLBACK</span><span class="w"> </span><span class="n">callback</span><span class="p">)</span></code></dt><dd><p>Forward read the next record on unit <code class="docutils literal notranslate"><span class="pre">uptr</span></code> into buffer <code class="docutils literal notranslate"><span class="pre">buf</span></code> of size <code class="docutils literal notranslate"><span class="pre">max</span></code>.
Return the actual record size in <code class="docutils literal notranslate"><span class="pre">tbc</span></code> and call <code class="docutils literal notranslate"><span class="pre">callback</span></code> routine on completion.</p>
</dd>
</dl>
<dl class="simple" id="sim-tape-rdrecr">
<dt><code class="code highlight c docutils literal highlight-c"><span class="n">t_stat</span><span class="w"> </span><span class="n">sim_tape_rdrecr</span><span class="w"> </span><span class="p">(</span><span class="n">UNIT</span><span class="w"> </span><span class="o">*</span><span class="n">uptr</span><span class="p">,</span><span class="w"> </span><span class="n">uint8</span><span class="w"> </span><span class="o">*</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="n">t_mtrlnt</span><span class="w"> </span><span class="o">*</span><span class="n">tbc</span><span class="p">,</span><span class="w"> </span><span class="n">t_mtrlnt</span><span class="w"> </span><span class="n">max</span><span class="p">)</span></code></dt><dd><p>Reverse read the next record on unit <code class="docutils literal notranslate"><span class="pre">uptr</span></code> into buffer <code class="docutils literal notranslate"><span class="pre">buf</span></code> of size <code class="docutils literal notranslate"><span class="pre">max</span></code>.
Return the actual record size in <code class="docutils literal notranslate"><span class="pre">tbc</span></code>.
Note that the record is returned in forward order,
that is, byte 0 of the record is stored in <code class="code highlight c docutils literal highlight-c"><span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></code>, and so on.</p>
</dd>
</dl>
<dl class="simple" id="sim-tape-rdrecr-a">
<dt><code class="code highlight c docutils literal highlight-c"><span class="n">t_stat</span><span class="w"> </span><span class="n">sim_tape_rdrecr_a</span><span class="w"> </span><span class="p">(</span><span class="n">UNIT</span><span class="w"> </span><span class="o">*</span><span class="n">uptr</span><span class="p">,</span><span class="w"> </span><span class="n">uint8</span><span class="w"> </span><span class="o">*</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="n">t_mtrlnt</span><span class="w"> </span><span class="o">*</span><span class="n">tbc</span><span class="p">,</span><span class="w"> </span><span class="n">t_mtrlnt</span><span class="w"> </span><span class="n">max</span><span class="p">,</span><span class="w"> </span><span class="n">TAPE_PCALLBACK</span><span class="w"> </span><span class="n">callback</span><span class="p">)</span></code></dt><dd><p>Reverse read the next record on unit <code class="docutils literal notranslate"><span class="pre">uptr</span></code> into buffer <code class="docutils literal notranslate"><span class="pre">buf</span></code> of size <code class="docutils literal notranslate"><span class="pre">max</span></code>.
Return the actual record size in <code class="docutils literal notranslate"><span class="pre">tbc</span></code> and call <code class="docutils literal notranslate"><span class="pre">callback</span></code> routine on completion.
Note that the record is returned in forward order,
that is, byte 0 of the record is stored in <code class="code highlight c docutils literal highlight-c"><span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></code>, and so on.</p>
</dd>
</dl>
<dl class="simple" id="sim-tape-wrrecf">
<dt><code class="code highlight c docutils literal highlight-c"><span class="n">t_stat</span><span class="w"> </span><span class="n">sim_tape_wrrecf</span><span class="w"> </span><span class="p">(</span><span class="n">UNIT</span><span class="w"> </span><span class="o">*</span><span class="n">uptr</span><span class="p">,</span><span class="w"> </span><span class="n">uint8</span><span class="w"> </span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="n">t_mtrlnt</span><span class="w"> </span><span class="n">tbc</span><span class="p">)</span></code></dt><dd><p>Write buffer <code class="docutils literal notranslate"><span class="pre">uptr</span></code> of size <code class="docutils literal notranslate"><span class="pre">tbc</span></code> as the next record on unit <code class="docutils literal notranslate"><span class="pre">uptr</span></code>.</p>
</dd>
</dl>
<dl class="simple" id="sim-tape-wrrecf-a">
<dt><code class="code highlight c docutils literal highlight-c"><span class="n">t_stat</span><span class="w"> </span><span class="n">sim_tape_wrrecf_a</span><span class="w"> </span><span class="p">(</span><span class="n">UNIT</span><span class="w"> </span><span class="o">*</span><span class="n">uptr</span><span class="p">,</span><span class="w"> </span><span class="n">uint8</span><span class="w"> </span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="n">t_mtrlnt</span><span class="w"> </span><span class="n">tbc</span><span class="p">,</span><span class="w"> </span><span class="n">TAPE_PCALLBACK</span><span class="w"> </span><span class="n">callback</span><span class="p">)</span></code></dt><dd><p>Write buffer <code class="docutils literal notranslate"><span class="pre">uptr</span></code> of size <code class="docutils literal notranslate"><span class="pre">tbc</span></code> as the next record on unit <code class="docutils literal notranslate"><span class="pre">uptr</span></code> and call <code class="docutils literal notranslate"><span class="pre">callback</span></code> routine on completion.</p>
</dd>
</dl>
<dl class="simple" id="sim-tape-errecf">
<dt><code class="code highlight c docutils literal highlight-c"><span class="n">t_stat</span><span class="w"> </span><span class="n">sim_tape_errecf</span><span class="w"> </span><span class="p">(</span><span class="n">UNIT</span><span class="w"> </span><span class="o">*</span><span class="n">uptr</span><span class="p">,</span><span class="w"> </span><span class="n">t_mtrlnt</span><span class="w"> </span><span class="n">tbc</span><span class="p">)</span></code></dt><dd><p>Starting at the current tape position,
write an erase gap in the forward direction on unit <code class="docutils literal notranslate"><span class="pre">uptr</span></code> for a length corresponding to a record containing the number of bytes specified by <code class="docutils literal notranslate"><span class="pre">tbc</span></code>.
If <code class="docutils literal notranslate"><span class="pre">tbc</span></code> is 0, then the tape mark at the current position is erased.
If the tape is not positioned at a record of the specified length or at a tape mark,
the routine returns <code class="docutils literal notranslate"><span class="pre">MTSE_INVRL</span></code>.</p>
</dd>
</dl>
<dl class="simple" id="sim-tape-errecr">
<dt><code class="code highlight c docutils literal highlight-c"><span class="n">t_stat</span><span class="w"> </span><span class="n">sim_tape_errecr</span><span class="w"> </span><span class="p">(</span><span class="n">UNIT</span><span class="w"> </span><span class="o">*</span><span class="n">uptr</span><span class="p">,</span><span class="w"> </span><span class="n">t_mtrlnt</span><span class="w"> </span><span class="n">tbc</span><span class="p">)</span></code></dt><dd><p>Starting at the current tape position,
write an erase gap in the reverse direction on unit <code class="docutils literal notranslate"><span class="pre">uptr</span></code> for a length corresponding to a record containing the number of bytes specified by <code class="docutils literal notranslate"><span class="pre">tbc</span></code>.
If <code class="docutils literal notranslate"><span class="pre">tbc</span></code> is 0,
then the tape mark preceding the current position is erased.
If the tape is not positioned at the end of a record of the specified length or at a tape mark,
the routine returns <code class="docutils literal notranslate"><span class="pre">MTSE_INVRL</span></code>.</p>
</dd>
</dl>
<dl class="simple" id="sim-tape-sprecf">
<dt><code class="code highlight c docutils literal highlight-c"><span class="n">t_stat</span><span class="w"> </span><span class="n">sim_tape_sprecf</span><span class="w"> </span><span class="p">(</span><span class="n">UNIT</span><span class="w"> </span><span class="o">*</span><span class="n">uptr</span><span class="p">,</span><span class="w"> </span><span class="n">t_mtrlnt</span><span class="w"> </span><span class="o">*</span><span class="n">tbc</span><span class="p">)</span></code></dt><dd><p>Space unit <code class="docutils literal notranslate"><span class="pre">uptr</span></code> forward one record.
The size of the record is returned in <code class="docutils literal notranslate"><span class="pre">tbc</span></code>.</p>
</dd>
</dl>
<dl class="simple" id="sim-tape-sprecf-a">
<dt><code class="code highlight c docutils literal highlight-c"><span class="n">t_stat</span><span class="w"> </span><span class="n">sim_tape_sprecf_a</span><span class="w"> </span><span class="p">(</span><span class="n">UNIT</span><span class="w"> </span><span class="o">*</span><span class="n">uptr</span><span class="p">,</span><span class="w"> </span><span class="n">t_mtrlnt</span><span class="w"> </span><span class="o">*</span><span class="n">tbc</span><span class="p">,</span><span class="w"> </span><span class="n">TAPE_PCALLBACK</span><span class="w"> </span><span class="n">callback</span><span class="p">)</span></code></dt><dd><p>Space unit <code class="docutils literal notranslate"><span class="pre">uptr</span></code> forward one record.
The size of the record is returned in <code class="docutils literal notranslate"><span class="pre">tbc</span></code> and call <code class="docutils literal notranslate"><span class="pre">callback</span></code> routine on completion.</p>
</dd>
</dl>
<dl class="simple" id="sim-tape-sprecsf">
<dt><code class="code highlight c docutils literal highlight-c"><span class="n">t_stat</span><span class="w"> </span><span class="n">sim_tape_sprecsf</span><span class="w"> </span><span class="p">(</span><span class="n">UNIT</span><span class="w"> </span><span class="o">*</span><span class="n">uptr</span><span class="p">,</span><span class="w"> </span><span class="n">uint32</span><span class="w"> </span><span class="n">count</span><span class="p">,</span><span class="w"> </span><span class="n">uint32</span><span class="w"> </span><span class="o">*</span><span class="n">skipped</span><span class="p">)</span></code></dt><dd><p>Space unit <code class="docutils literal notranslate"><span class="pre">uptr</span></code> forward <code class="docutils literal notranslate"><span class="pre">count</span></code> records.
The number of records actually skipped is returned in <code class="docutils literal notranslate"><span class="pre">skipped</span></code>.</p>
</dd>
</dl>
<dl class="simple" id="sim-tape-sprecsf-a">
<dt><code class="code highlight c docutils literal highlight-c"><span class="n">t_stat</span><span class="w"> </span><span class="n">sim_tape_sprecsf_a</span><span class="w"> </span><span class="p">(</span><span class="n">UNIT</span><span class="w"> </span><span class="o">*</span><span class="n">uptr</span><span class="p">,</span><span class="w"> </span><span class="n">uint32</span><span class="w"> </span><span class="n">count</span><span class="p">,</span><span class="w"> </span><span class="n">uint32</span><span class="w"> </span><span class="o">*</span><span class="n">skipped</span><span class="p">,</span><span class="w"> </span><span class="n">TAPE_PCALLBACK</span><span class="w"> </span><span class="n">callback</span><span class="p">)</span></code></dt><dd><p>Space unit <code class="docutils literal notranslate"><span class="pre">uptr</span></code> forward <code class="docutils literal notranslate"><span class="pre">count</span></code> records.
The number of records actually skipped is returned in <code class="docutils literal notranslate"><span class="pre">skipped</span></code> and call <code class="docutils literal notranslate"><span class="pre">callback</span></code> routine on completion.</p>
</dd>
</dl>
<dl class="simple" id="sim-tape-spfilef">
<dt><code class="code highlight c docutils literal highlight-c"><span class="n">t_stat</span><span class="w"> </span><span class="n">sim_tape_spfilef</span><span class="w"> </span><span class="p">(</span><span class="n">UNIT</span><span class="w"> </span><span class="o">*</span><span class="n">uptr</span><span class="p">,</span><span class="w"> </span><span class="n">uint32</span><span class="w"> </span><span class="n">count</span><span class="p">,</span><span class="w"> </span><span class="n">uint32</span><span class="w"> </span><span class="o">*</span><span class="n">skipped</span><span class="p">)</span></code></dt><dd><p>Space unit <code class="docutils literal notranslate"><span class="pre">uptr</span></code> forward <code class="docutils literal notranslate"><span class="pre">count</span></code> files.
The number of files actually skipped is returned in <code class="docutils literal notranslate"><span class="pre">skipped</span></code>.</p>
</dd>
</dl>
<dl class="simple" id="sim-tape-spfilef-a">
<dt><code class="code highlight c docutils literal highlight-c"><span class="n">t_stat</span><span class="w"> </span><span class="n">sim_tape_spfilef_a</span><span class="w"> </span><span class="p">(</span><span class="n">UNIT</span><span class="w"> </span><span class="o">*</span><span class="n">uptr</span><span class="p">,</span><span class="w"> </span><span class="n">uint32</span><span class="w"> </span><span class="n">count</span><span class="p">,</span><span class="w"> </span><span class="n">uint32</span><span class="w"> </span><span class="o">*</span><span class="n">skipped</span><span class="p">,</span><span class="w"> </span><span class="n">TAPE_PCALLBACK</span><span class="w"> </span><span class="n">callback</span><span class="p">)</span></code></dt><dd><p>Space unit <code class="docutils literal notranslate"><span class="pre">uptr</span></code> forward <code class="docutils literal notranslate"><span class="pre">count</span></code> files.
The number of files actually skipped is returned in <code class="docutils literal notranslate"><span class="pre">skipped</span></code> and call <code class="docutils literal notranslate"><span class="pre">callback</span></code> routine on completion.</p>
</dd>
</dl>
<dl class="simple" id="sim-tape-spfilebyrecf">
<dt><code class="code highlight c docutils literal highlight-c"><span class="n">t_stat</span><span class="w"> </span><span class="n">sim_tape_spfilebyrecf</span><span class="w"> </span><span class="p">(</span><span class="n">UNIT</span><span class="w"> </span><span class="o">*</span><span class="n">uptr</span><span class="p">,</span><span class="w"> </span><span class="n">uint32</span><span class="w"> </span><span class="n">count</span><span class="p">,</span><span class="w"> </span><span class="n">uint32</span><span class="w"> </span><span class="o">*</span><span class="n">skipped</span><span class="p">,</span><span class="w"> </span><span class="n">uint32</span><span class="w"> </span><span class="o">*</span><span class="n">recsskipped</span><span class="p">,</span><span class="w"> </span><span class="n">t_bool</span><span class="w"> </span><span class="n">check_leot</span><span class="p">)</span></code></dt><dd><p>Space unit <code class="docutils literal notranslate"><span class="pre">uptr</span></code> forward <code class="docutils literal notranslate"><span class="pre">count</span></code> files.
The number of files actually skipped is returned in <code class="docutils literal notranslate"><span class="pre">skipped</span></code>.
The number of records skipped is returned in <code class="docutils literal notranslate"><span class="pre">recsskipped</span></code>.</p>
</dd>
</dl>
<dl class="simple" id="sim-tape-spfilebyrecf-a">
<dt><code class="code highlight c docutils literal highlight-c"><span class="n">t_stat</span><span class="w"> </span><span class="n">sim_tape_spfilebyrecf_a</span><span class="w"> </span><span class="p">(</span><span class="n">UNIT</span><span class="w"> </span><span class="o">*</span><span class="n">uptr</span><span class="p">,</span><span class="w"> </span><span class="n">uint32</span><span class="w"> </span><span class="n">count</span><span class="p">,</span><span class="w"> </span><span class="n">uint32</span><span class="w"> </span><span class="o">*</span><span class="n">skipped</span><span class="p">,</span><span class="w"> </span><span class="n">uint32</span><span class="w"> </span><span class="o">*</span><span class="n">recsskipped</span><span class="p">,</span><span class="w"> </span><span class="n">t_bool</span><span class="w"> </span><span class="n">check_leot</span><span class="p">,</span><span class="w"> </span><span class="n">TAPE_PCALLBACK</span><span class="w"> </span><span class="n">callback</span><span class="p">)</span></code></dt><dd><p>Space unit <code class="docutils literal notranslate"><span class="pre">uptr</span></code> forward <code class="docutils literal notranslate"><span class="pre">count</span></code> files.
The number of files actually skipped is returned in <code class="docutils literal notranslate"><span class="pre">skipped</span></code>.
The number of records skipped is returned in <code class="docutils literal notranslate"><span class="pre">recsskipped</span></code> and call <code class="docutils literal notranslate"><span class="pre">callback</span></code> routine on completion.</p>
</dd>
</dl>
<dl class="simple" id="sim-tape-position">
<dt><code class="code highlight c docutils literal highlight-c"><span class="n">t_stat</span><span class="w"> </span><span class="n">sim_tape_position</span><span class="w"> </span><span class="p">(</span><span class="n">UNIT</span><span class="w"> </span><span class="o">*</span><span class="n">uptr</span><span class="p">,</span><span class="w"> </span><span class="n">uint32</span><span class="w"> </span><span class="n">flags</span><span class="p">,</span><span class="w"> </span><span class="n">uint32</span><span class="w"> </span><span class="n">recs</span><span class="p">,</span><span class="w"> </span><span class="n">uint32</span><span class="w"> </span><span class="o">*</span><span class="n">recsskipped</span><span class="p">,</span><span class="w"> </span><span class="n">uint32</span><span class="w"> </span><span class="n">files</span><span class="p">,</span><span class="w"> </span><span class="n">uint32</span><span class="w"> </span><span class="o">*</span><span class="n">filesskipped</span><span class="p">,</span><span class="w"> </span><span class="n">uint32</span><span class="w"> </span><span class="o">*</span><span class="n">objectsskipped</span><span class="p">)</span></code></dt><dd><p>Space unit <code class="docutils literal notranslate"><span class="pre">uptr</span></code> forward <code class="docutils literal notranslate"><span class="pre">recs</span></code> records and <code class="docutils literal notranslate"><span class="pre">files</span></code> files.
The number of records actually skipped is returned in <code class="docutils literal notranslate"><span class="pre">recsskipped</span></code>.
The number of files actually skipped is returned in <code class="docutils literal notranslate"><span class="pre">filesskipped</span></code>.
The number of records skipped is returned in <code class="docutils literal notranslate"><span class="pre">recsskipped</span></code>.
The number of objects skipped is returned in <code class="docutils literal notranslate"><span class="pre">objectssskipped</span></code>.</p>
</dd>
</dl>
<dl class="simple" id="sim-tape-position-a">
<dt><code class="code highlight c docutils literal highlight-c"><span class="n">t_stat</span><span class="w"> </span><span class="n">sim_tape_position_a</span><span class="w"> </span><span class="p">(</span><span class="n">UNIT</span><span class="w"> </span><span class="o">*</span><span class="n">uptr</span><span class="p">,</span><span class="w"> </span><span class="n">uint32</span><span class="w"> </span><span class="n">flags</span><span class="p">,</span><span class="w"> </span><span class="n">uint32</span><span class="w"> </span><span class="n">recs</span><span class="p">,</span><span class="w"> </span><span class="n">uint32</span><span class="w"> </span><span class="o">*</span><span class="n">recsskipped</span><span class="p">,</span><span class="w"> </span><span class="n">uint32</span><span class="w"> </span><span class="n">files</span><span class="p">,</span><span class="w"> </span><span class="n">uint32</span><span class="w"> </span><span class="o">*</span><span class="n">filesskipped</span><span class="p">,</span><span class="w"> </span><span class="n">uint32</span><span class="w"> </span><span class="o">*</span><span class="n">objectsskipped</span><span class="p">,</span><span class="w"> </span><span class="n">TAPE_PCALLBACK</span><span class="w"> </span><span class="n">callback</span><span class="p">)</span></code></dt><dd><p>Space unit <code class="docutils literal notranslate"><span class="pre">uptr</span></code> forward <code class="docutils literal notranslate"><span class="pre">recs</span></code> records and <code class="docutils literal notranslate"><span class="pre">files</span></code> files.
The number of records actually skipped is returned in <code class="docutils literal notranslate"><span class="pre">recsskipped</span></code>.
The number of files actually skipped is returned in <code class="docutils literal notranslate"><span class="pre">filesskipped</span></code>.
The number of records skipped is returned in <code class="docutils literal notranslate"><span class="pre">recsskipped</span></code>.
The number of objects skipped is returned in <code class="docutils literal notranslate"><span class="pre">objectssskipped</span></code> and call <code class="docutils literal notranslate"><span class="pre">callback</span></code> routine on completion.</p>
</dd>
</dl>
<dl class="simple" id="sim-tape-sprecr">
<dt><code class="code highlight c docutils literal highlight-c"><span class="n">t_stat</span><span class="w"> </span><span class="n">sim_tape_sprecr</span><span class="w"> </span><span class="p">(</span><span class="n">UNIT</span><span class="w"> </span><span class="o">*</span><span class="n">uptr</span><span class="p">,</span><span class="w"> </span><span class="n">t_mtrlnt</span><span class="w"> </span><span class="o">*</span><span class="n">tbc</span><span class="p">)</span></code></dt><dd><p>Space unit <code class="docutils literal notranslate"><span class="pre">uptr</span></code> reverse one record.
The size of the record is returned in <code class="docutils literal notranslate"><span class="pre">tbc</span></code>.</p>
</dd>
</dl>
<dl class="simple" id="sim-tape-sprecr-a">
<dt><code class="code highlight c docutils literal highlight-c"><span class="n">t_stat</span><span class="w"> </span><span class="n">sim_tape_sprecr_a</span><span class="w"> </span><span class="p">(</span><span class="n">UNIT</span><span class="w"> </span><span class="o">*</span><span class="n">uptr</span><span class="p">,</span><span class="w"> </span><span class="n">t_mtrlnt</span><span class="w"> </span><span class="o">*</span><span class="n">tbc</span><span class="p">,</span><span class="w"> </span><span class="n">TAPE_PCALLBACK</span><span class="w"> </span><span class="n">callback</span><span class="p">)</span></code></dt><dd><p>Space unit <code class="docutils literal notranslate"><span class="pre">uptr</span></code> reverse one record.
The size of the record is returned in <code class="docutils literal notranslate"><span class="pre">tbc</span></code> and call <code class="docutils literal notranslate"><span class="pre">callback</span></code> routine on completion.</p>
</dd>
</dl>
<dl class="simple" id="sim-tape-wrtmk">
<dt><code class="code highlight c docutils literal highlight-c"><span class="n">t_stat</span><span class="w"> </span><span class="n">sim_tape_wrtmk</span><span class="w"> </span><span class="p">(</span><span class="n">UNIT</span><span class="w"> </span><span class="o">*</span><span class="n">uptr</span><span class="p">)</span></code></dt><dd><p>Write a tape mark on unit <code class="docutils literal notranslate"><span class="pre">uptr</span></code>.</p>
</dd>
</dl>
<dl class="simple" id="sim-tape-wrtmk-a">
<dt><code class="code highlight c docutils literal highlight-c"><span class="n">t_stat</span><span class="w"> </span><span class="n">sim_tape_wrtmk_a</span><span class="w"> </span><span class="p">(</span><span class="n">UNIT</span><span class="w"> </span><span class="o">*</span><span class="n">uptr</span><span class="p">,</span><span class="w"> </span><span class="n">TAPE_PCALLBACK</span><span class="w"> </span><span class="n">callback</span><span class="p">)</span></code></dt><dd><p>Write a tape mark on unit <code class="docutils literal notranslate"><span class="pre">uptr</span></code> and call <code class="docutils literal notranslate"><span class="pre">callback</span></code> routine on completion.</p>
</dd>
</dl>
<dl class="simple" id="sim-tape-wreom">
<dt><code class="code highlight c docutils literal highlight-c"><span class="n">t_stat</span><span class="w"> </span><span class="n">sim_tape_wreom</span><span class="w"> </span><span class="p">(</span><span class="n">UNIT</span><span class="w"> </span><span class="o">*</span><span class="n">uptr</span><span class="p">)</span></code></dt><dd><p>Write an end-of-medium marker on unit <code class="docutils literal notranslate"><span class="pre">uptr</span></code>
(this effectively erases the rest of the tape).</p>
</dd>
</dl>
<dl class="simple" id="sim-tape-wreom-a">
<dt><code class="code highlight c docutils literal highlight-c"><span class="n">t_stat</span><span class="w"> </span><span class="n">sim_tape_wreom_a</span><span class="w"> </span><span class="p">(</span><span class="n">UNIT</span><span class="w"> </span><span class="o">*</span><span class="n">uptr</span><span class="p">,</span><span class="w"> </span><span class="n">TAPE_PCALLBACK</span><span class="w"> </span><span class="n">callback</span><span class="p">)</span></code></dt><dd><p>Write an end-of-medium marker on unit <code class="docutils literal notranslate"><span class="pre">uptr</span></code>
(this effectively erases the rest of the tape)
and call <code class="docutils literal notranslate"><span class="pre">callback</span></code> routine on completion.</p>
</dd>
</dl>
<dl class="simple" id="sim-tape-wreomrw">
<dt><code class="code highlight c docutils literal highlight-c"><span class="n">t_stat</span><span class="w"> </span><span class="n">sim_tape_wreomrw</span><span class="w"> </span><span class="p">(</span><span class="n">UNIT</span><span class="w"> </span><span class="o">*</span><span class="n">uptr</span><span class="p">)</span></code></dt><dd><p>Write an end-of-medium marker on unit <code class="docutils literal notranslate"><span class="pre">uptr</span></code> and rewind
(this effectively erases the rest of the tape).</p>
</dd>
</dl>
<dl class="simple" id="sim-tape-wreomrw-a">
<dt><code class="code highlight c docutils literal highlight-c"><span class="n">t_stat</span><span class="w"> </span><span class="n">sim_tape_wreomrw_a</span><span class="w"> </span><span class="p">(</span><span class="n">UNIT</span><span class="w"> </span><span class="o">*</span><span class="n">uptr</span><span class="p">,</span><span class="w"> </span><span class="n">TAPE_PCALLBACK</span><span class="w"> </span><span class="n">callback</span><span class="p">)</span></code></dt><dd><p>Write an end-of-medium marker on unit <code class="docutils literal notranslate"><span class="pre">uptr</span></code> and rewind
(this effectively erases the rest of the tape)
and call <code class="docutils literal notranslate"><span class="pre">callback</span></code> routine on completion.</p>
</dd>
</dl>
<dl class="simple" id="sim-tape-wrgap">
<dt><code class="code highlight c docutils literal highlight-c"><span class="n">t_stat</span><span class="w"> </span><span class="n">sim_tape_wrgap</span><span class="w"> </span><span class="p">(</span><span class="n">UNIT</span><span class="w"> </span><span class="o">*</span><span class="n">uptr</span><span class="p">,</span><span class="w"> </span><span class="n">uint32</span><span class="w"> </span><span class="n">gaplen</span><span class="p">)</span></code></dt><dd><p>Write an erase gap on unit <code class="docutils literal notranslate"><span class="pre">uptr</span></code> of <code class="docutils literal notranslate"><span class="pre">gaplen</span></code> tenths of an inch in length at a tape density specified by a preceding <code class="docutils literal notranslate"><span class="pre">sim_tape_set_dens</span></code> call.</p>
</dd>
</dl>
<dl class="simple" id="sim-tape-wrgap-a">
<dt><code class="code highlight c docutils literal highlight-c"><span class="n">t_stat</span><span class="w"> </span><span class="n">sim_tape_wrgap_a</span><span class="w"> </span><span class="p">(</span><span class="n">UNIT</span><span class="w"> </span><span class="o">*</span><span class="n">uptr</span><span class="p">,</span><span class="w"> </span><span class="n">uint32</span><span class="w"> </span><span class="n">gaplen</span><span class="p">,</span><span class="w"> </span><span class="n">TAPE_PCALLBACK</span><span class="w"> </span><span class="n">callback</span><span class="p">)</span></code></dt><dd><p>Write an erase gap on unit <code class="docutils literal notranslate"><span class="pre">uptr</span></code> of <code class="docutils literal notranslate"><span class="pre">gaplen</span></code> tenths of an inch in length at a tape density specified by a preceding <code class="docutils literal notranslate"><span class="pre">sim_tape_set_dens</span></code> call and call <code class="docutils literal notranslate"><span class="pre">callback</span></code> routine on completion.</p>
</dd>
</dl>
<dl class="simple" id="sim-tape-rewind">
<dt><code class="code highlight c docutils literal highlight-c"><span class="n">t_stat</span><span class="w"> </span><span class="n">sim_tape_rewind</span><span class="w"> </span><span class="p">(</span><span class="n">UNIT</span><span class="w"> </span><span class="o">*</span><span class="n">uptr</span><span class="p">)</span></code></dt><dd><p>Rewind unit <code class="docutils literal notranslate"><span class="pre">uptr</span></code>.
This operation succeeds whether or not the unit is attached to a file.</p>
</dd>
</dl>
<dl class="simple" id="sim-tape-rewind-a">
<dt><code class="code highlight c docutils literal highlight-c"><span class="n">t_stat</span><span class="w"> </span><span class="n">sim_tape_rewind_a</span><span class="w"> </span><span class="p">(</span><span class="n">UNIT</span><span class="w"> </span><span class="o">*</span><span class="n">uptr</span><span class="p">,</span><span class="w"> </span><span class="n">TAPE_PCALLBACK</span><span class="w"> </span><span class="n">callback</span><span class="p">)</span></code></dt><dd><p>Rewind unit <code class="docutils literal notranslate"><span class="pre">uptr</span></code>.
This operation succeeds whether or not the unit is attached to a file and call <code class="docutils literal notranslate"><span class="pre">callback</span></code> routine on completion.</p>
</dd>
</dl>
<dl class="simple" id="sim-tape-reset">
<dt><code class="code highlight c docutils literal highlight-c"><span class="n">t_stat</span><span class="w"> </span><span class="n">sim_tape_reset</span><span class="w"> </span><span class="p">(</span><span class="n">UNIT</span><span class="w"> </span><span class="o">*</span><span class="n">uptr</span><span class="p">)</span></code></dt><dd><p>Reset unit <code class="docutils literal notranslate"><span class="pre">uptr</span></code>.
This routine should be called when a tape unit is reset.</p>
</dd>
</dl>
<dl class="simple" id="sim-tape-bot">
<dt><code class="code highlight c docutils literal highlight-c"><span class="n">t_bool</span><span class="w"> </span><span class="n">sim_tape_bot</span><span class="w"> </span><span class="p">(</span><span class="n">UNIT</span><span class="w"> </span><span class="o">*</span><span class="n">uptr</span><span class="p">)</span></code></dt><dd><p>Return <code class="code highlight c docutils literal highlight-c"><span class="n">TRUE</span></code> if unit <code class="docutils literal notranslate"><span class="pre">uptr</span></code> is at beginning-of-tape.</p>
</dd>
</dl>
<dl class="simple" id="sim-tape-wrp">
<dt><code class="code highlight c docutils literal highlight-c"><span class="n">t_bool</span><span class="w"> </span><span class="n">sim_tape_wrp</span><span class="w"> </span><span class="p">(</span><span class="n">UNIT</span><span class="w"> </span><span class="o">*</span><span class="n">uptr</span><span class="p">)</span></code></dt><dd><p>Return <code class="code highlight c docutils literal highlight-c"><span class="n">TRUE</span></code> if unit <code class="docutils literal notranslate"><span class="pre">uptr</span></code> is write-protected.</p>
</dd>
</dl>
<dl class="simple" id="sim-tape-eot">
<dt><code class="code highlight c docutils literal highlight-c"><span class="n">t_bool</span><span class="w"> </span><span class="n">sim_tape_eot</span><span class="w"> </span><span class="p">(</span><span class="n">UNIT</span><span class="w"> </span><span class="o">*</span><span class="n">uptr</span><span class="p">)</span></code></dt><dd><p>Return <code class="code highlight c docutils literal highlight-c"><span class="n">TRUE</span></code> if unit <code class="docutils literal notranslate"><span class="pre">uptr</span></code> has exceeded the capacity specified of the specified unit (kept in <code class="code highlight c docutils literal highlight-c"><span class="n">uptr</span><span class="o">-&gt;</span><span class="n">capac</span></code>).</p>
</dd>
</dl>
<p>The library supports reading and writing erase gaps in standard (SIMH) tape format image files.
Before writing a gap with <a class="reference internal" href="#sim-tape-wrgap"><code class="docutils literal notranslate"><span class="pre">sim_tape_wrgap</span></code></a>,
the tape unit density must be set by calling <a class="reference internal" href="#sim-tape-set-dens"><code class="docutils literal notranslate"><span class="pre">sim_tape_set_dens</span></code></a>;
failure to do so will result in an error.
For reading,
if the tape density has been set,
then the length is monitored when skipping over erase gaps.
If the gap length reaches 25 feet
(the maximum allowed by the ANSI/ECMA standards),
motion is terminated,
and “tape runaway” status is returned.
Runaway status is also returned if an end-of-medium marker or the physical end of file is encountered while spacing over a gap.
If the density has not been set,
then a gap of any length is skipped,
and tape runaway status is never returned;
in effect, any erase gaps present in the tape image file will be transparent to the calling simulator.</p>
<p>The library supports writing erase gaps over existing data records and writing records over existing gaps.
If the end of a gap overlays part of a data record,
the record will be truncated,
but the tape image will remain valid.</p>
<p>An attempt to write an erase gap in an unsupported tape format results in no action and no error.
This allows a device simulator that supports writing erase gaps to call <a class="reference internal" href="#sim-tape-wrgap"><code class="docutils literal notranslate"><span class="pre">sim_tape_wrgap</span></code></a> without concern for the tape format currently selected by the user.</p>
<p><a class="reference internal" href="#sim-tape-attach"><code class="docutils literal notranslate"><span class="pre">sim_tape_attach</span></code></a>,
<a class="reference internal" href="#sim-tape-detach"><code class="docutils literal notranslate"><span class="pre">sim_tape_detach</span></code></a>,
<a class="reference internal" href="#sim-tape-set-fmt"><code class="docutils literal notranslate"><span class="pre">sim_tape_set_fmt</span></code></a>,
<a class="reference internal" href="#sim-tape-show-fmt"><code class="docutils literal notranslate"><span class="pre">sim_tape_show_fmt</span></code></a>,
<a class="reference internal" href="#sim-tape-set-capac"><code class="docutils literal notranslate"><span class="pre">sim_tape_set_capac</span></code></a>,
<a class="reference internal" href="#sim-tape-show-capac"><code class="docutils literal notranslate"><span class="pre">sim_tape_show_capac</span></code></a>,
<a class="reference internal" href="#sim-tape-set-dens"><code class="docutils literal notranslate"><span class="pre">sim_tape_set_dens</span></code></a>,
and <a class="reference internal" href="#sim-tape-show-dens"><code class="docutils literal notranslate"><span class="pre">sim_tape_show_dens</span></code></a> return standard SCP status codes;
the other magtape library routines return return private codes for success and failure.
The currently defined magtape status codes are:</p>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">MTSE_OK</span></code></p></td>
<td><p>Operation successful</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">MTSE_UNATT</span></code></p></td>
<td><p>Unit is not attached to a file</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">MTSE_FMT</span></code></p></td>
<td><p>Unit specifies an unsupported tape file format</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">MTSE_IOERR</span></code></p></td>
<td><p>Host operating system I/O error during operation</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">MTSE_INVRL</span></code></p></td>
<td><p>Invalid record length (exceeds maximum allowed)</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">MTSE_RECE</span></code></p></td>
<td><p>Record header contains error flag</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">MTSE_TMK</span></code></p></td>
<td><p>Tape mark encountered</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">MTSE_BOT</span></code></p></td>
<td><p>Beginning of tape encountered during reverse operation</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">MTSE_EOM</span></code></p></td>
<td><p>End-of-medium encountered</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">MTSE_WRP</span></code></p></td>
<td><p>Write protected unit during write operation</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">MTSE_RUNAWAY</span></code></p></td>
<td><p>Tape runaway occurred</p></td>
</tr>
</tbody>
</table>
<p><a class="reference internal" href="#sim-tape-set-fmt"><code class="docutils literal notranslate"><span class="pre">sim_tape_set_fmt</span></code></a>,
<a class="reference internal" href="#sim-tape-show-fmt"><code class="docutils literal notranslate"><span class="pre">sim_tape_show_fmt</span></code></a>,
<a class="reference internal" href="#sim-tape-set-capac"><code class="docutils literal notranslate"><span class="pre">sim_tape_set_capac</span></code></a>,
and <a class="reference internal" href="#sim-tape-show-capac"><code class="docutils literal notranslate"><span class="pre">sim_tape_show_capac</span></code></a>
should be referenced by an entry in the tape device’s modifier list,
as follows:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">MTAB</span><span class="w"> </span><span class="n">tape_mod</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">{</span><span class="w"> </span><span class="n">MTAB_XTD</span><span class="o">|</span><span class="n">MTAB_VDV</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;FORMAT&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;FORMAT&quot;</span><span class="p">,</span>
<span class="w">      </span><span class="o">&amp;</span><span class="n">sim_tape_set_fmt</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">sim_tape_show_fmt</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="w"> </span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span><span class="w"> </span><span class="n">MTAB_XTD</span><span class="o">|</span><span class="n">MTAB_VUN</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;CAPACITY&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;CAPACITY&quot;</span><span class="p">,</span>
<span class="w">      </span><span class="o">&amp;</span><span class="n">sim_tape_set_capac</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">sim_tape_show_capac</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="w"> </span><span class="p">},</span>
<span class="w">    </span><span class="cm">/* … */</span>
<span class="p">};</span>
</pre></div>
</div>
<p><a class="reference internal" href="#sim-tape-set-dens"><code class="docutils literal notranslate"><span class="pre">sim_tape_set_dens</span></code></a> and <a class="reference internal" href="#sim-tape-show-dens"><code class="docutils literal notranslate"><span class="pre">sim_tape_show_dens</span></code></a> may be referenced in the modifier list,
or <a class="reference internal" href="#sim-tape-set-dens"><code class="docutils literal notranslate"><span class="pre">sim_tape_set_dens</span></code></a> may be called directly to set the density,
as indicated above.</p>
</section>
<section id="disk-emulation-library">
<h3><span class="sectnum">1.6.3. </span>Disk emulation library<a class="headerlink" href="#disk-emulation-library" title="Permalink to this heading">¶</a></h3>
<p>SIMH supports the use of disk drives.
Disk drives as disk files containing both data and potentially additional metadata which describes various aspects of the disk container and the disk drive it emulates.
SIMH provides a supporting library,
<code class="docutils literal notranslate"><span class="pre">sim_disk.c</span></code> (and its header file, <code class="docutils literal notranslate"><span class="pre">sim_disk.h</span></code>),
that abstracts handling of disk drives which have sectors which are a multiple of 512 bytes.
This allows support for alternate disk formats or disk access to physical devices on the host system,
without change to disk device simulators.</p>
<p>The disk library does not require any special data structures.</p>
<p>If disk drive simulators need to define private unit flags,
those flags should begin at bit number <code class="docutils literal notranslate"><span class="pre">DKUF_V_UF</span></code> instead of <code class="docutils literal notranslate"><span class="pre">UNIT_V_UF</span></code>.
The disk library maintains the current disk position in the <a class="reference internal" href="#unit-pos"><code class="docutils literal notranslate"><span class="pre">pos</span></code></a> field of the <a class="reference internal" href="#unit"><code class="docutils literal notranslate"><span class="pre">UNIT</span></code></a> structure.</p>
<p id="sim-disk"><span id="sim-disk-c"></span>Library <code class="docutils literal notranslate"><span class="pre">sim_disk.c</span></code> provides the following routines to support emulated disk drives.
These are declared in include file <code class="docutils literal notranslate"><span class="pre">sim_disk.h</span></code>.</p>
<dl class="simple" id="sim-disk-attach">
<dt><code class="code highlight c docutils literal highlight-c"><span class="n">t_stat</span><span class="w"> </span><span class="n">sim_disk_attach</span><span class="w"> </span><span class="p">(</span><span class="n">UNIT</span><span class="w"> </span><span class="o">*</span><span class="n">uptr</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">cptr</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">sector_size</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">xfer_element_size</span><span class="p">,</span><span class="w"> </span><span class="n">t_bool</span><span class="w"> </span><span class="n">dontautosize</span><span class="p">,</span><span class="w"> </span><span class="n">uint32</span><span class="w"> </span><span class="n">debugbit</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">drivetype</span><span class="p">,</span><span class="w"> </span><span class="n">uint32</span><span class="w"> </span><span class="n">pdp11_tracksize</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">completion_delay</span><span class="p">)</span></code></dt><dd><p>Attach disk unit <code class="docutils literal notranslate"><span class="pre">uptr</span></code> to file <code class="docutils literal notranslate"><span class="pre">cptr</span></code>.
Disk simulators should call this routine,
rather than the standard <code class="docutils literal notranslate"><span class="pre">attach_unit</span></code> routine.</p>
</dd>
</dl>
<dl class="simple" id="sim-disk-attach-ex">
<dt><code class="code highlight c docutils literal highlight-c"><span class="n">t_stat</span><span class="w"> </span><span class="n">sim_disk_attach_ex</span><span class="w"> </span><span class="p">(</span><span class="n">UNIT</span><span class="w"> </span><span class="o">*</span><span class="n">uptr</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">cptr</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">sector_size</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">xfer_element_size</span><span class="p">,</span><span class="w"> </span><span class="n">t_bool</span><span class="w"> </span><span class="n">dontchangecapac</span><span class="p">,</span><span class="w"> </span><span class="n">uint32</span><span class="w"> </span><span class="n">debugbit</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">drivetype</span><span class="p">,</span><span class="w"> </span><span class="n">uint32</span><span class="w"> </span><span class="n">pdp11_tracksize</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">completion_delay</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">**</span><span class="n">drivetypes</span><span class="p">)</span></code></dt><dd><p>Attach disk unit <code class="docutils literal notranslate"><span class="pre">uptr</span></code> to file <code class="docutils literal notranslate"><span class="pre">cptr</span></code>.
Disk simulators should call this routine,
rather than the standard <code class="docutils literal notranslate"><span class="pre">attach_unit</span></code> routine.
The <code class="docutils literal notranslate"><span class="pre">drivetypes</span></code> is a <code class="code highlight c docutils literal highlight-c"><span class="nb">NULL</span></code>-terminated list of drive types available to autosize.</p>
</dd>
</dl>
<dl class="simple" id="sim-disk-attach-ex2">
<dt><code class="code highlight c docutils literal highlight-c"><span class="n">t_stat</span><span class="w"> </span><span class="n">sim_disk_attach_ex2</span><span class="w"> </span><span class="p">(</span><span class="n">UNIT</span><span class="w"> </span><span class="o">*</span><span class="n">uptr</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">cptr</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">sector_size</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">xfer_element_size</span><span class="p">,</span><span class="w"> </span><span class="n">t_bool</span><span class="w"> </span><span class="n">dontchangecapac</span><span class="p">,</span><span class="w"> </span><span class="n">uint32</span><span class="w"> </span><span class="n">debugbit</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">drivetype</span><span class="p">,</span><span class="w"> </span><span class="n">uint32</span><span class="w"> </span><span class="n">pdp11_tracksize</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">completion_delay</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">**</span><span class="n">drivetypes</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">reserved_sectors</span><span class="p">)</span></code></dt><dd><p>Attach disk unit <code class="docutils literal notranslate"><span class="pre">uptr</span></code> to file <code class="docutils literal notranslate"><span class="pre">cptr</span></code>.
Disk simulators should call this routine,
rather than the standard <code class="docutils literal notranslate"><span class="pre">attach_unit</span></code> routine.
The <code class="docutils literal notranslate"><span class="pre">drivetypes</span></code> is a <code class="code highlight c docutils literal highlight-c"><span class="nb">NULL</span></code>-terminated list of drive types available to autosize.</p>
</dd>
</dl>
<dl class="simple" id="sim-disk-detach">
<dt><code class="code highlight c docutils literal highlight-c"><span class="n">t_stat</span><span class="w"> </span><span class="n">sim_disk_detach</span><span class="w"> </span><span class="p">(</span><span class="n">UNIT</span><span class="w"> </span><span class="o">*</span><span class="n">uptr</span><span class="p">)</span></code></dt><dd><p>Detach disk unit <code class="docutils literal notranslate"><span class="pre">uptr</span></code> from its current file.</p>
</dd>
</dl>
<dl class="simple" id="sim-disk-set-fmt">
<dt><code class="code highlight c docutils literal highlight-c"><span class="n">t_stat</span><span class="w"> </span><span class="n">sim_disk_set_fmt</span><span class="w"> </span><span class="p">(</span><span class="n">UNIT</span><span class="w"> </span><span class="o">*</span><span class="n">uptr</span><span class="p">,</span><span class="w"> </span><span class="n">int32</span><span class="w"> </span><span class="n">val</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">cptr</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">desc</span><span class="p">)</span></code></dt><dd><p>Set the disk format for unit <code class="docutils literal notranslate"><span class="pre">uptr</span></code> to the format specified by string <code class="docutils literal notranslate"><span class="pre">cptr</span></code>.</p>
</dd>
</dl>
<dl class="simple" id="sim-disk-show-fmt">
<dt><code class="code highlight c docutils literal highlight-c"><span class="n">t_stat</span><span class="w"> </span><span class="n">sim_disk_show_fmt</span><span class="w"> </span><span class="p">(</span><span class="kt">FILE</span><span class="w"> </span><span class="o">*</span><span class="n">st</span><span class="p">,</span><span class="w"> </span><span class="n">UNIT</span><span class="w"> </span><span class="o">*</span><span class="n">uptr</span><span class="p">,</span><span class="w"> </span><span class="n">int32</span><span class="w"> </span><span class="n">val</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">desc</span><span class="p">)</span></code></dt><dd><p>Write the disk format for unit <code class="docutils literal notranslate"><span class="pre">uptr</span></code> to the file specified by descriptor <code class="docutils literal notranslate"><span class="pre">st</span></code>.</p>
</dd>
</dl>
<dl class="simple" id="sim-disk-set-capac">
<dt><code class="code highlight c docutils literal highlight-c"><span class="n">t_stat</span><span class="w"> </span><span class="n">sim_disk_set_capac</span><span class="w"> </span><span class="p">(</span><span class="n">UNIT</span><span class="w"> </span><span class="o">*</span><span class="n">uptr</span><span class="p">,</span><span class="w"> </span><span class="n">int32</span><span class="w"> </span><span class="n">val</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">cptr</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">desc</span><span class="p">)</span></code></dt><dd><p>Set the disk capacity for unit <code class="docutils literal notranslate"><span class="pre">uptr</span></code> to the capacity, in MB, specified by string <code class="docutils literal notranslate"><span class="pre">cptr</span></code>.</p>
</dd>
</dl>
<dl class="simple" id="sim-disk-show-capac">
<dt><code class="code highlight c docutils literal highlight-c"><span class="n">t_stat</span><span class="w"> </span><span class="n">sim_disk_show_capac</span><span class="w"> </span><span class="p">(</span><span class="kt">FILE</span><span class="w"> </span><span class="o">*</span><span class="n">st</span><span class="p">,</span><span class="w"> </span><span class="n">UNIT</span><span class="w"> </span><span class="o">*</span><span class="n">uptr</span><span class="p">,</span><span class="w"> </span><span class="n">int32</span><span class="w"> </span><span class="n">val</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">desc</span><span class="p">)</span></code></dt><dd><p>Write the capacity for unit <code class="docutils literal notranslate"><span class="pre">uptr</span></code> to the file specified by descriptor <code class="docutils literal notranslate"><span class="pre">st</span></code>.</p>
</dd>
</dl>
<dl class="simple" id="sim-disk-rdsect">
<dt><code class="code highlight c docutils literal highlight-c"><span class="n">t_stat</span><span class="w"> </span><span class="n">sim_disk_rdsect</span><span class="w"> </span><span class="p">(</span><span class="n">UNIT</span><span class="w"> </span><span class="o">*</span><span class="n">uptr</span><span class="p">,</span><span class="w"> </span><span class="n">t_lba</span><span class="w"> </span><span class="n">lba</span><span class="p">,</span><span class="w"> </span><span class="n">uint8</span><span class="w"> </span><span class="o">*</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="n">t_seccnt</span><span class="w"> </span><span class="o">*</span><span class="n">sectsread</span><span class="p">,</span><span class="w"> </span><span class="n">t_seccnt</span><span class="w"> </span><span class="o">*</span><span class="n">sectstoread</span><span class="p">)</span></code></dt><dd><p>Read up to <code class="docutils literal notranslate"><span class="pre">sectstoread</span></code> sectors from sector number <code class="docutils literal notranslate"><span class="pre">lba</span></code> on unit <code class="docutils literal notranslate"><span class="pre">uptr</span></code> into buffer <code class="docutils literal notranslate"><span class="pre">buf</span></code>.
Return the number of sectors read in <code class="docutils literal notranslate"><span class="pre">sectsread</span></code>.</p>
</dd>
</dl>
<dl class="simple" id="sim-disk-rdsect-a">
<dt><code class="code highlight c docutils literal highlight-c"><span class="n">t_stat</span><span class="w"> </span><span class="n">sim_disk_rdsect_a</span><span class="w"> </span><span class="p">(</span><span class="n">UNIT</span><span class="w"> </span><span class="o">*</span><span class="n">uptr</span><span class="p">,</span><span class="w"> </span><span class="n">t_lba</span><span class="w"> </span><span class="n">lba</span><span class="p">,</span><span class="w"> </span><span class="n">uint8</span><span class="w"> </span><span class="o">*</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="n">t_seccnt</span><span class="w"> </span><span class="o">*</span><span class="n">sectsread</span><span class="p">,</span><span class="w"> </span><span class="n">t_seccnt</span><span class="w"> </span><span class="o">*</span><span class="n">sectstoread</span><span class="p">,</span><span class="w"> </span><span class="n">DISK_PCALLBACK</span><span class="w"> </span><span class="n">callback</span><span class="p">)</span></code></dt><dd><p>Read up to <code class="docutils literal notranslate"><span class="pre">sectstoread</span></code> sectors from sector number <code class="docutils literal notranslate"><span class="pre">lba</span></code> on unit <code class="docutils literal notranslate"><span class="pre">uptr</span></code> into buffer <code class="docutils literal notranslate"><span class="pre">buf</span></code> asynchronously.
Return the number of sectors read in <code class="docutils literal notranslate"><span class="pre">sectsread</span></code>,
and call <code class="docutils literal notranslate"><span class="pre">callback</span></code> routine on completion.</p>
</dd>
</dl>
<dl class="simple" id="sim-disk-wrsect">
<dt><code class="code highlight c docutils literal highlight-c"><span class="n">t_stat</span><span class="w"> </span><span class="n">sim_disk_wrsect</span><span class="w"> </span><span class="p">(</span><span class="n">UNIT</span><span class="w"> </span><span class="o">*</span><span class="n">uptr</span><span class="p">,</span><span class="w"> </span><span class="n">t_lba</span><span class="w"> </span><span class="n">lba</span><span class="p">,</span><span class="w"> </span><span class="n">uint8</span><span class="w"> </span><span class="o">*</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="n">t_seccnt</span><span class="w"> </span><span class="o">*</span><span class="n">sectswritten</span><span class="p">,</span><span class="w"> </span><span class="n">t_seccnt</span><span class="w"> </span><span class="o">*</span><span class="n">sectstowrite</span><span class="p">)</span></code></dt><dd><p>Write <code class="docutils literal notranslate"><span class="pre">sectstowrite</span></code> sectors from buffer <code class="docutils literal notranslate"><span class="pre">buf</span></code> to disk sector number <code class="docutils literal notranslate"><span class="pre">lba</span></code> on unit <code class="docutils literal notranslate"><span class="pre">uptr</span></code>.
Return the number of sectors written in <code class="docutils literal notranslate"><span class="pre">sectswritten</span></code>.</p>
</dd>
</dl>
<dl class="simple" id="sim-disk-wrsect-a">
<dt><code class="code highlight c docutils literal highlight-c"><span class="n">t_stat</span><span class="w"> </span><span class="n">sim_disk_wrsect_a</span><span class="w"> </span><span class="p">(</span><span class="n">UNIT</span><span class="w"> </span><span class="o">*</span><span class="n">uptr</span><span class="p">,</span><span class="w"> </span><span class="n">t_lba</span><span class="w"> </span><span class="n">lba</span><span class="p">,</span><span class="w"> </span><span class="n">uint8</span><span class="w"> </span><span class="o">*</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="n">t_seccnt</span><span class="w"> </span><span class="o">*</span><span class="n">sectswritten</span><span class="p">,</span><span class="w"> </span><span class="n">t_seccnt</span><span class="w"> </span><span class="o">*</span><span class="n">sectstowrite</span><span class="p">,</span><span class="w"> </span><span class="n">DISK_PCALLBACK</span><span class="w"> </span><span class="n">callback</span><span class="p">)</span></code></dt><dd><p>Write <code class="docutils literal notranslate"><span class="pre">sectstowrite</span></code> sectors from buffer <code class="docutils literal notranslate"><span class="pre">buf</span></code> to disk sector number <code class="docutils literal notranslate"><span class="pre">lba</span></code> on unit <code class="docutils literal notranslate"><span class="pre">uptr</span></code> asynchronously.
Return the number of sectors written in <code class="docutils literal notranslate"><span class="pre">sectswritten</span></code>,
and call <code class="docutils literal notranslate"><span class="pre">callback</span></code> routine on completion.</p>
</dd>
</dl>
<dl class="simple" id="sim-disk-unload">
<dt><code class="code highlight c docutils literal highlight-c"><span class="n">t_stat</span><span class="w"> </span><span class="n">sim_disk_unload</span><span class="w"> </span><span class="p">(</span><span class="n">UNIT</span><span class="w"> </span><span class="o">*</span><span class="n">uptr</span><span class="p">)</span></code></dt><dd><p>Unload or detach a disk as needed.</p>
</dd>
</dl>
<dl class="simple" id="sim-disk-set-asynch">
<dt><code class="code highlight c docutils literal highlight-c"><span class="n">t_stat</span><span class="w"> </span><span class="n">sim_disk_set_asynch</span><span class="w"> </span><span class="p">(</span><span class="n">UNIT</span><span class="w"> </span><span class="o">*</span><span class="n">uptr</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">latency</span><span class="p">)</span></code></dt><dd><p>Enable asynchronous operation for I/O to disk unit <code class="docutils literal notranslate"><span class="pre">uptr</span></code>.</p>
</dd>
</dl>
<dl class="simple" id="sim-disk-clr-asynch">
<dt><code class="code highlight c docutils literal highlight-c"><span class="n">t_stat</span><span class="w"> </span><span class="n">sim_disk_clr_asynch</span><span class="w"> </span><span class="p">(</span><span class="n">UNIT</span><span class="w"> </span><span class="o">*</span><span class="n">uptr</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">latency</span><span class="p">)</span></code></dt><dd><p>Disable asynchronous operation for I/O to disk unit <code class="docutils literal notranslate"><span class="pre">uptr</span></code>.</p>
</dd>
</dl>
<dl class="simple" id="sim-disk-reset">
<dt><code class="code highlight c docutils literal highlight-c"><span class="n">t_stat</span><span class="w"> </span><span class="n">sim_disk_reset</span><span class="w"> </span><span class="p">(</span><span class="n">UNIT</span><span class="w"> </span><span class="o">*</span><span class="n">uptr</span><span class="p">)</span></code></dt><dd><p>Reset unit <code class="docutils literal notranslate"><span class="pre">uptr</span></code>.
This routine should be called when a tape unit is reset.</p>
</dd>
</dl>
<dl class="simple" id="sim-disk-isavailable">
<dt><code class="code highlight c docutils literal highlight-c"><span class="n">t_bool</span><span class="w"> </span><span class="n">sim_disk_isavailable</span><span class="w"> </span><span class="p">(</span><span class="n">UNIT</span><span class="w"> </span><span class="o">*</span><span class="n">uptr</span><span class="p">)</span></code></dt><dd><p>Check to see if disk is available for I/O, return <code class="code highlight c docutils literal highlight-c"><span class="n">TRUE</span></code> if so.</p>
</dd>
</dl>
<dl class="simple" id="sim-disk-isavailable-a">
<dt><code class="code highlight c docutils literal highlight-c"><span class="n">t_bool</span><span class="w"> </span><span class="n">sim_disk_isavailable_a</span><span class="w"> </span><span class="p">(</span><span class="n">UNIT</span><span class="w"> </span><span class="o">*</span><span class="n">uptr</span><span class="p">,</span><span class="w"> </span><span class="n">DISK_PCALLBACK</span><span class="w"> </span><span class="n">callback</span><span class="p">)</span></code></dt><dd><p>Check to see if disk is available for I/O asynchronously.
Return <code class="code highlight c docutils literal highlight-c"><span class="n">TRUE</span></code> if so.</p>
</dd>
</dl>
<dl class="simple" id="sim-disk-wrp">
<dt><code class="code highlight c docutils literal highlight-c"><span class="n">t_bool</span><span class="w"> </span><span class="n">sim_disk_wrp</span><span class="w"> </span><span class="p">(</span><span class="n">UNIT</span><span class="w"> </span><span class="o">*</span><span class="n">uptr</span><span class="p">)</span></code></dt><dd><p>Return <code class="code highlight c docutils literal highlight-c"><span class="n">TRUE</span></code> if unit <code class="docutils literal notranslate"><span class="pre">uptr</span></code> is write-protected.</p>
</dd>
</dl>
<dl class="simple" id="sim-disk-size">
<dt><code class="code highlight c docutils literal highlight-c"><span class="n">t_addr</span><span class="w"> </span><span class="n">sim_disk_size</span><span class="w"> </span><span class="p">(</span><span class="n">UNIT</span><span class="w"> </span><span class="o">*</span><span class="n">uptr</span><span class="p">)</span></code></dt><dd><p>Get disk size.</p>
</dd>
</dl>
<p><a class="reference internal" href="#sim-disk-attach"><code class="docutils literal notranslate"><span class="pre">sim_disk_attach</span></code></a>,
<a class="reference internal" href="#sim-disk-detach"><code class="docutils literal notranslate"><span class="pre">sim_disk_detach</span></code></a>,
<a class="reference internal" href="#sim-disk-set-fmt"><code class="docutils literal notranslate"><span class="pre">sim_disk_set_fmt</span></code></a>,
<a class="reference internal" href="#sim-disk-show-fmt"><code class="docutils literal notranslate"><span class="pre">sim_disk_show_fmt</span></code></a>,
and <a class="reference internal" href="#sim-disk-set-capac"><code class="docutils literal notranslate"><span class="pre">sim_disk_set_capac</span></code></a> return standard SCP status codes;
the other disk library routines return private codes for success and failure.
Success status is <code class="docutils literal notranslate"><span class="pre">DKSE_OK</span></code> and any other value is an error.
<code class="docutils literal notranslate"><span class="pre">errno</span></code> usually will have the appropriate error code:</p>
<table class="docutils align-left">
<tbody>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">DKSE_OK</span></code></p></td>
<td><p>Operation successful</p></td>
</tr>
</tbody>
</table>
<p><a class="reference internal" href="#sim-disk-set-fmt"><code class="docutils literal notranslate"><span class="pre">sim_disk_set_fmt</span></code></a>,
<a class="reference internal" href="#sim-disk-show-fmt"><code class="docutils literal notranslate"><span class="pre">sim_disk_show_fmt</span></code></a>,
<a class="reference internal" href="#sim-disk-set-capac"><code class="docutils literal notranslate"><span class="pre">sim_disk_set_capac</span></code></a>,
and <a class="reference internal" href="#sim-disk-show-capac"><code class="docutils literal notranslate"><span class="pre">sim_disk_show_capac</span></code></a> should be referenced by an entry in the disk device’s modifier list, as follows:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">MTAB</span><span class="w"> </span><span class="n">disk_mod</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">{</span><span class="w"> </span><span class="n">MTAB_XTD</span><span class="o">|</span><span class="n">MTAB_VDV</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;FORMAT&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;FORMAT&quot;</span><span class="p">,</span>
<span class="w">      </span><span class="o">&amp;</span><span class="n">sim_disk_set_fmt</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">sim_disk_show_fmt</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="w"> </span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span><span class="w"> </span><span class="n">MTAB_XTD</span><span class="o">|</span><span class="n">MTAB_VUN</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;CAPACITY&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;CAPACITY&quot;</span><span class="p">,</span>
<span class="w">      </span><span class="o">&amp;</span><span class="n">sim_disk_set_capac</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">sim_disk_show_capac</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="w"> </span><span class="p">},</span>
<span class="w">    </span><span class="cm">/* … */</span>
<span class="p">};</span>
</pre></div>
</div>
</section>
<section id="breakpoint-support">
<h3><span class="sectnum">1.6.4. </span>Breakpoint support<a class="headerlink" href="#breakpoint-support" title="Permalink to this heading">¶</a></h3>
<p>SIMH provides a highly flexible and extensible breakpoint subsystem to assist in debugging simulated code.
Its features include:</p>
<ul class="simple">
<li><p>Up to 26 different kinds of breakpoints <a class="footnote-reference brackets" href="#id9" id="id8" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a></p></li>
<li><p>Unlimited numbers of breakpoints</p></li>
<li><p>Proceed counts for each breakpoint</p></li>
<li><p>Automatic execution of commands when a breakpoint is taken</p></li>
</ul>
<p>If debugging is going to be a major activity on a simulator,
implementation of a full-featured breakpoint facility will be of immense help to users.</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id9" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id8">1</a><span class="fn-bracket">]</span></span>
<p>Breakpoint type C should probably be avoided since the <code class="docutils literal notranslate"><span class="pre">-C</span></code> switch is used by the <code class="docutils literal notranslate"><span class="pre">SHOW</span> <span class="pre">BREAK</span> <span class="pre">-C</span></code> command to display currently defined breakpoints as commands which can be entered in a subsequent invocation of the simulator to recreate the same breakpoint set.</p>
</aside>
</aside>
<section id="breakpoint-basics">
<h4><span class="sectnum">1.6.4.1. </span>Breakpoint basics<a class="headerlink" href="#breakpoint-basics" title="Permalink to this heading">¶</a></h4>
<p>SIMH breakpoints are characterized by a type,
an address,
a class,
a proceed count,
and an action string.
Breakpoint types are arbitrary and are defined by the virtual machine.
Each breakpoint type is assigned a unique letter.
All simulators to date provide execution (“E”) breakpoints.
A useful extension would be to provide breakpoints on read (“R”) and write (“W”) data access.
Even finer gradations are possible,
e.g., physical versus virtual addressing,
DMA versus CPU access,
and so on.</p>
<p>Breakpoints can be assigned to devices other than the CPU,
but breakpoints don’t contain a device pointer.
Thus, each device must have its own unique set of breakpoint types.
For example, if a simulator contained a programmable graphics processor,
it would need a separate instruction breakpoint type
(e.g., type G rather than E).</p>
<p>The virtual machine defines the valid breakpoint types to SIMH through two variables:</p>
<dl class="simple" id="sim-brk-types">
<dt><code class="docutils literal notranslate"><span class="pre">sim_brk_types</span></code></dt><dd><p>Initialized by the VM
(usually in the CPU reset routine)
to a mask of all supported breakpoints;
bit 0 (low-order bit) corresponds to type “A”,
bit 1 to type “B”, etc.</p>
</dd>
</dl>
<dl class="simple" id="sim-brk-dflt">
<dt><code class="docutils literal notranslate"><span class="pre">sim_brk_dflt</span></code></dt><dd><p>Initialized by the VM to the mask for the default breakpoint type.</p>
</dd>
</dl>
<p>SIMH in turn provides the virtual machine with a summary of all the breakpoint types that currently have active breakpoints:</p>
<dl class="simple" id="sim-brk-summ">
<dt><code class="docutils literal notranslate"><span class="pre">sim_brk_summ</span></code></dt><dd><p>Maintained by SIMH;
provides a bitmask summary of whether any breakpoints of a particular type have been defined.</p>
</dd>
</dl>
<p>When the virtual machine reaches the point in its execution cycle corresponding to a breakpoint type,
it tests to see if any breakpoints of that type are active.
If so, it calls <code class="docutils literal notranslate"><span class="pre">sim_brk_test</span></code> to see if a breakpoint of a specified type (or types) is set at the current address.
Here is an example from the fetch phase,
testing for an execution breakpoint:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/* Test for breakpoint before fetching next instruction */</span>

<span class="k">if</span><span class="w"> </span><span class="p">((</span><span class="n">sim_brk_summ</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">SWMASK</span><span class="w"> </span><span class="p">(</span><span class="sc">&#39;E&#39;</span><span class="p">))</span><span class="w"> </span><span class="o">&amp;&amp;</span>
<span class="w">     </span><span class="n">sim_brk_test</span><span class="w"> </span><span class="p">(</span><span class="n">PC</span><span class="p">,</span><span class="w"> </span><span class="n">SWMASK</span><span class="w"> </span><span class="p">(</span><span class="sc">&#39;E&#39;</span><span class="p">)))</span><span class="w"> </span><span class="o">&lt;</span><span class="n">execution</span><span class="w"> </span><span class="k">break</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>If the virtual machine implements only one kind of breakpoint,
then testing <a class="reference internal" href="#sim-brk-summ"><code class="docutils literal notranslate"><span class="pre">sim_brk_summ</span></code></a> for non-zero suffices.
Even if there are multiple breakpoint types,
a simple non-zero test distinguishes the no-breakpoints case
(normal run mode)
from debugging mode and provides sufficient efficiency.</p>
<p>When a breakpoint match is detected by <code class="docutils literal notranslate"><span class="pre">sim_brk_test</span></code>,
the global variables <code class="docutils literal notranslate"><span class="pre">sim_brk_match_type</span></code> and <code class="docutils literal notranslate"><span class="pre">sim_brk_match_addr</span></code> are set to reflect the details of the match that was found.
Simulator code can use this information directly or SIMH provides internal facilities to report the details of breakpoints which have been matched.
For example:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">BRKTYPTAB</span><span class="w"> </span><span class="n">cpu_breakpoints</span><span class="w"> </span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">BRKTYPE</span><span class="p">(</span><span class="sc">&#39;E&#39;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Execute Instruction at Virtual Address&quot;</span><span class="p">),</span>
<span class="w">    </span><span class="n">BRKTYPE</span><span class="p">(</span><span class="sc">&#39;P&#39;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Execute Instruction at Physical Address&quot;</span><span class="p">),</span>
<span class="w">    </span><span class="n">BRKTYPE</span><span class="p">(</span><span class="sc">&#39;R&#39;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Read from Virtual Address&quot;</span><span class="p">),</span>
<span class="w">    </span><span class="n">BRKTYPE</span><span class="p">(</span><span class="sc">&#39;S&#39;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Read from Physical Address&quot;</span><span class="p">),</span>
<span class="w">    </span><span class="n">BRKTYPE</span><span class="p">(</span><span class="sc">&#39;W&#39;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Write to Virtual Address&quot;</span><span class="p">),</span>
<span class="w">    </span><span class="n">BRKTYPE</span><span class="p">(</span><span class="sc">&#39;X&#39;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Write to Physical Address&quot;</span><span class="p">),</span>
<span class="w">    </span><span class="p">{</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">}</span>
<span class="p">};</span>

<span class="n">t_stat</span><span class="w"> </span><span class="nf">cpu_reset</span><span class="w"> </span><span class="p">(</span><span class="n">DEVICE</span><span class="w"> </span><span class="o">*</span><span class="n">dptr</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="cm">/* ... */</span>
<span class="w">    </span><span class="n">sim_brk_dflt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">SWMASK</span><span class="w"> </span><span class="p">(</span><span class="sc">&#39;E&#39;</span><span class="p">);</span>
<span class="w">    </span><span class="n">sim_brk_types</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sim_brk_dflt</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">SWMASK</span><span class="w"> </span><span class="p">(</span><span class="sc">&#39;P&#39;</span><span class="p">)</span><span class="w"> </span><span class="o">|</span>
<span class="w">                    </span><span class="n">SWMASK</span><span class="w"> </span><span class="p">(</span><span class="sc">&#39;R&#39;</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">SWMASK</span><span class="w"> </span><span class="p">(</span><span class="sc">&#39;S&#39;</span><span class="p">)</span><span class="w"> </span><span class="o">|</span>
<span class="w">                    </span><span class="n">SWMASK</span><span class="w"> </span><span class="p">(</span><span class="sc">&#39;W&#39;</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">SWMASK</span><span class="w"> </span><span class="p">(</span><span class="sc">&#39;X&#39;</span><span class="p">);</span>
<span class="w">    </span><span class="n">sim_brk_type_desc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cpu_breakpoints</span><span class="p">;</span>
<span class="w">    </span><span class="cm">/* ... */</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In the breakpoint dispatch code, something like:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">reason</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">STOP_IBKPT</span><span class="p">;</span>
<span class="n">sim_messagef</span><span class="w"> </span><span class="p">(</span><span class="n">reason</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;%s&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">sim_brk_message</span><span class="p">());</span>
<span class="cm">/* and then sim_instr() returns with: */</span>
<span class="k">return</span><span class="w"> </span><span class="n">reason</span><span class="p">;</span>
</pre></div>
</div>
<p>Or, if it is desirable to suppress the standard message produced when returning to SCP,
the following may be used:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">reason</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">STOP_IBKPT</span><span class="p">;</span>
<span class="n">reason</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sim_messagef</span><span class="w"> </span><span class="p">(</span><span class="n">reason</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">sim_brk_message</span><span class="p">());</span>
<span class="cm">/* and then sim_instr() returns with: */</span>
<span class="k">return</span><span class="w"> </span><span class="n">reason</span><span class="p">;</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">sim_messagef</span></code> produces a message which contains either the breakpoint type and the matched breakpoint address
(if <code class="docutils literal notranslate"><span class="pre">sim_brk_type_desc</span></code> is not set),
or the type mapped to it related description as indicated in the <code class="docutils literal notranslate"><span class="pre">BRKTYPTAB</span></code> pointed to by <code class="docutils literal notranslate"><span class="pre">sim_brk_typ_desc</span></code>.</p>
</section>
<section id="testing-for-breakpoints">
<h4><span class="sectnum">1.6.4.2. </span>Testing for breakpoints<a class="headerlink" href="#testing-for-breakpoints" title="Permalink to this heading">¶</a></h4>
<p>Breakpoint testing must be done at every point in the instruction decode and execution cycle where an event relating to a breakpoint type occurs.
If a virtual machine implements data breakpoints,
it simplifies implementation if data reads and writes are centralized in subroutines,
rather than scattered throughout the code.
For this reason (among others),
it is good practice to perform memory access through subroutines,
rather than by direct access to the memory array.</p>
<p>As an example,
consider a virtual machine with a central memory read subroutine.
This routine takes an additional parameter,
the type of read (often required for memory protection):</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#define IF 0  </span><span class="cm">/* Fetch */</span>
<span class="cp">#define ID 1  </span><span class="cm">/* Indirect */</span>
<span class="cp">#define RD 2  </span><span class="cm">/* Data read */</span>
<span class="cp">#define WR 3  </span><span class="cm">/* Data write */</span>

<span class="n">t_stat</span><span class="w"> </span><span class="nf">Read</span><span class="w"> </span><span class="p">(</span><span class="n">uint32</span><span class="w"> </span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="n">uint32</span><span class="w"> </span><span class="o">*</span><span class="n">dat</span><span class="p">,</span><span class="w"> </span><span class="n">uint32</span><span class="w"> </span><span class="n">acctyp</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="n">uint32</span><span class="w"> </span><span class="n">bkpt_type</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">SWMASK</span><span class="w"> </span><span class="p">(</span><span class="sc">&#39;E&#39;</span><span class="p">),</span><span class="w"> </span><span class="n">SWMASK</span><span class="w"> </span><span class="p">(</span><span class="sc">&#39;N&#39;</span><span class="p">),</span>
<span class="w">        </span><span class="n">SWMASK</span><span class="w"> </span><span class="p">(</span><span class="sc">&#39;R&#39;</span><span class="p">),</span><span class="w"> </span><span class="n">SWMASK</span><span class="w"> </span><span class="p">(</span><span class="sc">&#39;W&#39;</span><span class="p">)</span>
<span class="w">    </span><span class="p">};</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">((</span><span class="n">sim_brk_summ</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">bkpt_type</span><span class="p">[</span><span class="n">acctyp</span><span class="p">])</span><span class="w"> </span><span class="o">&amp;&amp;</span>
<span class="w">         </span><span class="n">sim_brk_test</span><span class="w"> </span><span class="p">(</span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="n">bkpt_type</span><span class="p">[</span><span class="n">acctyp</span><span class="p">])){</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">STOP_BKPT</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">else</span><span class="w"> </span><span class="o">*</span><span class="n">dat</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">M</span><span class="p">[</span><span class="n">addr</span><span class="p">];</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">SCPE_OK</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This routine provides differentiated breakpoints for execution,
indirect addresses,
and data reads,
with a single test.</p>
</section>
<section id="the-replay-problem">
<h4><span class="sectnum">1.6.4.3. </span>The replay problem<a class="headerlink" href="#the-replay-problem" title="Permalink to this heading">¶</a></h4>
<p>When a breakpoint is taken,
control returns to the SIMH control package.
Depending on the code structure of the simulated system and the particular type of breakpoint,
a breakpoint may be taken before or after a specific activity has completed.
If it is taken before the operation has actually been performed,
when execution resumes,
the same breakpoint will be reached and taken again immediately.
This could result in an endless loop,
with the simulator never progressing beyond a breakpoint.</p>
<p>To address this problem,
when a breakpoint is taken,
SIMH remembers the breakpoint that was taken and the instruction executed count when that particular breakpoint was taken.
If the next breakpoint test for that breakpoint type is to the same address and the instruction execution count is the same, SIMH suppresses the breakpoint.
Thus, the simulator can make progress past the breakpoint but will take the breakpoint again if control returns to the same address.</p>
<p>In order to properly suppress replay breakpoints it is important that the bookkeeping that a simulator does to record the instructions actually executed not be done when a breakpoint is taken.
This bookkeeping is done by adjustments to <a class="reference internal" href="#sim-interval"><code class="docutils literal notranslate"><span class="pre">sim_interval</span></code></a> and subsequent calls to <a class="reference internal" href="#sim-process-event"><code class="docutils literal notranslate"><span class="pre">sim_process_event</span></code></a>.
If a simulator returns from <a class="reference internal" href="#sim-instr"><code class="docutils literal notranslate"><span class="pre">sim_instr()</span></code></a> due to a breakpoint, either the adjustment to <a class="reference internal" href="#sim-interval"><code class="docutils literal notranslate"><span class="pre">sim_interval</span></code></a> should be done after all breakpoint checking,
or the return logic that handles breakpoints should unwind any <a class="reference internal" href="#sim-interval"><code class="docutils literal notranslate"><span class="pre">sim_interval</span></code></a> adjustment that may have happened.</p>
<p>Most simulators will implement a CPU execution breakpoint concept such that the breakpoint is taken prior to the instruction at the breakpoint address having executed.
This allows for the user to continue execution from breakpoint and the simulator will produce precisely the same results as if the breakpoint hadn’t been there.
In order for this to be true,
when a breakpoint is taken,
not only must <a class="reference internal" href="#sim-interval"><code class="docutils literal notranslate"><span class="pre">sim_interval</span></code></a> be restored to its value prior to the breakpoint,
but all other simulator specific state must also be retained.
This state includes program counter,
the contents of registers,
condition codes and memory that may have already changed prior to the call to <code class="docutils literal notranslate"><span class="pre">sim_brk_test</span></code> that causes the breakpoint to be taken.
Achieving this is simplest with basic PC based execution breakpoints and gets more complicated with breakpoints based on various memory reference activities.</p>
</section>
<section id="breakpoint-classes">
<h4><span class="sectnum">1.6.4.4. </span>Breakpoint classes<a class="headerlink" href="#breakpoint-classes" title="Permalink to this heading">¶</a></h4>
<p>SIMH implements up to 8 breakpoint classes.
Each breakpoint class has its own state.
Thus, if the E, R, and W breakpoints are assigned to separate classes,
each will be suppressed in turn until the next breakpoint test on that class that fails or that uses a different address.</p>
<p>Breakpoint classes are arbitrary identifiers and can be assigned by the simulator writer as desired.
The class is specified as part of the breakpoint type in the call to <code class="docutils literal notranslate"><span class="pre">sim_brk_test</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="mi">31</span><span class="p">:</span><span class="mi">29</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">Class</span> <span class="n">number</span> <span class="p">(</span><span class="mi">0</span> <span class="n">by</span> <span class="n">default</span><span class="p">)</span>
<span class="o">&lt;</span><span class="mi">25</span><span class="p">:</span><span class="mi">0</span><span class="o">&gt;</span>  <span class="o">=</span> <span class="n">Bitmask</span> <span class="n">of</span> <span class="nb">breakpoint</span> <span class="n">types</span>
</pre></div>
</div>
<p>Note that breakpoint classes and breakpoint types are orthogonal.
Thus, classes can be used to distinguish different cases of the same breakpoint type.
For example, in an SMP system with <code class="docutils literal notranslate"><span class="pre">n</span></code> processors,
classes <code class="docutils literal notranslate"><span class="pre">0</span></code>..<code class="docutils literal notranslate"><span class="pre">n-1</span></code> could be used for E-breakpoints for processors <code class="docutils literal notranslate"><span class="pre">0</span></code>..<code class="docutils literal notranslate"><span class="pre">n-1</span></code>.
Or in a VAX, classes <code class="docutils literal notranslate"><span class="pre">1</span></code>..<code class="docutils literal notranslate"><span class="pre">6</span></code> could be used for data breakpoints on operands <code class="docutils literal notranslate"><span class="pre">1</span></code>..<code class="docutils literal notranslate"><span class="pre">6</span></code>,
with <code class="docutils literal notranslate"><span class="pre">0</span></code> reserved for the CPU’s E-breakpoints.</p>
</section>
</section>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">Python</a></h1>








<h3>Navigation</h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="simh_doc.html">SimH Users' Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="simh_swre.html">SimH Sample Software Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="simh_faq.html">SimH FAQ</a></li>
<li class="toctree-l1"><a class="reference internal" href="nova_doc.html">Data General Nova</a></li>
<li class="toctree-l1"><a class="reference internal" href="pdp1_doc.html">Digital Equipment Corporation PDP-1</a></li>
<li class="toctree-l1"><a class="reference internal" href="pdp18b_doc.html">Digital Equipment Corporation PDP-4, PDP-7, PDP-9, PDP-15</a></li>
<li class="toctree-l1"><a class="reference internal" href="pdp8_doc.html">Digital Equipment Corporation PDP-8</a></li>
<li class="toctree-l1"><a class="reference internal" href="pdp10_doc.html">Digital Equipment Corporation PDP-10</a></li>
<li class="toctree-l1"><a class="reference internal" href="pdp11_doc.html">Digital Equipment Corporation PDP-11</a></li>
<li class="toctree-l1"><a class="reference internal" href="vax780_doc.html">Digital Equipment Corporation VAX-11/780</a></li>
<li class="toctree-l1"><a class="reference internal" href="vax_doc.html">Digital Equipment Corporation MicroVAX 3900</a></li>
<li class="toctree-l1"><a class="reference internal" href="gri_doc.html">GRI Computer Corporation GRI-909</a></li>
<li class="toctree-l1"><a class="reference internal" href="i1401_doc.html">IBM 1401</a></li>
<li class="toctree-l1"><a class="reference internal" href="i1620_doc.html">IBM 1620</a></li>
<li class="toctree-l1"><a class="reference internal" href="i7094_doc.html">IBM 7094</a></li>
<li class="toctree-l1"><a class="reference internal" href="id_doc.html">Interdata (Perkin Elmer) 16b and 32b systems</a></li>
<li class="toctree-l1"><a class="reference internal" href="h316_doc.html">Honeywell H316/H516</a></li>
<li class="toctree-l1"><a class="reference internal" href="lgp_doc.html">Royal-Mcbee LGP-30 (and LGP-21)</a></li>
<li class="toctree-l1"><a class="reference internal" href="sds_doc.html">Scientific Data Systems SDS-940</a></li>
<li class="toctree-l1"><a class="reference internal" href="sigma_doc.html">Xerox Data Systems Sigma 32b systems</a></li>
<li class="toctree-l1"><a class="reference internal" href="tx0_doc.html">TX-0 simulator usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="simh_breakpoints.html">The SIMH breakpoint subsystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="simh_magtape.html">SIMH magtape representation and handling</a></li>
<li class="toctree-l1"><a class="reference internal" href="simh_vmio.html">Adding an I/O device to a SIMH virtual machine</a></li>
<li class="toctree-l1"><a class="reference internal" href="simulators_acm_queue_2004.html">Simulators: virtual machines of the past and future</a></li>
<li class="toctree-l1"><a class="reference internal" href="Summary%20of%20IMP%20IO%20Device%20Codes.html">Summary of I/O commands for the Arpanet IMP</a></li>
<li class="toctree-l1"><a class="reference internal" href="ssem_doc.html">SSEM simulator usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="swtp6800_doc.html">SWTP 6800 simulator usage</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Writing a simulator for the SIMH system</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
      <li>Previous: <a href="swtp6800_doc.html" title="previous chapter"><span class="sectnum">1. </span>SWTP 6800 simulator usage</a></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 5.3.0</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="_sources/simh.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>